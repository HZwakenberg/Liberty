#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.4 (??? June ??th 2009) [????]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

#ifdef __cplusplus
}
#endif
#include "test_array_add_last1.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
    /* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    size_t dummy = fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
T7 M7={(void*)0,0,0};
T53 M53={0,(void*)0,0};
T176 M176={(void*)0,0,0,0};
T175 M175={(void*)0,0,0,0};
T63 M63=(void*)0;
T174 M174={(void*)0,0,0,0};
T25 M25={(void*)0,(void*)0,(void*)0,0};
/*Aliased storage area or unicode storage.*/
char*s25_10="\n";
char*s25_1367241514="TEST_ARRAY_ADD_LAST1: ERROR Test # ";
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
void se_print_run_time_stack (void) {
  handle(SE_HANDLE_ENTER_PRINT_STACK, NULL);
  fprintf(SE_ERR,"Eiffel program crash at run time.\n");
  fprintf(SE_ERR,"No trace when using option \"-boost\"\n");
  handle(SE_HANDLE_EXIT_PRINT_STACK, NULL);
}

void se_signal_handler(int sig) {
  handle(SE_HANDLE_RUNTIME_ERROR, NULL);
  printf("Received signal %d.\n",sig);
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}

/*INTEGER_64*/T3 r11decimal_digit(T11 C){
T3 R=0;
R=((T3)(((int32_t)(((int32_t)(C))))+(INT32_C(48))));
return R;
}/*--*/

/*INTEGER_64*/void r11append_in(T11 C,T0* a1){
T11 _val=0;
T2 _i=0;
T2 _idx=0;
if((C)==(INT8_C(0))){
r7extend(((T7*)a1),((T3)'0'));
}
else{
if(((int64_t)(C))>(INT64_C(0))){
_val=C;
_i=((int32_t)((/*RF2*/(((T7*)a1))->_count/*3p*/)))+(INT32_C(1));
}
else{
r7extend(((T7*)a1),((T3)'\055'));
_i=((int32_t)((/*RF2*/(((T7*)a1))->_count/*3p*/)))+(INT32_C(1));
_val=((int64_t)(C))%(INT64_C(10));
if(((int64_t)(_val))<=(INT64_C(0))){
r7extend(((T7*)a1),r11decimal_digit(-(_val)));
_val=-(((int64_t)(C))/(INT64_C(10)));
}
else{
r7extend(((T7*)a1),r11decimal_digit(((int64_t)(-(_val)))+(INT64_C(10))));
_val=((int64_t)(-(((int64_t)(C))/(INT64_C(10)))))-(INT64_C(1));
}
}
while(!((_val)==(INT8_C(0))))
{
r7extend(((T7*)a1),r11decimal_digit(((int64_t)(_val))%(INT64_C(10))));
_val=((int64_t)(_val))/(INT64_C(10));
}
_idx=(/*RF2*/(((T7*)a1))->_count/*3p*/);
while(!(((int32_t)(_i))>=(_idx)))
{
r7swap(((T7*)a1),_i,_idx);
_idx=((int32_t)(_idx))-(INT32_C(1));
_i=((int32_t)(_i))+(INT32_C(1));
}
}
}/*--*/

/*INTEGER_32*/T2 r2max(T2 C,T2 a1){
T2 R=0;
if(((int32_t)(C))>=(a1)){
R=C;
}
else{
R=a1;
}
return R;
}/*--*/

/*NATIVE_ARRAY[BOOLEAN]*/void r179clear_all(T179 C,T2 a1){
T6 _v=0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=((T6)(_v));
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[BOOLEAN]*/void r179set_all_with(T179 C,T6 a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=((T6)(a1));
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[BOOLEAN]*/T6 r179safe_equal(T6 a1,T6 a2){
T6 R=0;
T6 _e_type=0;
if((a1)==(a2)){
R=((T6)(1));
}
return R;
}/*--*/

/*NATIVE_ARRAY[BOOLEAN]*/T179 r179realloc(T179 C,T2 a1,T2 a2){
T179 R=(void*)0;
R=((T179)(se_calloc(a2,sizeof(T6))));
r179copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[BOOLEAN]*/void r179copy_from(T179 C,T179 a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=((T6)((a1)[_i]));
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[BOOLEAN]*/T2 r179occurrences(T179 C,T6 a1,T2 a2){
T2 R=0;
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
if(r179safe_equal((T6)(a1),(T6)((C)[_i]))){
R=((int32_t)(R))+(INT32_C(1));
}
_i=((int32_t)(_i))-(INT32_C(1));
}
return R;
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/void r178clear_all(T178 C,T2 a1){
T2 _v=0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/void r178set_all_with(T178 C,T2 a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(a1);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/T6 r178safe_equal(T2 a1,T2 a2){
T6 R=0;
T2 _e_type=0;
if((a1)==(a2)){
R=((T6)(1));
}
return R;
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/T178 r178realloc(T178 C,T2 a1,T2 a2){
T178 R=(void*)0;
R=((T178)(se_calloc(a2,sizeof(T2))));
r178copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/void r178copy_from(T178 C,T178 a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=((a1)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[INTEGER_32]*/T2 r178occurrences(T178 C,T2 a1,T2 a2){
T2 R=0;
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
if(r178safe_equal(a1,(C)[_i])){
R=((int32_t)(R))+(INT32_C(1));
}
_i=((int32_t)(_i))-(INT32_C(1));
}
return R;
}/*--*/

/*NATIVE_ARRAY[ANIMAL]*/void r177clear_all(T177 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[ANIMAL]*/void r177set_all_with(T177 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(a1);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[ANIMAL]*/T6 r177safe_equal(T0* a1,T0* a2){
T6 R=0;
T0* _e_type=(void*)0;
if((a1)==((void*)(a2))){
R=((T6)(1));
}
else{
if((a1)==((void*)((void*)0))){
}
else{
if((a2)==((void*)((void*)0))){
}
else{
if((_e_type)==((void*)((void*)0))){
R=((T6)());
}
}
}
}
return R;
}/*--*/

/*NATIVE_ARRAY[ANIMAL]*/T177 r177realloc(T177 C,T2 a1,T2 a2){
T177 R=(void*)0;
R=((T177)(se_calloc(a2,sizeof(T0*))));
r177copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[ANIMAL]*/void r177copy_from(T177 C,T177 a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=((a1)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[ANIMAL]*/T2 r177occurrences(T177 C,T0* a1,T2 a2){
T2 R=0;
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
if(r177safe_equal(a1,(C)[_i])){
R=((int32_t)(R))+(INT32_C(1));
}
_i=((int32_t)(_i))-(INT32_C(1));
}
return R;
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(T9 C,T2 a1){
T3 _v=0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(T9 C,T2 a1,T2 a2){
T9 R=(void*)0;
R=((T9)(se_calloc(a2,sizeof(T3))));
r9copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(T9 C,T9 a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=((a1)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*STRING*/void r7swap(T7* C,T2 a1,T2 a2){
T3 _tmp=0;
_tmp=r7item(C,a1);
r7put(C,r7item(C,a2),a1);
r7put(C,_tmp,a2);
}/*--*/

/*STRING*/void r7put(T7* C,T3 a1,T2 a2){
((/*RF2*/(C)->_storage/*3p*/))[((int32_t)(a2))-(INT32_C(1))]=(a1);
}/*--*/

/*STRING*/void r7extend(T7* C,T3 a1){
if(((/*RF2*/(C)->_count/*3p*/))==((/*RF2*/(C)->_capacity/*3p*/))){
r7ensure_capacity(C,((int32_t)((/*RF2*/(C)->_count/*3p*/)))+(INT32_C(1)));
}
((/*RF2*/(C)->_storage/*3p*/))[(/*RF2*/(C)->_count/*3p*/)]=(a1);
/*SFN*/(C->_count/*3p*/)=((int32_t)((/*RF2*/(C)->_count/*3p*/)))+(INT32_C(1));
}/*--*/

/*STRING*/void r7ensure_capacity(T7* C,T2 a1){
T2 _new_capacity=0;
if(((NULL!=((void*)((/*RF2*/(C)->_storage/*3p*/)))))==(0)){
_new_capacity=r2max(a1,INT32_C(32));
/*SFN*/(C->_storage/*3p*/)=((T9)(se_calloc(_new_capacity,sizeof(T3))));
/*SFN*/(C->_capacity/*3p*/)=_new_capacity;
}
else{
if(((int32_t)((/*RF2*/(C)->_capacity/*3p*/)))<(a1)){
_new_capacity=r2max(a1,(int32_t)(((uint32_t)((/*RF2*/(C)->_capacity/*3p*/)))*((uint32_t)(INT32_C(2)))));
/*SFN*/(C->_storage/*3p*/)=r9realloc((/*RF2*/(C)->_storage/*3p*/),(/*RF2*/(C)->_capacity/*3p*/),_new_capacity);
/*SFN*/(C->_capacity/*3p*/)=_new_capacity;
}
}
}/*--*/

/*STRING*/void r7make(T7* C,T2 a1){
if(((int32_t)(a1))>(INT32_C(0))){
if(((int32_t)((/*RF2*/(C)->_capacity/*3p*/)))<(a1)){
/*SFN*/(C->_storage/*3p*/)=((T9)(se_calloc(a1,sizeof(T3))));
/*SFN*/(C->_capacity/*3p*/)=a1;
}
}
/*SFN*/(C->_count/*3p*/)=INT32_C(0);
}/*--*/

/*STRING*/T3 r7item(T7* C,T2 a1){
T3 R=0;
R=((/*RF2*/(C)->_storage/*3p*/))[((int32_t)(a1))-(INT32_C(1))];
return R;
}/*--*/

/*ARRAY[BOOLEAN]*/void r176clear_all(T176* C){
T6 _value=0;
r176set_all_with(C,(T6)(_value));
}/*--*/

/*ARRAY[BOOLEAN]*/void r176set_all_with(T176* C,T6 a1){
r179set_all_with((/*RF2*/(C)->_storage/*4p*/),(T6)(a1),((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/)));
}/*--*/

/*ARRAY[BOOLEAN]*/void r176ensure_capacity_and_bounds(T176* C,T2 a1,T2 a2,T2 a3){
T6 _value=0;
/*SFN*/(C->_lower/*4p*/)=a2;
/*SFN*/(C->_upper/*4p*/)=a3;
if(((int32_t)(a1))>(INT32_C(0))){
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(a1)){
/*SFN*/(C->_storage/*4p*/)=((T179)(se_calloc(a1,sizeof(T6))));
/*SFN*/(C->_capacity/*4p*/)=a1;
}
else{
if(((int32_t)(a3))>=(a2)){
r176clear_all(C);
}
}
}
}/*--*/

/*ARRAY[BOOLEAN]*/void r176manifest_make(T176* C,T2 a1,T2 a2){
r176make(C,a2,((int32_t)(((int32_t)(a2))+(a1)))-(INT32_C(1)));
}/*--*/

/*ARRAY[BOOLEAN]*/void r176put(T176* C,T6 a1,T2 a2){
((/*RF2*/(C)->_storage/*4p*/))[((int32_t)(a2))-((/*RF2*/(C)->_lower/*4p*/))]=((T6)(a1));
}/*--*/

/*ARRAY[BOOLEAN]*/void r176make(T176* C,T2 a1,T2 a2){
r176ensure_capacity_and_bounds(C,((int32_t)(((int32_t)(a2))-(a1)))+(INT32_C(1)),a1,a2);
}/*--*/

/*ARRAY[BOOLEAN]*/void r176add_last(T176* C,T6 a1){
T2 _new_capacity=0;
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(((int32_t)(r176count(C)))+(INT32_C(1)))){
if(((/*RF2*/(C)->_capacity/*4p*/))==(INT8_C(0))){
_new_capacity=INT32_C(16);
/*SFN*/(C->_storage/*4p*/)=((T179)(se_calloc(_new_capacity,sizeof(T6))));
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
}
else{
_new_capacity=((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))*(INT32_C(2));
/*SFN*/(C->_storage/*4p*/)=r179realloc((/*RF2*/(C)->_storage/*4p*/),(/*RF2*/(C)->_capacity/*4p*/),_new_capacity);
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
}
}
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
r176put(C,(T6)(a1),(/*RF2*/(C)->_upper/*4p*/));
}/*--*/

/*ARRAY[BOOLEAN]*/T2 r176count(T176* C){
T2 R=0;
R=((int32_t)(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/))))+(INT32_C(1));
return R;
}/*--*/

/*ARRAY[BOOLEAN]*/void r176manifest_put(T176* C,T2 a1,T6 a2){
((/*RF2*/(C)->_storage/*4p*/))[a1]=((T6)(a2));
}/*--*/

/*ARRAY[BOOLEAN]*/T2 r176occurrences(T176* C,T6 a1){
T2 R=0;
R=r179occurrences((/*RF2*/(C)->_storage/*4p*/),(T6)(a1),((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/)));
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/void r175clear_all(T175* C){
T2 _value=0;
r175set_all_with(C,_value);
}/*--*/

/*ARRAY[INTEGER_32]*/void r175set_all_with(T175* C,T2 a1){
r178set_all_with((/*RF2*/(C)->_storage/*4p*/),a1,((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/)));
}/*--*/

/*ARRAY[INTEGER_32]*/void r175ensure_capacity_and_bounds(T175* C,T2 a1,T2 a2,T2 a3){
T2 _value=0;
/*SFN*/(C->_lower/*4p*/)=a2;
/*SFN*/(C->_upper/*4p*/)=a3;
if(((int32_t)(a1))>(INT32_C(0))){
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(a1)){
/*SFN*/(C->_storage/*4p*/)=((T178)(se_calloc(a1,sizeof(T2))));
/*SFN*/(C->_capacity/*4p*/)=a1;
}
else{
if(((int32_t)(a3))>=(a2)){
r175clear_all(C);
}
}
}
}/*--*/

/*ARRAY[INTEGER_32]*/void r175manifest_make(T175* C,T2 a1,T2 a2){
r175make(C,a2,((int32_t)(((int32_t)(a2))+(a1)))-(INT32_C(1)));
}/*--*/

/*ARRAY[INTEGER_32]*/void r175put(T175* C,T2 a1,T2 a2){
((/*RF2*/(C)->_storage/*4p*/))[((int32_t)(a2))-((/*RF2*/(C)->_lower/*4p*/))]=(a1);
}/*--*/

/*ARRAY[INTEGER_32]*/void r175make(T175* C,T2 a1,T2 a2){
r175ensure_capacity_and_bounds(C,((int32_t)(((int32_t)(a2))-(a1)))+(INT32_C(1)),a1,a2);
}/*--*/

/*ARRAY[INTEGER_32]*/void r175add_last(T175* C,T2 a1){
T2 _new_capacity=0;
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(((int32_t)(r175count(C)))+(INT32_C(1)))){
if(((/*RF2*/(C)->_capacity/*4p*/))==(INT8_C(0))){
_new_capacity=INT32_C(16);
/*SFN*/(C->_storage/*4p*/)=((T178)(se_calloc(_new_capacity,sizeof(T2))));
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
}
else{
_new_capacity=((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))*(INT32_C(2));
/*SFN*/(C->_storage/*4p*/)=r178realloc((/*RF2*/(C)->_storage/*4p*/),(/*RF2*/(C)->_capacity/*4p*/),_new_capacity);
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
}
}
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
r175put(C,a1,(/*RF2*/(C)->_upper/*4p*/));
}/*--*/

/*ARRAY[INTEGER_32]*/T2 r175count(T175* C){
T2 R=0;
R=((int32_t)(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/))))+(INT32_C(1));
return R;
}/*--*/

/*ARRAY[INTEGER_32]*/void r175manifest_put(T175* C,T2 a1,T2 a2){
((/*RF2*/(C)->_storage/*4p*/))[a1]=(a2);
}/*--*/

/*ARRAY[INTEGER_32]*/T2 r175occurrences(T175* C,T2 a1){
T2 R=0;
R=r178occurrences((/*RF2*/(C)->_storage/*4p*/),a1,((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/)));
return R;
}/*--*/

/*ARRAY[ANIMAL]*/void r174clear_all(T174* C){
T0* _value=(void*)0;
r174set_all_with(C,_value);
}/*--*/

/*ARRAY[ANIMAL]*/void r174set_all_with(T174* C,T0* a1){
r177set_all_with((/*RF2*/(C)->_storage/*4p*/),a1,((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/)));
}/*--*/

/*ARRAY[ANIMAL]*/void r174ensure_capacity_and_bounds(T174* C,T2 a1,T2 a2,T2 a3){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* _value=(void*)0;
tmp0/*and then*/=((T6)((_value)==((void*)((void*)0))));
if(tmp0/*and then*/){
tmp0/*and then*/=((T6)(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))>(INT32_C(0))));
}
if(tmp0/*and then*/){
r174clear_all(C);
}
/*SFN*/(C->_lower/*4p*/)=a2;
/*SFN*/(C->_upper/*4p*/)=a3;
if(((int32_t)(a1))>(INT32_C(0))){
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(a1)){
/*SFN*/(C->_storage/*4p*/)=((T177)(se_calloc(a1,sizeof(T0*))));
/*SFN*/(C->_capacity/*4p*/)=a1;
}
else{
/*auto-unlock tmp0*/tmp0/*and then*/=((T6)((_value)!=((void*)((void*)0))));
if(tmp0/*and then*/){
tmp0/*and then*/=((T6)(((int32_t)(a3))>=(a2)));
}
if(tmp0/*and then*/){
r174clear_all(C);
}
}
}
}/*--*/

/*ARRAY[ANIMAL]*/void r174manifest_make(T174* C,T2 a1,T2 a2){
r174make(C,a2,((int32_t)(((int32_t)(a2))+(a1)))-(INT32_C(1)));
}/*--*/

/*ARRAY[ANIMAL]*/void r174put(T174* C,T0* a1,T2 a2){
((/*RF2*/(C)->_storage/*4p*/))[((int32_t)(a2))-((/*RF2*/(C)->_lower/*4p*/))]=(a1);
}/*--*/

/*ARRAY[ANIMAL]*/void r174make(T174* C,T2 a1,T2 a2){
r174ensure_capacity_and_bounds(C,((int32_t)(((int32_t)(a2))-(a1)))+(INT32_C(1)),a1,a2);
}/*--*/

/*ARRAY[ANIMAL]*/void r174add_last(T174* C,T0* a1){
T2 _new_capacity=0;
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(((int32_t)(r174count(C)))+(INT32_C(1)))){
if(((/*RF2*/(C)->_capacity/*4p*/))==(INT8_C(0))){
_new_capacity=INT32_C(16);
/*SFN*/(C->_storage/*4p*/)=((T177)(se_calloc(_new_capacity,sizeof(T0*))));
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
}
else{
_new_capacity=((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))*(INT32_C(2));
/*SFN*/(C->_storage/*4p*/)=r177realloc((/*RF2*/(C)->_storage/*4p*/),(/*RF2*/(C)->_capacity/*4p*/),_new_capacity);
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
}
}
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
r174put(C,a1,(/*RF2*/(C)->_upper/*4p*/));
}/*--*/

/*ARRAY[ANIMAL]*/T2 r174count(T174* C){
T2 R=0;
R=((int32_t)(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/))))+(INT32_C(1));
return R;
}/*--*/

/*ARRAY[ANIMAL]*/void r174manifest_put(T174* C,T2 a1,T0* a2){
((/*RF2*/(C)->_storage/*4p*/))[a1]=(a2);
}/*--*/

/*ARRAY[ANIMAL]*/T2 r174occurrences(T174* C,T0* a1){
T2 R=0;
R=r177occurrences((/*RF2*/(C)->_storage/*4p*/),a1,((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-((/*RF2*/(C)->_lower/*4p*/)));
return R;
}/*--*/

/*STD_OUTPUT*/void r53filtered_flush(T53* C){
if(((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))>(INT32_C(0))){
r53write_buffer(C);
}
io_flush((stdout));
}/*--*/

/*STD_OUTPUT*/void r53filtered_put_character(T53* C,T3 a1){
if(((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))>=(INT32_C(4096))){
r53write_buffer(C);
}
((/*RF2*/(C)->_buffer/*3p*/))[(/*RF2*/(C)->_buffer_position/*3p*/)]=(a1);
/*SFN*/(C->_buffer_position/*3p*/)=((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))+(INT32_C(1));
if((a1)==(((T3)'\n'))){
r53write_buffer(C);
}
}/*--*/
T0*oBC13std_output=(void*)0;
int fBC13std_output=0;

/*STD_OUTPUT*/T0* r53std_output(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13std_output==0){fBC13std_output=1;{
tmp0/*new*/=((T0*)se_malloc(sizeof(T53)))/*3p*/;
*((T53*)tmp0/*new*/)=M53;
r53make(((T53*)tmp0/*new*/));
oBC13std_output=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13std_output;
}/*--*/

/*STD_OUTPUT*/void r53se_atexit(void){
r53filtered_flush((T53*)(r53std_output()));
}/*--*/

/*STD_OUTPUT*/void r53make(T53* C){
/*SFN*/(C->_buffer/*3p*/)=((T9)(se_calloc(INT32_C(4096),sizeof(T3))));
/*SFN*/(C->_capacity/*3p*/)=INT32_C(4096);
}/*--*/

/*STD_OUTPUT*/void r53flush(T53* C){
r53filtered_flush(C);
}/*--*/

/*STD_OUTPUT*/void r53put_string(T53* C,T0* a1){
T2 _i=0;
T2 _count=0;
_i=INT32_C(1);
_count=(/*RF2*/(((T7*)a1))->_count/*3p*/);
while(!(((int32_t)(_i))>(_count)))
{
r53filtered_put_character(C,r7item(((T7*)a1),_i));
_i=((int32_t)(_i))+(INT32_C(1));
}
}/*--*/

/*STD_OUTPUT*/void r53write_buffer(T53* C){
T2 _unused_result=0;
if(((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))>(INT32_C(0))){
_unused_result=io_fwrite((/*RF2*/(C)->_buffer/*3p*/),(/*RF2*/(C)->_buffer_position/*3p*/),(stdout));
/*SFN*/(C->_buffer_position/*3p*/)=INT32_C(0);
}
}/*--*/

/*STD_OUTPUT*/void r53put_integer(T53* C,T11 a1){
(/*RF2*/((T7*)(r53tmp_string()))->_count/*3p*/)=INT32_C(0);
r11append_in(a1,r53tmp_string());
r53put_string(C,r53tmp_string());
}/*--*/
T0*oBC31tmp_string=(void*)0;
int fBC31tmp_string=0;

/*STD_OUTPUT*/T0* r53tmp_string(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC31tmp_string==0){fBC31tmp_string=1;{
tmp0/*new*/=((T0*)se_malloc(sizeof(T7)))/*3p*/;
*((T7*)tmp0/*new*/)=M7;
r7make(((T7*)tmp0/*new*/),INT32_C(512));
oBC31tmp_string=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC31tmp_string;
}/*--*/

/*TEST_ARRAY_ADD_LAST1*/T0* r25std_output(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13std_output==0){fBC13std_output=1;{
tmp0/*new*/=((T0*)se_malloc(sizeof(T53)))/*3p*/;
*((T53*)tmp0/*new*/)=M53;
r53make(((T53*)tmp0/*new*/));
oBC13std_output=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13std_output;
}/*--*/

/*TEST_ARRAY_ADD_LAST1*/void r25assert(T25* C,T6 a1){
/*SFN*/(C->_cpt/*4p*/)=((int32_t)((/*RF2*/(C)->_cpt/*4p*/)))+(INT32_C(1));
if((a1)==(0)){
r53put_string((T53*)(r25std_output()),se_ms(35,s25_1367241514));
r53put_integer((T53*)(r25std_output()),/*IC*/(T11)((/*RF2*/(C)->_cpt/*4p*/)));
r53put_string((T53*)(r25std_output()),se_ms(1,s25_10));
}
}/*--*/

/*TEST_ARRAY_ADD_LAST1*/void r25make(T25* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
T0* _cat=(void*)0;
/*SFN*/(C->_t_boolean/*4p*/)=se_manifest176(INT32_C(1),1,
1);
_i=INT32_C(1);
while(!((_i)==(INT8_C(100))))
{
_i=((int32_t)(_i))+(INT32_C(1));
r176add_last((T176*)((/*RF2*/(C)->_t_boolean/*4p*/)),(T6)(1));
r25assert(C,(T6)((r176occurrences((T176*)((/*RF2*/(C)->_t_boolean/*4p*/)),(T6)(1)))==(_i)));
}
/*SFN*/(C->_t_integer/*4p*/)=se_manifest175(INT32_C(1),1,
/*{INTEGER_32 56}*/INT32_C(56));
_i=INT32_C(1);
while(!((_i)==(INT8_C(100))))
{
_i=((int32_t)(_i))+(INT32_C(1));
r175add_last((T175*)((/*RF2*/(C)->_t_integer/*4p*/)),INT32_C(56));
r25assert(C,(T6)((r175occurrences((T175*)((/*RF2*/(C)->_t_integer/*4p*/)),INT32_C(56)))==(_i)));
}
tmp0/*new*/=((T0*)(se_malloc(1)));
_cat=tmp0/*new*/;
/*tmp0.unlock*/
/*SFN*/(C->_t_animal/*4p*/)=se_manifest174(INT32_C(1),1,
_cat);
_i=INT32_C(1);
while(!((_i)==(INT8_C(100))))
{
_i=((int32_t)(_i))+(INT32_C(1));
r174add_last((T174*)((/*RF2*/(C)->_t_animal/*4p*/)),_cat);
r25assert(C,(T6)((r174occurrences((T174*)((/*RF2*/(C)->_t_animal/*4p*/)),_cat))==(_i)));
}
}/*--*/

T0*se_ms(int c,char*e){
/* Allocate a Manifest STRING.*/
T7*s=((T7*)se_malloc(sizeof(T7)));
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)se_malloc(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

T0*se_string(char*e){
/* Allocate an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=((T7*)se_malloc(sizeof(T7)));
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)se_malloc(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/
T25*eiffel_root_object=(void*)0;
int se_argc;
char**se_argv;

void se_atexit(void){
r53se_atexit();
}/*--*/

void initialize_eiffel_runtime(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
se_argc=argc;
se_argv=argv;
atexit(se_atexit);
#ifdef SIGQUIT
signal(SIGQUIT,se_signal_handler);
#endif
#ifdef SIGILL
signal(SIGILL,se_signal_handler);
#endif
#ifdef SIGABRT
signal(SIGABRT,se_signal_handler);
#endif
#ifdef SIGFPE
signal(SIGFPE,se_signal_handler);
#endif
#ifdef SIGSEGV
signal(SIGSEGV,se_signal_handler);
#endif
#ifdef SIGBUS
signal(SIGBUS,se_signal_handler);
#endif
#ifdef SIGSYS
signal(SIGSYS,se_signal_handler);
#endif
#ifdef SIGTRAP
signal(SIGTRAP,se_signal_handler);
#endif
#ifdef SIGXCPU
signal(SIGXCPU,se_signal_handler);
#endif
#ifdef SIGXFSZ
signal(SIGXFSZ,se_signal_handler);
#endif
tmp0/*root*/=((T0*)se_malloc(sizeof(T25)))/*4p*/;
*((T25*)tmp0/*root*/)=M25;
eiffel_root_object=((T25*)tmp0/*root*/);
/*tmp0.unlock*/
}/*--*/

int main(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
initialize_eiffel_runtime(argc,argv);
tmp0/*prof*/=((T0*)eiffel_root_object);
r25make(((T25*)tmp0/*prof*/));
handle(SE_HANDLE_NORMAL_EXIT, NULL);
/*tmp0.unlock*/
exit(0);
return 0;
}/*--*/

T0* se_manifest174(T2 initial_lower,int argc,...){
/*ARRAY[ANIMAL]*/
T174*C;
va_list pa;
int i=0;
int imax;
va_start(pa,argc);
C=se_malloc(sizeof(*C));
*C=M174;
r174manifest_make(C,argc,initial_lower);
imax=argc;
while (i < imax) {
T0* element=((T0*)(va_arg(pa,T0*)));
r174manifest_put(C,i++,element);
}
va_end(pa);
return ((T0*)C);
}/*--*/

T0* se_manifest176(T2 initial_lower,int argc,...){
/*ARRAY[BOOLEAN]*/
T176*C;
va_list pa;
int i=0;
int imax;
va_start(pa,argc);
C=se_malloc(sizeof(*C));
*C=M176;
r176manifest_make(C,argc,initial_lower);
imax=argc;
while (i < imax) {
T6 element=((T6)(va_arg(pa,int)));
r176manifest_put(C,i++,element);
}
va_end(pa);
return ((T0*)C);
}/*--*/

T0* se_manifest175(T2 initial_lower,int argc,...){
/*ARRAY[INTEGER_32]*/
T175*C;
va_list pa;
int i=0;
int imax;
va_start(pa,argc);
C=se_malloc(sizeof(*C));
*C=M175;
r175manifest_make(C,argc,initial_lower);
imax=argc;
while (i < imax) {
T2 element=((T2)(va_arg(pa,int)));
r175manifest_put(C,i++,element);
}
va_end(pa);
return ((T0*)C);
}/*--*/

#ifdef __cplusplus
}
#endif
