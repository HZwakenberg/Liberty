#!/bin/sh

## Process C files finding enumeration and turning them into proper
## Eiffel enumeration class with the design of Eiffel Wrapper
## Libraries Collection

print_usage () {
    cat <<EOF
$(basename $0) OPTIONS FILES

Options:
  --header=HEADER   Use HEADER instead of current file for the external calls

EOF
}

eiffellize_class_name () {
    ## Eiffellize class name 
    if [ -n $1 ] ; then 
	echo $1 | 
	sed 's/\B\([A-Z]\)/_\1/g' |
	tr a-z- A-Z_
    fi
}

process_file () {
    if [ -n $1 ] ; then 
	FILE=$1
	echo Processing $FILE
        
        # Loop initialization
	PROCESSABLE=$(mktemp -t create-eiffel-enum-processable-XXXX)
	PROCESSED=$(mktemp -t partially-processed-enum-XXXX)
	# echo Processable $PROCESSABLE Processed $PROCESSED
	cp $FILE $PROCESSABLE 
	
	while csplit --quiet --prefix=$PROCESSED $PROCESSABLE "/\benum\b/" "/}/1" 2>/dev/null
	do
	    cp ${PROCESSED}02 $PROCESSABLE
	    ENUM=${PROCESSED}01
	    process_enum $ENUM
	done
	# Cleanup
	rm $PROCESSABLE ${PROCESSED} \
	    ${PROCESSED}00 ${PROCESSED}01 ${PROCESSED}02 \
	    2>/dev/null 
    else
	echo process_file got no file to work on
    fi
}

process_enum () {
    if [ -n $1 ] ; then 
	ENUM_FILE=$1
	ENUM_NAME=$(grep ";" $ENUM_FILE | tr --delete --complement [:alnum:] )
	EIFFEL_ENUM=$(eiffellize_class_name $ENUM_NAME)
	EIFFEL_ENUM_FILE=$(echo $EIFFEL_ENUM.e | tr '[:upper:]' '[:lower:]')
	echo Converting $ENUM_NAME into $EIFFEL_ENUM, file "$EIFFEL_ENUM_FILE"
	ENUM_PART=$(mktemp)
	csplit --quiet --prefix=$ENUM_PART $ENUM_FILE "/{/1" "/}/" 
	ENUMERATION_ITEMS=$(cat ${ENUM_PART}01 | tr --delete ",")
	echo Enumeration items: $ENUMERATION_ITEMS 
        ## TODO: build a list with the longest common part removed to
        ## be used as Eiffel feature names
	echo  LONGEST_PREFIX = $(longest_prefix $ENUMERATION_ITEMS)
	
	emit_header
	emit_setters
	emit_queries
	emit_values
	emit_footer

	rm ${ENUM_PART}* 2>/dev/null # Cleaning up
    else echo No enum file to work on
    fi
}

longest_prefix () {
    LENGTH=$(echo $@ | wc --max-line-length )
    PREFIXES=$@
    echo >/dev/stderr Looking for longest prefix at length $LENGTH in $PREFIXES...
    until [ -n $PREFIX ] 
    do
	PREFIXES=$(echo $@ | sort | cut --bytes -$LENGTH )
	if [ $(echo $PREFIXES | wc --lines ) -eq 1 ]
	then 
	    PREFIX=$PREFIXES
	    echo >/dev/stderr Found \"$PREFIX\"
	else
	    echo >/dev/stderr Not found, length $LENGTH -- $PREFIXES --
	    LENGTH=$(($LENGTH - 1 ))
	fi
    done
}

emit_header () {
    cat >$EIFFEL_ENUM_FILE <<EOF
indexing
	description: "Enum $ENUM_NAME"
	copyright: "[
					Copyright (C) $YEARS $COPYRIGHT_HOLDER,
					
					This library is free software; you can redistribute it and/or
					modify it under the terms of the GNU Lesser General Public License
					as published by the Free Software Foundation; either version 2.1 of
					the License, or (at your option) any later version.
					
					This library is distributed in the hope that it will be useful, but
					WITHOUT ANY WARRANTY; without even the implied warranty of
					MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
					Lesser General Public License for more details.

					You should have received a copy of the GNU Lesser General Public
					License along with this library; if not, write to the Free Software
					Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
					02110-1301 USA
				]"

--- WARINING! THIS FILE IS AUTOMATICALLY GENERATED. ANY CHANGE TO THIS WILL BE OVERWRITTEN BY NEXT EXECUTION OF GENERATIONG SCIPT!

expanded class $EIFFEL_ENUM
       -- Enum $ENUM_NAME

insert ENUM

creation $CREATION_CLAUSE

EOF
}

emit_setters () {
    cat >>$EIFFEL_ENUM_FILE <<EOF
feature -- Setters

EOF
    for VALUE in $ENUMERATION_ITEMS; do
	ITEM=$(echo $VALUE| tr '[:upper:]' '[:lower:]')
	cat >>$EIFFEL_ENUM_FILE <<EOF
    set_$ITEM is 
       do
          value := $ITEM 
       ensure is_$ITEM 
       end

EOF
    done
}

emit_queries () {
    cat >>$EIFFEL_ENUM_FILE <<EOF
feature -- Queries

EOF
    for VALUE in $ENUMERATION_ITEMS; do
	ITEM=$(echo $VALUE| tr '[:upper:]' '[:lower:]')
	cat >>$EIFFEL_ENUM_FILE <<EOF
    is_$ITEM: BOOLEAN is do Result:=$ITEM end
EOF
    done
}

emit_values () {
    cat >$>EIFFEL_ENUM_FILE <<EOF
feature {WRAPPER, WRAPPER_HANDLER} -- Low level values

EOF
    for VALUE in $ENUMERATION_ITEMS; do
	ITEM=$(echo $VALUE| tr '[:upper:]' '[:lower:]')
	cat >>$EIFFEL_ENUM_FILE <<EOF
    $ITEM: INTEGER is
         external "C macro use $HEADER"
         alias "$VALUE"
         end
EOF
    done
}

emit_footer () {
    cat >>$EIFFEL_ENUM_FILE <<EOF
end -- class $EIFFEL_ENUM
EOF
}

	
for FILE in $@ ; do
    process_file $FILE
done
