#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by 
Liberty Eiffel The GNU Eiffel Compiler, Eiffel tools and libraries
    release 2013.09 (Charles Adler, Jr.)

Copyright (C), 2011-2013 - C.ADRIAN, P.REDAELLI, R.MACK
    http://www.liberty-eiffel.org

Original SmartEiffel code:
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER, F.MERIZEN
    http://smarteiffel.loria.fr
C Compiler options used: -pipe -O2 -fno-gcse
*/

#ifdef __cplusplus
}
#endif
#include "compile_to_c.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


void se_check_malloc(void*result) {
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
}

/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  se_check_malloc(result);
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed: %lu x %lu).\n", nmemb, size);
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
    /* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    size_t dummy = fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
EIF_BOOLEAN mbi_inc (int32_t *p) {
    if ((++(*p)) == 0) {
      return 1;
    }
    else {
      return 0;
    }
}

EIF_BOOLEAN mbi_add (int32_t a, int32_t b, int32_t *p) {
  (*p) = a + b;
  if (((uint32_t)(*p)) < ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_add_with_inc (int32_t a, int32_t b, int32_t *p) {
  (*p) = a + b + 1;
  if (((uint32_t)(*p)) <= ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_dec (int32_t *p) {
    if (((*p)--) == 0) {
      return 1;
    }
    else {
      return 0;
    }
}

EIF_BOOLEAN mbi_subtract (int32_t a, int32_t b, int32_t *p) {
  (*p) = a - b;
  if (((uint32_t)(*p)) > ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_subtract_with_dec (int32_t a, int32_t b, int32_t *p) {
  (*p) = a - b - 1;
  if (((uint32_t)(*p)) >= ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_INTEGER mbi_multiply (int32_t a, int32_t b, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_multiply_with_add (int32_t a, int32_t b, int32_t c, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b)) + ((uint32_t)(c));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_multiply_with_2_add (int32_t a, int32_t b, int32_t c, int32_t d, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b)) + ((uint32_t)(c)) + ((uint32_t)(d));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_divide (int32_t a, int32_t b, int32_t d, int32_t *r) {
  uint64_t x;
  x = (((uint64_t)((uint32_t)(a))) << 32) + ((uint32_t)(b));
  (*r) = (uint32_t)(x % ((uint32_t)(d)));
  return ((uint32_t)(x / ((uint32_t)(d))));
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_posix
static char** envp(void) {
  static char* result[] = {"PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL};
  return result;
}

static int arr_size(char** arr){
  int size = 0;
  while(arr[size] != NULL) {
    size++;
  }
  return size;
}

static int find_variable(char** env, char* var){
  int location;
  int src_size;
  if(var == NULL || env == NULL)
    return -1;
  src_size = strchr(var, '=') - var + 1;
  for(location = 0; env[location] != NULL; location++){
    if(strncasecmp(env[location], var, src_size) == 0){
      return location;
    }
  }
  return -1;
}

static void check_write(int expected, int actual) {
   if (actual != expected) {
    handle(SE_HANDLE_RUNTIME_ERROR, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#elif !defined(SE_BOOST)
    error0("Routine failure: could not write.", NULL);
#else
    fprintf(SE_ERR,"Routine failure (write returned %d but expected %d).\n", actual, expected);
    exit(EXIT_FAILURE);
#endif
  }
}

EIF_BOOLEAN basic_exec_posix_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  int id = fork();
  if (id == 0) {
    /* child */

    if(in_fd) {
      dup2(in_fd[0], 0);
      close(in_fd[1]);
    }

    if(out_fd) {
      dup2(out_fd[1], 1);
      close(out_fd[0]);
    }

    if(err_fd) {
      dup2(err_fd[1], 2);
      close(err_fd[0]);
    }

    if (prog == NULL && args == NULL) {
      data->running = 1;
      data->child = 1;
#ifdef SE_SEDB
      sedb_duplicate();
#endif
      return 1;
    } else {
      if (add_env == NULL && keep_env) {
        execvp(prog, args); /* NO RETURN in child */
        se_print_run_time_stack();
        exit(1);
      }else{
        char** new_env;
        char** old_env;
        int old_size, add_size;
        int src, dest = 0;
        if(keep_env){
          old_env = environ;
        }else{
          old_env = envp();
        }
        old_size = arr_size(old_env);
        add_size = arr_size(add_env);
        new_env = malloc(sizeof(void*) * (old_size + add_size));

        /* we first copy the pointers from the old env */
        for(src = 0; src < old_size; src++){
          new_env[dest++] = old_env[src];
        }

        /* now the ones from add_env */
        for(src = 0; src < add_size; src++){
          int override = find_variable(old_env, add_env[src]);
          if (override >= 0){
            new_env[override] = add_env[src];
          }else{
            new_env[dest++] = add_env[src];
          }
        }

        execve(prog, args, new_env); /* NO RETURN in child */
        se_print_run_time_stack();
        exit(1);
      }
    }
  }
  else if (id > 0) {
    /* father */
    data->id = id;
    data->running = 1;
    data->child = 0;
    if(in_fd) close(in_fd[0]);
    if(out_fd) close(out_fd[1]);
    if(err_fd) close(err_fd[1]);
    return 1;
  } else {
    return 0; /* ... in father only */
  }
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  EIF_BOOLEAN result = (EIF_BOOLEAN)0;
  int status;
  if (data->running) {
    int id = waitpid(data->id, &status, WNOHANG);
    if (id == data->id) {
      /* child is finished */
      result = (EIF_BOOLEAN)(id == data->id);
      basic_exec_cleanup(data, status);
    }
  }
  else{
    result = (EIF_BOOLEAN)1;
  }
  return result;
}

void basic_exec_wait(se_exec_data_t*data) {
  int status;
  if (data->running) {
    int id = waitpid(data->id, &status, 0);
    if (id == data->id) {
      basic_exec_cleanup(data, status);
    }
  }
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
  data->status = WEXITSTATUS(status);
  data->running = 0;
}

EIF_INTEGER basic_exec_posix_get_character (EIF_INTEGER fd) {
  EIF_INTEGER result = -1;
  char buf[1];
  ssize_t r = read(fd, buf, 1);
  if (r > 0) {
    result = 0xff & ((EIF_INTEGER)(buf[0]));
  }
  return result;
}

void basic_exec_posix_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
  char buf[1];
  buf[0] = c;
  check_write(1, write(fd, buf, 1));
}

void basic_exec_posix_wait_any(se_exec_data_t*data) {
  data->id = wait(&data->status);
}

void basic_exec_posix_any_finished(se_exec_data_t*data) {
  data->id = waitpid(-1, &data->status, WNOHANG);
}

/*
 * See http://stackoverflow.com/questions/282176/waitpid-equivalent-with-timeout
 *
 * (with specific adaptation to Liberty Eiffel)
 */
static int waitpid_selfpipe[2];
static EIF_OBJECT waitpid_input;

static void waitpid_sigh(int n) {
   check_write(1, write(waitpid_selfpipe[1], "", 1));
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
   waitpid_input = obj;
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   static init = 0;
   static struct sigaction act;
   if (!init) {
      init = 1;
      if (pipe(waitpid_selfpipe) == -1) {
         waitpid_selfpipe[0] = -1;
      }
      else {
         fcntl(waitpid_selfpipe[0], F_SETFL, fcntl(waitpid_selfpipe[0], F_GETFL) | O_NONBLOCK);
         fcntl(waitpid_selfpipe[1], F_SETFL, fcntl(waitpid_selfpipe[1], F_GETFL) | O_NONBLOCK);
         memset(&act, 0, sizeof(act));
         act.sa_handler = waitpid_sigh;
         sigaction(SIGCHLD, &act, NULL);
      }
   }
   return waitpid_selfpipe[0];
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   static char dummy[4096];
   char *buffer = (char*)data;
   int pid, status;

   while (read(waitpid_selfpipe[0], dummy, sizeof(dummy)) > 0);

   while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
      oob_info(waitpid_input, pid, status);
   }

   buffer[0] = 0;
   return 1;
}
#else
EIF_INTEGER basic_exec_posix_get_character (EIF_INTEGER fd) {
  return 0;
}

void basic_exec_posix_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
}

void basic_exec_posix_wait_any(se_exec_data_t*data) {
}

void basic_exec_posix_any_finished(se_exec_data_t*data) {
}

EIF_BOOLEAN basic_exec_posix_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  return 0;
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_none
/* Dummy implementation that always reports an error back to the Eiffel side */

EIF_BOOLEAN basic_exec_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  return 0;
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  return (EIF_BOOLEAN)0;
}

void basic_exec_wait(se_exec_data_t*data) {
}

EIF_INTEGER basic_exec_get_character (EIF_INTEGER fd) {
  return (EIF_INTEGER)0;
}

void basic_exec_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   return -1;
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   return -1;
}
#else
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_win32
static char* envp(void) {
  static char* result = "\0";/* *** Maybe call GetFullPathName to set =C: and friends */
  return result;
}

EIF_BOOLEAN basic_exec_win32_execute(se_exec_data_t*data, char*args, EIF_BOOLEAN keep_env, char*add_env, HANDLE*in_h, HANDLE*out_h, HANDLE*err_h) {
  STARTUPINFO start_info;
  EIF_BOOLEAN result = 0;

  ZeroMemory( &start_info, sizeof(STARTUPINFO) );

  start_info.cb = sizeof(STARTUPINFO);
  if(in_h) {
    start_info.hStdInput = in_h[0];
    SetHandleInformation(in_h[1], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdInput) goto leave;
  if(out_h) {
    start_info.hStdOutput = out_h[1];
    SetHandleInformation(out_h[0], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdOutput) goto leave;
  if(err_h) {
    start_info.hStdError = err_h[1];
    SetHandleInformation(err_h[0], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdError = GetStdHandle(STD_ERROR_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdError) goto leave;
  start_info.dwFlags |= STARTF_USESTDHANDLES;

  if(CreateProcess(NULL, args,
                   NULL,                                /* process security attributes          */
                   NULL,                                /* primary thread security attributes   */
                   TRUE,                                /* handles are inherited                */
                   0,                                   /* creation flags                       */
                   keep_env?NULL:envp(),
                   NULL,                                /* use parent's current directory       */
                   &start_info,                         /* STARTUPINFO pointer                  */
                   &data->process_information)) {       /* receives PROCESS_INFORMATION         */
    CloseHandle(data->process_information.hThread);
    data->running = 1;
    result = 1;
  }
 leave:
  if(in_h) CloseHandle(in_h[0]);
  if(out_h) CloseHandle(out_h[1]);
  if(err_h) CloseHandle(err_h[1]);
  return result;
}

EIF_BOOLEAN basic_exec_init_pipe(HANDLE*pipe) {
  SECURITY_ATTRIBUTES security_attributes;

  // Set the bInheritHandle flag so pipe handles are inherited.

  security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
  security_attributes.bInheritHandle = TRUE;
  security_attributes.lpSecurityDescriptor = NULL;

  return CreatePipe(pipe, pipe+1, &security_attributes, 0);
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  EIF_BOOLEAN result = (EIF_BOOLEAN)0;
  if (data->running) {
    result = (WaitForSingleObject(data->process_information.hProcess, 0) == WAIT_OBJECT_0);
    if (result) {
      /* child is finished */
      DWORD status;
      GetExitCodeProcess(data->process_information.hProcess, &status);
      /* *** Could have failed */
      basic_exec_cleanup(data, status);
    }
  }
  else{
    result = (EIF_BOOLEAN)1;
  }
  return result;
}

void basic_exec_wait(se_exec_data_t*data) {
  if (data->running) {
    DWORD status;
    WaitForSingleObject(data->process_information.hProcess, INFINITE);
    GetExitCodeProcess(data->process_information.hProcess, &status);
    /* *** Any of these calls could have failed, right? */
    basic_exec_cleanup(data, status);
  }
}

EIF_INTEGER basic_exec_win32_get_character (HANDLE h) {
  char result;
  DWORD num_read;

  ReadFile(h, &result, 1, &num_read, NULL);
  if(!num_read) return -1;
  return result;
}

void basic_exec_win32_put_character(HANDLE h, EIF_CHARACTER c) {
  DWORD num_written;

  WriteFile(h, &c, 1, &num_written, NULL);
  /* *** Do something if num_written!=1 or WriteFile returned 0. */
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
  data->status = status;
  data->running = 0;
  CloseHandle(data->process_information.hProcess);
}

EIF_BOOLEAN basic_exec_win32_wait_any(HANDLE*handles, DWORD count, se_exec_data_t*data) {
  DWORD result = WaitForMultipleObjects(count, handles, FALSE, INFINITE);
  EIF_BOOLEAN success = (result < (WAIT_OBJECT_0 + count));
  if(success) {
    int index = result - WAIT_OBJECT_0;
    HANDLE handle = handles[index];
    GetExitCodeProcess(handle, &data->status);
    data->process_information.hProcess = handle;
  }
  return success;
}

EIF_BOOLEAN basic_exec_win32_any_finished(HANDLE*handles, DWORD count, se_exec_data_t*data ) {
  DWORD result = WaitForMultipleObjects(count, handles, FALSE, 0);
  EIF_BOOLEAN success = (result < (WAIT_OBJECT_0 + count));
  if(success) {
    int index = result - WAIT_OBJECT_0;
    HANDLE handle = handles[index];
    GetExitCodeProcess(handle, &data->status);
    data->process_information.hProcess = handle;
  }
  return success;
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   return -1;
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   return -1;
}
#else
EIF_INTEGER basic_exec_win32_get_character (void *h) {
  return 0;
}

void basic_exec_win32_put_character(void *h, EIF_CHARACTER c) {
}

EIF_BOOLEAN basic_exec_win32_wait_any(void*handles, int count, se_exec_data_t*data) {
  return 0;
}

EIF_BOOLEAN basic_exec_win32_any_finished(void*handles, int count, se_exec_data_t*data) {
  return 0;
}

EIF_BOOLEAN basic_exec_win32_execute(se_exec_data_t*data, char*args, EIF_BOOLEAN keep_env, char*add_env, void*in_h, void*out_h, void*err_h) {
  return 0;
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#ifdef WIN32
#define SIMULATED_MODE
/* The simulated mode for WIN32.
*/
typedef struct _SIMULATED_DIR {
  HANDLE handle;
  WIN32_FIND_DATA data;
  int entry_used;
  char * pattern;
} SIMULATED_DIR;

static SIMULATED_DIR* simulated_opendir(char* path) {
  int len = strlen((char*)path);
  char* pattern = se_malloc(len + 5);
  SIMULATED_DIR* result = se_malloc(sizeof(SIMULATED_DIR));

  pattern = strcpy(pattern,(char*)path);
  if (pattern[len - 1] != '\\') pattern[len++] = '\\';
  pattern[len++] = '*';
  pattern[len++] = '.';
  pattern[len++] = '*';
  pattern[len++] = 0;
  result->handle = FindFirstFile(pattern,&(result->data));
  if (result->handle == INVALID_HANDLE_VALUE) {
    free(pattern);
    free(result);
    return NULL;
  } else {
    result->pattern = pattern;
  }
  result->entry_used = 0;
  return result;
}

static void* simulated_readdir(SIMULATED_DIR* dirstream) {
  if (dirstream->entry_used) {
    if (FindNextFile(dirstream->handle,&(dirstream->data))) {
      dirstream->entry_used = 1;
      return dirstream;
    }
    else {
      return NULL;
    }
  }
  else {
    dirstream->entry_used = 1;
    return dirstream;
  }
}

#define simulated_get_entry_name(x) ((x)->data.cFileName)

static int simulated_closedir(SIMULATED_DIR* dirstream) {
  FindClose(dirstream->handle);
  free(dirstream->pattern);
  free(dirstream);
  return 0;
}


/* GCC(MingW32) doesn't need these prototypes; whereas, LCC needs them. */
char * getcwd(char* buffer, int maxlen);
int chdir(const char* buffer);
int mkdir(const char* directory_path);
int rmdir(const char* directory_path);


#define simulated_getcwd(x, y) getcwd(x, y)
#define simulated_chdir(x) chdir(x)
#define simulated_rmdir(x) rmdir(x)

int simulated_mkdir(const char* directory_path, int perm) {

  mkdir(directory_path);
  return 0;
}

#endif  /* WIN32 */

#ifdef AMIGA
#define SIMULATED_MODE
/* The simulated mode for AmigaOS 2.04+
   Author: Thomas Aglassinger <agi@rieska.oulu.fi>

   Normally this shouldn't be necessary as all compilers include a
   simulation of the Un*x directory API. However, they differ in
   certain details, often resulting into compiler errors. Thus a
   implementation using native AmigaDOS calls seems preferable.

   Note that many of the happenings below have to deal with the
   various idiosyncracies of the "dos.library", which are not all
   documented clearly in the Autodocs. The biggest surprises should
   be reflected in comments. But consider reading chapter 17 of
   Ralph Babel's "Amiga Guru Book" before changing anything.
*/
#include <exec/types.h>
#include <dos/dos.h>
#include <dos/dostags.h>

#include <proto/exec.h>
#include <proto/dos.h>

typedef struct _SIMULATED_DIR {
  struct FileInfoBlock *info;
  BPTR lock;
} SIMULATED_DIR;


/* Release all resources allocated during `simulated_opendir'; also
   works correctly if structure was only partially initialized.
*/
static void free_simulated_dir(SIMULATED_DIR * dir) {
  if (dir != NULL) {
    if (dir->lock != NULL) {
      UnLock(dir->lock);
    }
    if (dir->info != NULL) {
      FreeDosObject(DOS_FIB, dir->info);
    }
    free(dir);
  }
}

static SIMULATED_DIR * simulated_opendir(char *path) {
  BOOL ok = FALSE;
  SIMULATED_DIR *result = se_malloc(sizeof(SIMULATED_DIR));

  if (result != NULL) {
    result->lock = NULL;
    result->info = (struct FileInfoBlock *) AllocDosObject(DOS_FIB, NULL);
    if (result->info != NULL) {
      result->lock = Lock(path, ACCESS_READ);
      if (result->lock != NULL) {
	ok = (Examine(result->lock, result->info) != DOSFALSE);
	if (ok) {
	  /* Ensure we are scanning a directory, not a file */
	  ok = (result->info->fib_DirEntryType >= 0)
	    && (result->info->fib_DirEntryType != ST_SOFTLINK);
	}
      }
    }
  }
  if (!ok) {
    free_simulated_dir(result);
    result = NULL;
  }
  return result;
}

static void * simulated_readdir(SIMULATED_DIR * dirstream) {
  BOOL ok;
  SIMULATED_DIR *result = NULL;

  ok = (ExNext(dirstream->lock, dirstream->info) != DOSFALSE);

  if (ok) {
    result = dirstream;
  }
  return (void *) result;
}

#define simulated_get_entry_name(entry) ((entry)->info->fib_FileName)

static int simulated_closedir(SIMULATED_DIR * dirstream) {
  free_simulated_dir(dirstream);
  return 0;
}


static EIF_POINTER simulated_getcwd(char *buffer, size_t maximum_length) {
     EIF_POINTER result = NULL;
     BPTR lock = Lock("", ACCESS_READ);
     if (lock != NULL) {
       if (NameFromLock(lock, buffer, maximum_length) != DOSFALSE) {
         result = (EIF_POINTER) buffer;
       }
       UnLock(lock);
     }
     return result;
   }

static int simulated_chdir(char *name) {
  int result = -1;
  BPTR lock = Lock(name, ACCESS_READ);
  if (lock != NULL) {
    /* Change the current working directory (CWD) of the task
     */
    BPTR old_lock = CurrentDir(lock);

    /* Attempt to update internal buffer of the process.
       If we are not running in a process, but a plain task, this
       call does not cause any harm.
    */
    /* FIXME: What's the result of SetCurrentDirName() in a plain
       task? If it is FALSE, the below code won't work.
    */
    if (SetCurrentDirName(name)) {
      /* If this was successful, unlock `old_lock' because we
	 are not going to restore it later; this routine is one
	 of the few cases where such behavior is appropriate.
      */
      UnLock(old_lock);
      result = 0;
    }
    else {
      /* If it fails, restore the previous CWD and make the
	 whole routine fail.
      */
      CurrentDir(old_lock);
    }
  }
  return result;
}

static void strip_trailing_slash(char *path, size_t *length,
				 BOOL * stripped) {
  /* Used in `simulated_mkdir' and `simulated_rmdir' to temporarily
     blank out a possible traling slash (/) in the directory path.
     `restore_trailing_slash' puts it back in place afterwards.
  */
  *length = strlen(path);
  if ((*length > 0) && (path[*length - 1] == '/')) {
    *stripped = TRUE;
    path[*length - 1] = '\0';
  } else {
    *stripped = FALSE;
  }
}

static void restore_trailing_slash(char *path, size_t *length,
				   BOOL * stripped) {
  if (*stripped) {
    path[*length - 1] = '/';
  }
}

static int simulated_mkdir(char *directory_path, int permission) {
  BPTR lock;
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;

  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  lock = CreateDir(directory_path);
  if (lock != NULL) {
    UnLock(lock);
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}

static int simulated_rmdir(char *directory_path) {
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;

  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  if (DeleteFile(directory_path)) {
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}
#endif /* AMIGA */

/*--------------------------------------------------------------------
  At his point, either this is a Linux/POSIX platform or some
  SIMULATED_MODE is defined. Unsupported platform should add their own
  SIMULATED_MODE before.
*/

EIF_POINTER directory_open(EIF_POINTER path) {
#ifndef SIMULATED_MODE
  return (opendir(((char*) path)));
#else
  return (simulated_opendir(((char*) path)));
#endif
}

EIF_POINTER directory_read_entry(EIF_POINTER dirstream) {
#ifndef SIMULATED_MODE
  return readdir((DIR*)dirstream);
#else
  return simulated_readdir((SIMULATED_DIR*)dirstream);
#endif
}

EIF_POINTER directory_get_entry_name(EIF_POINTER entry) {
#ifndef SIMULATED_MODE
  return (((struct dirent*)entry)->d_name);
#else
  return simulated_get_entry_name((SIMULATED_DIR*)entry);
#endif
}

EIF_BOOLEAN directory_close(EIF_POINTER dirstream) {
  int status;
#ifndef SIMULATED_MODE
  status = (closedir((DIR*)dirstream) == 0);
#else
  status = (simulated_closedir((SIMULATED_DIR*)dirstream) == 0);
#endif
  return ((EIF_BOOLEAN)(status ? 1 : 0));
}

EIF_POINTER directory_cwd(void) {
  static char* buf = NULL;
#ifdef WIN32
  /* MS Windows requires size to be an int; whereas in non-windows systems,
     it needs to be size_t
  */
  static int size = 0;
#else
  static size_t size = 0;
#endif
  int status;
  if (buf == NULL) {
    size = 256;
    buf = (char*)se_malloc(size);
  }


#ifndef SIMULATED_MODE
  status = (getcwd(buf,size) != NULL);
#else
  status = (simulated_getcwd(buf,size) != NULL);
#endif


  if (status) {
    return buf;
  }
  else {
    free(buf);
    size = size * 2;
    buf = (char*)se_malloc(size);
    return directory_cwd();
  }
}

EIF_BOOLEAN directory_chdir(EIF_POINTER destination) {
  int status;
#ifndef SIMULATED_MODE
  status = (chdir((char*)destination));
#else
  status = simulated_chdir((char*)destination);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN directory_mkdir(EIF_POINTER directory_path){
  int status;
#ifndef SIMULATED_MODE
  status = (mkdir((char*)directory_path,0777));
#else
  status = simulated_mkdir((char*)directory_path,0777);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN directory_rmdir(EIF_POINTER directory_path){
  int status;
#ifndef SIMULATED_MODE
  status = rmdir((char*)directory_path);
#else
  status = simulated_rmdir((char*)directory_path);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/

EIF_INTEGER fstat_st_size(EIF_POINTER path) {

	struct stat buf;
	int test;

	test = stat(path, &buf);
	return (test == 0 ? buf.st_size : -1);

}

EIF_INTEGER_64 fstat_st_mtime(EIF_POINTER path) {

	struct stat buf;
	int test;

	test = stat(path, &buf);
	return (test == 0 ? buf.st_mtime : -1);

}

EIF_BOOLEAN fstat_st_is_file(EIF_POINTER path) {
#if defined S_ISREG
  struct stat buf;

  return stat((const char *)path, &buf)?0:!!S_ISREG(buf.st_mode);
#elif defined WIN32
  EIF_BOOLEAN result;
  HANDLE h=CreateFile((LPCTSTR)path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		      NULL, OPEN_EXISTING, 0, NULL);

  if(INVALID_HANDLE_VALUE == h) {
    return 0;
  }
  result = (GetFileType(h) == FILE_TYPE_DISK)
    && !(GetFileAttributes((LPCTSTR) path) & FILE_ATTRIBUTE_DIRECTORY);
  CloseHandle(h);
  return result;
#else
  printf("fstat_st_is_file (in SmartEiffel/sys/io/c/fstat.c)\nnot yet implemented for this architecture.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

EIF_BOOLEAN fstat_st_is_dir(EIF_POINTER path) {
#if defined S_ISDIR
  struct stat buf;

  return stat((const char *)path, &buf)?0:!!S_ISDIR(buf.st_mode);
#elif defined WIN32
  DWORD attr =GetFileAttributes((LPCTSTR) path);
  return (attr != INVALID_FILE_ATTRIBUTES)  && (attr & FILE_ATTRIBUTE_DIRECTORY);
#else
  printf("fstat_st_is_dir (in SmartEiffel/sys/io/c/fstat.c)\nnot yet implemented for this architecture.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
EIF_INTEGER basic_microsecond_microsecond = 0;
EIF_INTEGER_64 basic_microsecond_time = 0;

void _basic_microsecond_update(void) {
#ifndef WIN32
  struct timeval t;

  gettimeofday (&t, NULL);
  basic_microsecond_time = t.tv_sec;
  basic_microsecond_microsecond = t.tv_usec;
#else
  static DWORD ref_uptime = -1; /* max value as ref_uptime is unsigned */
  static time_t ref_time;
  DWORD uptime;

  /*  uptime = timeGetTime();*/
  uptime = GetTickCount();

  if (uptime < ref_uptime) {
    /* !!! this test manages first call AND 50th day ;-)  */
    ref_uptime = uptime;
    time(&ref_time);
  }

  basic_microsecond_time = ref_time + (uptime - ref_uptime)/1000;
  basic_microsecond_microsecond = ((uptime - ref_uptime) % 1000) * 1000;
#endif
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
void sprintf_real_64(EIF_CHARACTER* b, EIF_CHARACTER m, int32_t f, real64_t r) {
  char fmt[32];
  fmt[0]='%';
  fmt[1]='.';
  sprintf(fmt+2, "%d%c", f, m);
  sprintf((char*)b, fmt, r);
}

void sprintf_real_extended(EIF_CHARACTER* b, EIF_CHARACTER m, int32_t f, real_extended_t r) {
  char fmt[32];
  fmt[0]='%';
  fmt[1]='.';
  sprintf(fmt+2, "%dL%c", f, m);
  sprintf((char*)b, fmt, r);
}


int se_cmpT2082(T2082* o1,T2082* o2){
int R=0;
R = R || ((o1->_current_entry) != (o2->_current_entry));
R = R || ((o1->_directory_stream) != (o2->_directory_stream));
return R;
}/*--*/

int se_cmpT1894(T1894* o1,T1894* o2){
int R=0;
R = R || ((o1->_mangling) != (o2->_mangling));
return R;
}/*--*/

int se_cmpT2240(T2240* o1,T2240* o2){
int R=0;
return R;
}/*--*/

int se_cmpT2323(T2323* o1,T2323* o2){
int R=0;
R = R || ((o1->_hashed_string_memory) != (o2->_hashed_string_memory));
R = R || ((o1->_column) != (o2->_column));
R = R || ((o1->_line) != (o2->_line));
return R;
}/*--*/
T2606 M2606=0;
T2608 M2608=0;
T2614 M2614={2614,NULL};
T2616 M2616={2616,NULL};
T2621 M2621=0;

int se_cmpT2260(T2260* o1,T2260* o2){
int R=0;
R = R || ((o1->_time_memory) != (o2->_time_memory));
return R;
}/*--*/

int se_cmpT2027(T2027* o1,T2027* o2){
int R=0;
R = R || ((o1->_microsecond) != (o2->_microsecond));
R = R || se_cmpT2260(&(o1->_time), &(o2->_time));
return R;
}/*--*/
T2651 M2651={2651,NULL};
T2670 M2670={2670,NULL};
T2673 M2673={2673,NULL};
T2706 M2706={2706,NULL};

int se_cmpT1891(T1891* o1,T1891* o2){
int R=0;
R = R || ((o1->_hash_code) != (o2->_hash_code));
R = R || ((o1->_feature_name) != (o2->_feature_name));
R = R || ((o1->_class_name) != (o2->_class_name));
return R;
}/*--*/
T2723 M2723={2723,NULL};
T2726 M2726={2726,NULL};
T2733 M2733={2733,NULL};
T2737 M2737={2737,NULL};
T2745 M2745={2745,NULL};

int se_cmpT1867(T1867* o1,T1867* o2){
int R=0;
R = R || ((o1->_item_memory) != (o2->_item_memory));
R = R || ((o1->_capacity) != (o2->_capacity));
return R;
}/*--*/

int se_cmpT2078(T2078* o1,T2078* o2){
int R=0;
R = R || ((o1->_direct_error) != (o2->_direct_error));
R = R || ((o1->_direct_output) != (o2->_direct_output));
R = R || ((o1->_direct_input) != (o2->_direct_input));
R = R || ((o1->_group) != (o2->_group));
R = R || ((o1->_keep_environment) != (o2->_keep_environment));
return R;
}/*--*/
T2767 M2767={2767,NULL};
T2770 M2770={2770,NULL};
T2775 M2775={2775,NULL};
T2776 M2776={2776,NULL};
T2806 M2806={2806,NULL};
T2808 M2808={2808,NULL};
T2817 M2817={2817,NULL};
T2820 M2820={2820,NULL};
T2823 M2823={2823,NULL};
T2829 M2829={2829,NULL};
T2837 M2837={2837,NULL};
T2838 M2838={2838,NULL};
T2846 M2846={2846,NULL};
T2851 M2851={2851,NULL};
T2852 M2852={2852,NULL};
T2857 M2857={2857,NULL};
T2858 M2858={2858,NULL};
T2863 M2863={2863,NULL};
T2866 M2866={2866,NULL};
T2870 M2870={2870,NULL};
T2873 M2873={2873,NULL};
T2877 M2877={2877,NULL};
T2880 M2880={2880,NULL};
T2885 M2885={2885,NULL};
T2886 M2886={2886,NULL};
T2889 M2889={2889,NULL};
T2894 M2894={2894,NULL};
T2911 M2911={2911,NULL};
T2913 M2913={2913,NULL};
T2919 M2919={2919,NULL};
T2923 M2923={2923,NULL};
T2925 M2925={2925,NULL};
T2930 M2930={2930,NULL};
T2932 M2932={2932,NULL};
T2935 M2935={2935,NULL};
T2946 M2946={2946,NULL};
T2954 M2954={2954,NULL};
T2958 M2958={2958,NULL};
T2960 M2960=0;
T2963 M2963={2963,NULL};
T2968 M2968={2968,NULL};
T2978 M2978={2978,NULL};
T2981 M2981={2981,NULL};
T2985 M2985={2985,NULL};
T2990 M2990={2990,NULL};
T2995 M2995=0;

int se_cmpT2300(T2300* o1,T2300* o2){
int R=0;
R = R || ((o1->_first_error_character) != (o2->_first_error_character));
R = R || ((o1->_first_error_index) != (o2->_first_error_index));
R = R || ((o1->_first_error) != (o2->_first_error));
return R;
}/*--*/
T3028 M3028={3028,NULL};
T3031 M3031={3031,NULL};
T3034 M3034={3034,NULL};
T3035 M3035={3035,NULL};
T3038 M3038={3038,NULL};
T3049 M3049={3049,NULL};
T3054 M3054=0;
T3068 M3068=0;
T3076 M3076=0;
T3093 M3093={3093,NULL};
T3113 M3113=0;
T3117 M3117={3117,NULL};
T1580 M1580={(void*)0,0,0};
T1840 M1840=0;
T1661 M1661={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,{(void*)0,(void*)0},(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2544 M2544=(void*)0;
T1652 M1652={(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,0,0,0,0,(void*)0,(void*)0,0,0,0,0,{(void*)0,0,0},0,0,0,(void*)0,(void*)0,'\0',(void*)0,0,0};
T1674 M1674={(void*)0,(void*)0,(void*)0,0,0};
T1827 M1827={0,(void*)0,(void*)0,0,0,0,0,0,0,0,0,0,0,0,0,(void*)0,(void*)0,(void*)0,{(void*)0,0,0},0,0,0,(void*)0,'\0',(void*)0,0,0};
T1665 M1665={(void*)0,(void*)0,0,(void*)0,0,(void*)0,0,0,0,0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0};
T1659 M1659={0,(void*)0,0,(void*)0,0,0,0,0,0,0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0};
T1835 M1835={0,0};
T1825 M1825=(void*)0;
T1841 M1841=0;
T7 M7={7,0,0,0,0,(void*)0,0};
T2573 M2573={2573,0,0,(void*)0,0};
T1636 M1636={(void*)0,0};
T2574 M2574={(void*)0};
T1837 M1837={(void*)0,0,0,0,0};
T1839 M1839=0;
T2091 M2091=0;
T2082 M2082={(void*)0,(void*)0};
T1628 M1628={1628};
T2575 M2575={2575,(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2094 M2094={2094,(void*)0,(void*)0};
T2098 M2098={2098,(void*)0,(void*)0};
T2099 M2099={2099};
T2100 M2100={2100};
T2101 M2101={2101};
T2102 M2102={2102};
T2576 M2576={(void*)0};
T2577 M2577={0};
T1650 M1650={0,0,0,0,(void*)0,(void*)0,'\0',0,(void*)0,(void*)0};
T2093 M2093={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2006 M2006={0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2081 M2081=0;
T2005 M2005={2005,(void*)0,0,0,(void*)0,0,(void*)0,(void*)0};
T2196 M2196={2196,(void*)0};
T1631 M1631={1631,(void*)0};
T1619 M1619={1619,0,(void*)0,0,(void*)0};
T2578 M2578={0,0,(void*)0,0};
T1654 M1654={0,(void*)0};
T1671 M1671={(void*)0,0,(void*)0,(void*)0};
T2241 M2241={2241,(void*)0,(void*)0,0};
T2245 M2245={2245,0,(void*)0,(void*)0,0,(void*)0,(void*)0,0};
T2243 M2243={2243,0,(void*)0,(void*)0,0};
T2103 M2103={(void*)0,0,0,(void*)0,(void*)0,{(void*)0,(void*)0}};
T2237 M2237={2237,(void*)0,{(void*)0,(void*)0},0,(void*)0};
T1894 M1894={0};
T1976 M1976={1976,(void*)0,{0},0};
T2579 M2579={2579,0,0,0,(void*)0,0};
T1876 M1876={(void*)0,(void*)0,0,0,(void*)0,0};
T2240 M2240={0};
T2580 M2580={0,0,(void*)0,0};
T1988 M1988={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,'\0',0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2323 M2323={(void*)0,0,0};
T2122 M2122={2122,(void*)0};
T2154 M2154={2154,(void*)0};
T2155 M2155={2155,(void*)0};
T2156 M2156={2156,(void*)0};
T2157 M2157={2157,(void*)0};
T2169 M2169={2169};
T2170 M2170={2170};
T2171 M2171={2171,(void*)0,(void*)0};
T2173 M2173={2173,(void*)0};
T2174 M2174={2174,(void*)0};
T2178 M2178={2178,0,(void*)0,(void*)0,(void*)0};
T2179 M2179={2179,(void*)0,(void*)0,(void*)0,(void*)0};
T2180 M2180={2180,(void*)0,(void*)0,(void*)0,(void*)0};
T2181 M2181={2181,(void*)0,(void*)0,(void*)0};
T2182 M2182={2182,0};
T2183 M2183={2183,0};
T2184 M2184={2184};
T2186 M2186={2186};
T2185 M2185={2185};
T2187 M2187={2187};
T2188 M2188={2188,0};
T2189 M2189={2189,(void*)0,(void*)0,0};
T2581 M2581={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2582 M2582={0,0,(void*)0,0};
T1924 M1924={1924,(void*)0,(void*)0,(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1645 M1645={0,(void*)0,0,(void*)0,(void*)0,{0}};
T1647 M1647={1647,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T2583 M2583={(void*)0,0,0,0,(void*)0,0};
T2584 M2584={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2585 M2585={0,0,(void*)0,0};
T1830 M1830={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1639 M1639={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T2090 M2090={(void*)0,{0,{0}},0,0,(void*)0,0,0};
T2587 M2587={0,0,0,(void*)0,0};
T1884 M1884={0,(void*)0,0,(void*)0};
T1658 M1658=(void*)0;
T1656 M1656={(void*)0,(void*)0,(void*)0,0,0};
T1664 M1664=(void*)0;
T1673 M1673=(void*)0;
T1672 M1672={0};
T1675 M1675=(void*)0;
T1641 M1641={(void*)0,{0},{0},0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1993 M1993={1993,(void*)0,0,(void*)0};
T2589 M2589={0,0,0,(void*)0,0};
T2590 M2590={(void*)0,0,0,0,(void*)0,0};
T1668 M1668={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0};
T1980 M1980={1980,(void*)0,0,(void*)0};
T2593 M2593={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2121 M2121=0;
T2594 M2594={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2595 M2595={(void*)0,0,0,0,(void*)0,0};
T2596 M2596={0};
T2261 M2261={2261,0};
T2262 M2262={2262,(void*)0,(void*)0,(void*)0,0};
T2263 M2263={2263,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1860 M1860={1860,(void*)0,(void*)0,(void*)0,(void*)0};
T1883 M1883={(void*)0,(void*)0,(void*)0};
T2600 M2600={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2088 M2088={(void*)0,(void*)0};
T2601 M2601={0,0,(void*)0,0};
T2602 M2602={(void*)0,0,0,0,(void*)0,0};
T2603 M2603={0,0,(void*)0,0};
T1849 M1849={1849,(void*)0,(void*)0,0,0,0,0,0,0,0,(void*)0};
T2254 M2254={2254,(void*)0};
T2604 M2604={0,0,0,0,(void*)0,0};
T2253 M2253={0,(void*)0,(void*)0};
T2605 M2605={0,0,(void*)0,0};
T2337 M2337={2337,(void*)0};
T2339 M2339={2339,0,(void*)0,(void*)0};
T2338 M2338={2338,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2609 M2609={0,0,(void*)0,0};
T2610 M2610={(void*)0};
T1609 M1609={0,(void*)0,{(void*)0,0}};
T2611 M2611={(void*)0,(void*)0,(void*)0};
T2617 M2617={(void*)0,(void*)0,(void*)0};
T2618 M2618={(void*)0,0,0,0,(void*)0,0};
T2619 M2619={0,0,(void*)0,0};
T1834 M1834={(void*)0,{0},0};
T1630 M1630=0;
T2623 M2623={0,0,(void*)0,0};
T1655 M1655={(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,(void*)0,{(void*)0,0,0},0,0,0,(void*)0,(void*)0,'\0',(void*)0,0,0};
T2626 M2626={0,0,(void*)0,0};
T2316 M2316={2316,(void*)0,(void*)0,(void*)0,(void*)0,{(void*)0,(void*)0},0,(void*)0};
T2354 M2354={2354,(void*)0,(void*)0,(void*)0,{(void*)0,(void*)0},0,(void*)0};
T2628 M2628={(void*)0,0,0,0,(void*)0,0};
T2630 M2630={(void*)0,0,0,0,(void*)0,0};
T2632 M2632={(void*)0,0,0,0,(void*)0,0};
T2634 M2634={(void*)0,0,0,0,(void*)0,0};
T2318 M2318={(void*)0,(void*)0};
T2027 M2027={0,{0}};
T2637 M2637={0,0,(void*)0,0};
T2003 M2003={0,{0},(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1985 M1985={(void*)0,(void*)0};
T1936 M1936={1936,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,{0}};
T1978 M1978={0,(void*)0,{0}};
T1979 M1979={0,(void*)0,(void*)0};
T2041 M2041={2041,0,(void*)0,(void*)0,0,(void*)0,0,(void*)0};
T2050 M2050={2050,{0},0,(void*)0};
T2052 M2052={2052,(void*)0,(void*)0,(void*)0,(void*)0,{0},0,(void*)0};
T1910 M1910={1910,(void*)0,(void*)0};
T1669 M1669={0,0};
T2053 M2053={2053,0,(void*)0,(void*)0,(void*)0,{0},0,(void*)0};
T1999 M1999={1999,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T1964 M1964={1964,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T2016 M2016={2016,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T1937 M1937={1937,(void*)0,0,(void*)0};
T1991 M1991={1991,(void*)0,0,(void*)0};
T1963 M1963={1963,0,(void*)0,(void*)0,0,(void*)0};
T1989 M1989={1989,0,(void*)0,(void*)0,0,(void*)0};
T1959 M1959={1959,(void*)0,(void*)0,(void*)0,0,(void*)0};
T1992 M1992={1992,(void*)0,0,(void*)0};
T1990 M1990={1990,0,(void*)0,(void*)0,0,(void*)0};
T1996 M1996={1996,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T1994 M1994={1994,(void*)0,(void*)0,0,(void*)0};
T1997 M1997={1997,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T2000 M2000={2000,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T1826 M1826={0,0,(void*)0,(void*)0};
T2022 M2022={2022,(void*)0};
T2024 M2024={2024,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2025 M2025={2025,(void*)0,(void*)0,(void*)0};
T2026 M2026={2026,0,(void*)0,0,(void*)0,(void*)0,(void*)0,0,0,0,(void*)0};
T1977 M1977={(void*)0,(void*)0,{0},(void*)0,(void*)0};
T2638 M2638={0,0,(void*)0,0};
T1833 M1833={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0};
T2033 M2033={(void*)0,(void*)0};
T2639 M2639={0,0,(void*)0,0};
T2074 M2074={2074,(void*)0,{0}};
T2043 M2043={2043,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1957 M1957={1957,(void*)0,(void*)0,(void*)0};
T2029 M2029={2029,(void*)0,0,(void*)0,{0}};
T1927 M1927={1927,(void*)0,(void*)0,0,0,{0}};
T2030 M2030={2030,(void*)0,(void*)0,(void*)0,{0}};
T2031 M2031={2031,{0},(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,{0}};
T1895 M1895={(void*)0,(void*)0};
T1904 M1904={1904,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1907 M1907={1907,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1909 M1909={1909,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1898 M1898={1898,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1902 M1902={1902,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1903 M1903={1903,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T2045 M2045={2045,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2046 M2046={2046,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2047 M2047={2047,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2035 M2035={2035,(void*)0,(void*)0,{0}};
T1941 M1941={1941,{0}};
T2010 M2010={2010,{0}};
T2017 M2017={2017,(void*)0,'\0',{0}};
T2036 M2036={2036,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T2071 M2071={2071,(void*)0,(void*)0,{0}};
T2072 M2072={2072,0,(void*)0,(void*)0,(void*)0,{0}};
T2640 M2640={0,0,(void*)0,0};
T2641 M2641={2641,0,0,0,(void*)0,0};
T2007 M2007={2007,0,(void*)0,(void*)0,(void*)0,{0}};
T2008 M2008={2008,(void*)0};
T2642 M2642={2642,0,0,0,(void*)0,0};
T1947 M1947={1947,(void*)0};
T2643 M2643={0,0,0,(void*)0,0};
T2219 M2219={2219,(void*)0,(void*)0,0,0};
T2644 M2644={0,0,(void*)0,0};
T1974 M1974={1974,(void*)0,(void*)0,(void*)0,(void*)0};
T1944 M1944={1944,0,0,0,(void*)0,(void*)0,(void*)0,{0}};
T2645 M2645={2645,0,0,0,(void*)0,0};
T1948 M1948={1948,(void*)0,(void*)0};
T2002 M2002={(void*)0,(void*)0};
T2073 M2073={2073,(void*)0,0};
T2646 M2646={0,0,(void*)0,0};
T2032 M2032={2032,(void*)0,(void*)0,{0},0};
T1968 M1968={1968,(void*)0,(void*)0,{0},0};
T1954 M1954={1954,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T2647 M2647={0,0,(void*)0,0};
T1913 M1913={1913,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T1925 M1925={1925,(void*)0,{0}};
T1918 M1918={1918,(void*)0,(void*)0,(void*)0,(void*)0,{0},(void*)0,(void*)0,{0},0};
T2034 M2034={2034,(void*)0,(void*)0,(void*)0,(void*)0,{0},(void*)0,(void*)0,{0},0};
T1982 M1982={1982,(void*)0,(void*)0,{0},0};
T2020 M2020={2020,(void*)0,(void*)0,(void*)0,(void*)0};
T2021 M2021={2021,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T1920 M1920={1920,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T1960 M1960={1960,0,(void*)0,(void*)0,(void*)0,{0},0};
T2018 M2018={2018,(void*)0,{0},(void*)0,0,0};
T2049 M2049={2049,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T2039 M2039={2039,(void*)0,{0}};
T1923 M1923={1923,(void*)0,(void*)0,0};
T1950 M1950={1950,0,(void*)0,(void*)0,0};
T2019 M2019={2019,(void*)0,(void*)0,0};
T2013 M2013={2013,{0},0};
T1951 M1951={1951,(void*)0,0};
T2213 M2213={2213,0,(void*)0,(void*)0,{0},0};
T2038 M2038={2038,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T2011 M2011={2011,(void*)0,(void*)0};
T1952 M1952={1952,{0}};
T2048 M2048={2048,(void*)0,{0},(void*)0};
T2070 M2070={2070,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2069 M2069={2069,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2065 M2065={2065,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2066 M2066={2066,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2067 M2067={2067,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2068 M2068={2068,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2064 M2064={2064,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1930 M1930={1930,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1953 M1953={1953,(void*)0,(void*)0,{0},0};
T2060 M2060={2060,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2061 M2061={2061,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2062 M2062={2062,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2063 M2063={2063,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1958 M1958={1958,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2059 M2059={2059,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2056 M2056={2056,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2057 M2057={2057,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2058 M2058={2058,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2055 M2055={2055,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2012 M2012={2012,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2054 M2054={2054,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2040 M2040={(void*)0,(void*)0};
T1836 M1836={(void*)0,(void*)0,{0}};
T2015 M2015={(void*)0,(void*)0,(void*)0,{0}};
T2014 M2014={(void*)0,(void*)0};
T2648 M2648={0,0,0,(void*)0,0};
T1975 M1975={(void*)0,(void*)0,(void*)0,{0}};
T1987 M1987={(void*)0,(void*)0,(void*)0,(void*)0};
T2317 M2317={(void*)0,(void*)0,(void*)0};
T2009 M2009={{0},(void*)0};
T1914 M1914={1914,(void*)0,(void*)0,0,{0}};
T1966 M1966={1966,(void*)0,(void*)0,(void*)0,(void*)0};
T1949 M1949={1949,(void*)0,(void*)0,(void*)0,0,{0}};
T2649 M2649={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T2650 M2650={0,0,(void*)0,0};
T2652 M2652={(void*)0,(void*)0,(void*)0};
T2655 M2655={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2656 M2656={0,0,0,(void*)0,0};
T2658 M2658={0,0,(void*)0,0};
T2236 M2236={2236,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1981 M1981={1981,(void*)0,(void*)0,{0},0};
T2659 M2659={0,0,(void*)0,0};
T2664 M2664={0,0,(void*)0,0};
T2665 M2665={(void*)0,0,0,0,(void*)0,0};
T2004 M2004={(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2666 M2666={(void*)0,0,0,0,(void*)0,0};
T1986 M1986={(void*)0};
T2001 M2001={(void*)0};
T2667 M2667={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1984 M1984={(void*)0};
T2668 M2668={(void*)0,(void*)0,(void*)0};
T2671 M2671={(void*)0,(void*)0,(void*)0};
T2675 M2675={(void*)0,0,0,0,(void*)0,0};
T2678 M2678={0,0,(void*)0,0};
T2679 M2679={(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,0,0};
T2682 M2682={(void*)0,0,0,0,(void*)0,0};
T2683 M2683={0,0,(void*)0,0};
T2684 M2684={0,0,(void*)0,0};
T2685 M2685={0,0,(void*)0,0};
T2686 M2686={0,0,(void*)0,0};
T2687 M2687={0,0,(void*)0,0};
T2688 M2688={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2079 M2079={(void*)0,0,(void*)0};
T2690 M2690={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T2694 M2694={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2695 M2695={(void*)0,0,0,0,(void*)0,0};
T2696 M2696={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2697 M2697={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T2698 M2698={0,0,(void*)0,0};
T2083 M2083={2083,(void*)0,(void*)0,(void*)0};
T2699 M2699={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2700 M2700={0,0,(void*)0,0};
T2115 M2115={(void*)0,(void*)0};
T2702 M2702={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T2703 M2703={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2704 M2704={0,0,(void*)0,0};
T1956 M1956={1956,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2707 M2707={(void*)0,(void*)0,(void*)0};
T2709 M2709={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2710 M2710={0,0,(void*)0,0};
T2191 M2191={0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T2711 M2711={(void*)0,0,0,0,(void*)0,0};
T2712 M2712={0,0,0,0,(void*)0,0};
T2713 M2713={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T1891 M1891={0,(void*)0,(void*)0};
T2714 M2714={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2719 M2719={(void*)0,0,0,0,(void*)0,0};
T2720 M2720={0,0,0,(void*)0,0};
T2721 M2721={0,0,0,(void*)0,0};
T2722 M2722={0,0,(void*)0,0};
T2724 M2724={(void*)0,(void*)0,(void*)0};
T2727 M2727={(void*)0,(void*)0,0};
T2730 M2730={(void*)0,(void*)0};
T2734 M2734={(void*)0,0,0,0,(void*)0,0};
T2373 M2373={2373,(void*)0,(void*)0,(void*)0};
T2374 M2374=(void*)0;
T2375 M2375={2375,(void*)0,(void*)0,(void*)0};
T2376 M2376={2376};
T2378 M2378={2378,(void*)0,(void*)0,(void*)0};
T2379 M2379={2379};
T2380 M2380={2380};
T2381 M2381={2381,0};
T2735 M2735={0,0,(void*)0,0};
T2736 M2736={0,0,(void*)0,0};
T2117 M2117={(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2738 M2738={(void*)0,(void*)0,(void*)0};
T2740 M2740={(void*)0,0,(void*)0,(void*)0,0,(void*)0,0,0};
T2744 M2744={(void*)0,0,(void*)0};
T2747 M2747={0,0,(void*)0,0};
T2750 M2750={0,0,0,0,(void*)0,0};
T2751 M2751={(void*)0,0,0,0,(void*)0,0};
T2753 M2753={0,0,(void*)0,0};
T1867 M1867={(void*)0,0};
T2280 M2280=0;
T2757 M2757={0,0,0,0,(void*)0,0};
T2760 M2760={(void*)0,(void*)0,0,0,0,(void*)0,0};
T2761 M2761={2761,(void*)0,(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2078 M2078={0,0,0,(void*)0,0};
T2763 M2763={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2341 M2341={2341,(void*)0};
T2765 M2765={0,0,(void*)0,0};
T2766 M2766={(void*)0,0,0,0,(void*)0,0};
T2768 M2768={(void*)0,(void*)0,(void*)0};
T2771 M2771={(void*)0,(void*)0,(void*)0};
T2774 M2774={(void*)0,(void*)0};
T2777 M2777={(void*)0,(void*)0,0};
T2779 M2779={(void*)0,0,0,0,(void*)0,0};
T2260 M2260={0};
T2234 M2234={2234,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2231 M2231={2231,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2118 M2118={2118,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2235 M2235={2235,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2228 M2228={2228,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2221 M2221={2221,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2224 M2224={2224,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2226 M2226={2226,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2233 M2233={2233,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2227 M2227={2227,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2223 M2223={2223,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2225 M2225={2225,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2232 M2232={2232,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2781 M2781={0,0,0,(void*)0,0};
T2782 M2782={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2783 M2783={(void*)0,0,0,0,(void*)0,0};
T2247 M2247={(void*)0};
T2790 M2790={0,0,(void*)0,0};
T2794 M2794={0,0,(void*)0,0};
T2296 M2296={2296,(void*)0,(void*)0,(void*)0,(void*)0};
T2796 M2796={0,0,(void*)0,0};
T1935 M1935={1935,(void*)0,(void*)0};
T2206 M2206={2206,(void*)0};
T2208 M2208={2208,(void*)0,(void*)0,(void*)0};
T2797 M2797={0,0,(void*)0,0};
T2798 M2798={0,0,(void*)0,0};
T2209 M2209={2209,0,(void*)0,0,(void*)0,{0}};
T2799 M2799={0,0,(void*)0,0};
T2800 M2800={0,0,(void*)0,0};
T2801 M2801={(void*)0,0,0,0,(void*)0,0};
T2805 M2805={(void*)0,(void*)0};
T2809 M2809={(void*)0,(void*)0,(void*)0};
T2816 M2816={(void*)0,(void*)0,0};
T2819 M2819={(void*)0,(void*)0,(void*)0};
T2821 M2821={0,0,(void*)0,0};
T2822 M2822={0,0,(void*)0,0};
T2824 M2824={(void*)0,(void*)0,(void*)0};
T2826 M2826={0,0,0,(void*)0,0};
T2828 M2828={(void*)0,(void*)0,0};
T2833 M2833={(void*)0,(void*)0,(void*)0,(void*)0};
T2835 M2835={(void*)0,0,0,0,(void*)0,0};
T2839 M2839={(void*)0,(void*)0,(void*)0};
T2845 M2845={(void*)0,(void*)0,(void*)0};
T2850 M2850={(void*)0,(void*)0};
T2853 M2853={(void*)0,(void*)0,(void*)0};
T2856 M2856={(void*)0,(void*)0};
T2859 M2859={(void*)0,(void*)0,(void*)0};
T2862 M2862={(void*)0,(void*)0};
T2865 M2865={(void*)0,(void*)0,(void*)0};
T2869 M2869={(void*)0,(void*)0};
T2871 M2871={(void*)0,(void*)0,(void*)0};
T1969 M1969={1969,(void*)0,0};
T2297 M2297={{0},(void*)0,(void*)0};
T2876 M2876={(void*)0,(void*)0,(void*)0};
T2881 M2881={(void*)0,(void*)0,(void*)0};
T2884 M2884={(void*)0,{0,(void*)0,(void*)0}};
T2887 M2887={(void*)0,{0,(void*)0,(void*)0},(void*)0};
T2890 M2890={(void*)0,(void*)0,(void*)0};
T2895 M2895={(void*)0,(void*)0,(void*)0};
T2897 M2897={0,0,(void*)0,0};
T1962 M1962={1962,(void*)0,(void*)0,0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1912 M1912={1912,0,{0},(void*)0,(void*)0};
T2900 M2900={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T2901 M2901={0,0,(void*)0,0};
T2902 M2902={0,(void*)0,(void*)0,(void*)0,0};
T2903 M2903={2903,0,0,(void*)0,0};
T2904 M2904={(void*)0,0,0,0,(void*)0,0};
T2909 M2909={(void*)0,(void*)0,(void*)0};
T2916 M2916={(void*)0,(void*)0,(void*)0};
T2917 M2917={2917,0,0,(void*)0};
T2334 M2334={2334,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0};
T2335 M2335={2335,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0};
T2336 M2336={2336,(void*)0,0,0,0};
T2331 M2331={2331,(void*)0,(void*)0};
T2332 M2332={2332,(void*)0,0,(void*)0};
T2333 M2333={2333};
T2921 M2921={(void*)0,(void*)0,(void*)0};
T2926 M2926={(void*)0,(void*)0,(void*)0};
T2929 M2929={(void*)0,(void*)0,(void*)0};
T2933 M2933={(void*)0,(void*)0,(void*)0};
T2936 M2936={(void*)0,(void*)0,(void*)0};
T2938 M2938={0,0,(void*)0,0};
T2944 M2944={(void*)0,0,0,0,(void*)0,0};
T2947 M2947={(void*)0,(void*)0,(void*)0};
T2953 M2953={(void*)0,(void*)0,(void*)0};
T2397 M2397={(void*)0,(void*)0,(void*)0,0,0,0,0};
T2957 M2957={(void*)0,(void*)0};
T2962 M2962={(void*)0,(void*)0,(void*)0};
T2965 M2965={(void*)0,0,0,0,(void*)0,0};
T2966 M2966={(void*)0,0,0,0,(void*)0,0};
T2969 M2969={(void*)0,(void*)0,(void*)0};
T1893 M1893={0};
T2971 M2971={0,0,(void*)0,0};
T2972 M2972={(void*)0,(void*)0,0,(void*)0,(void*)0,0,0};
T2973 M2973={0,'\0'};
T2974 M2974={0,(void*)0,0,(void*)0,0,0,(void*)0,0,0};
T2976 M2976={(void*)0,0,(void*)0};
T2979 M2979={(void*)0,0,(void*)0};
T2986 M2986={(void*)0,(void*)0};
T2987 M2987={(void*)0,0,0,0,(void*)0,0};
T2988 M2988={0,0,(void*)0,0};
T2989 M2989={0,0,0,(void*)0,(void*)0,0};
T2991 M2991={(void*)0,(void*)0,(void*)0};
T1611 M1611={0,(void*)0,(void*)0};
T2343 M2343={2343,0,(void*)0,'\0',(void*)0};
T2300 M2300={0,0,(void*)0};
T2217 M2217={2217,'\0',{0},0};
T2999 M2999={(void*)0,0,0,0,(void*)0,0};
T3000 M3000={(void*)0,(void*)0};
T3001 M3001={(void*)0,0,0,0,(void*)0,0};
T3002 M3002={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T3004 M3004={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T3007 M3007={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T2200 M2200={2200,(void*)0,(void*)0};
T2204 M2204={2204,(void*)0,(void*)0,(void*)0};
T2203 M2203={2203,(void*)0,(void*)0};
T2198 M2198={2198,(void*)0,(void*)0,{0}};
T2205 M2205={2205,(void*)0};
T2202 M2202={2202,(void*)0,0,(void*)0,{0},(void*)0};
T2216 M2216={2216,(void*)0,0};
T2197 M2197={2197,(void*)0,(void*)0,0,0,{0}};
T2199 M2199={2199,(void*)0,{0}};
T2218 M2218={2218,0,(void*)0,{0},0,0};
T1885 M1885=0;
T3008 M3008={0,0,(void*)0,0};
T3009 M3009={(void*)0,0,(void*)0,{0},0,(void*)0,0,0};
T2080 M2080={2080,(void*)0,(void*)0,(void*)0};
T3010 M3010={0,0,(void*)0,0};
T2210 M2210={2210,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2214 M2214={2214,(void*)0,(void*)0,{0},0};
T2220 M2220={2220,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T3011 M3011={(void*)0};
T3012 M3012={0,0,(void*)0,0};
T3013 M3013={0,0,(void*)0,0};
T1862 M1862=0;
T3014 M3014={(void*)0,0,0,0,(void*)0,0};
T3015 M3015={0,0,(void*)0,0};
T3021 M3021={0,0,(void*)0,0};
T2085 M2085={(void*)0};
T1676 M1676={1676,0,0};
T2298 M2298={2298,0,(void*)0,(void*)0};
T2303 M2303={2303,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1670 M1670={0};
T3023 M3023={0,0,0,(void*)0,0};
T1970 M1970={1970,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1967 M1967={1967,0,(void*)0,(void*)0,(void*)0,{0},0};
T1922 M1922={1922,'\0',(void*)0,{0}};
T2351 M2351={2351,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2194 M2194={2194,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2349 M2349={2349,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2304 M2304={2304,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2201 M2201={2201,{0},(void*)0,(void*)0,(void*)0};
T2089 M2089={2089,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2350 M2350={2350,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T2193 M2193={2193,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T3024 M3024={0,0,(void*)0,0};
T2399 M2399={2399,(void*)0,0,0,(void*)0};
T2401 M2401={2401,(void*)0,0,'\0','\0',0,0,0,0,(void*)0};
T2402 M2402={2402,(void*)0,(void*)0,0,(void*)0};
T2403 M2403={2403,(void*)0,(void*)0,'\0','\0',0,0,0,0,(void*)0};
T3025 M3025={3025,0,0,(void*)0,0};
T3027 M3027={(void*)0,(void*)0,(void*)0};
T3029 M3029={(void*)0,(void*)0,(void*)0};
T3033 M3033={(void*)0,(void*)0};
T3036 M3036={(void*)0,(void*)0,(void*)0};
T3039 M3039={(void*)0,(void*)0,(void*)0};
T3041 M3041={0,0,(void*)0,0};
T3042 M3042={0,{0},(void*)0,(void*)0,0};
T3043 M3043={3043,0,0,(void*)0,0};
T2207 M2207={2207,(void*)0,{0}};
T2270 M2270={2270,0};
T3048 M3048={(void*)0,(void*)0};
T2545 M2545={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0,0,{(void*)0,(void*)0},(void*)0,(void*)0,0};
T2190 M2190={0};
T2114 M2114={(void*)0,(void*)0,0,0};
T3066 M3066={0,0,(void*)0,0};
T3067 M3067={0,0,0,(void*)0,0};
T2108 M2108={2108,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2109 M2109={2109,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2110 M2110={2110,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2111 M2111={2111,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2112 M2112={2112,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T2113 M2113={2113,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T3075 M3075={3075,0,0,(void*)0};
T2356 M2356={2356,0,0};
T3077 M3077={0,0,0,(void*)0,0};
T3083 M3083={0,0,(void*)0,0};
T2372 M2372={2372,0};
T3085 M3085={(void*)0,0,0,0,(void*)0,0};
T3086 M3086={0,0,(void*)0,0};
T2275 M2275={0,0,0,0,(void*)0};
T3087 M3087={0,0,(void*)0,0};
T3091 M3091={(void*)0,(void*)0,(void*)0};
T2272 M2272={2272,(void*)0,0,0};
T3110 M3110={0,0,(void*)0,0};
T2348 M2348={2348,(void*)0};
T3111 M3111={(void*)0,0,0,0,(void*)0,0};
T2346 M2346={2346,0};
T3114 M3114={0,0,(void*)0,0};
T3116 M3116={(void*)0,0,(void*)0};
/*Aliased storage area or unicode storage.*/
char*s1901_1195446850A=". (See the next error report for details.)";
char*s1661_0A="";
char*s1665_1418906530A="void se_msi";
char*s1584_424424A="low_16";
char*s2179_25969530A=",a1ptr->_";
char*s1669_9A="\011""";
char*s1659_10A="\n";
char*s1584_424430A="low_32";
char*s1923_1114345928A="Void cannot be assigned to an expanded entity.";
char*s2191_1983193131A="To fix this ambiguous Precursor call you have to remove direct repeated inheritance. You may thus consider to add a new class which inherit ";
char*s1581_199827552A=": level is already set to ";
char*s1665_1564992795A="int se_general_trace_switch";
char*s2179_59375621A="Class NATIVE_ARRAY has been tampered with. Unknown function: ";
char*s1665_1772404517A="&local_profile,";
char*s1652_1078639380A="Expression expected after \'implies\'.";
char*s1975_772854717A="Feature `manifest_put\' must be a procedure.";
char*s1652_1138390195A="Prefix operator name expected.";
char*s1665_523400916A="Precomputed once function";
char*s2019_218994080A="Replacing assign to \173""";
char*s1665_12331A="NULL";
char*s2263_1880914324A="gc_agent*gcu=(gc_agent*)u;\nif (gcu->header.flag==FSOH_UNMARKED)\173""\ngcu->header.flag=FSOH_MARKED;\n";
char*s1652_34A="\"";
char*s2263_1607908341A="Adding SmartEiffel Garbage Collector.\n";
char*s1584_38A="&";
char*s1665_40A="(";
char*s1665_41A=")";
char*s2172_7233618A="INT8_MIN";
char*s1584_42A="*";
char*s1584_43A="+";
char*s1665_44A=",";
char*s1665_36951A="(T0*)";
char*s1584_45A="-";
char*s2006_46A=".";
char*s1584_47A="/";
char*s2170_48A="0";
char*s1580_1889925553A="compile_to_c";
char*s1674_1071750288A="SmallEiffel";
char*s1966_532898088A=" See also the next message for more information.";
char*s2157_1664036235A="set_dump_stack_top(caller);/*unlink*/\nreturn C;\n";
char*s2024_58A=":";
char*s2157_1023028228A=";\nu->afp=afp_";
char*s2180_59A=";";
char*s1584_60A="<";
char*s1584_61A="=";
char*s2179_2017590A="floor((";
char*s2375_1752899740A="GC_REGISTER_FINALIZER_NO_ORDER(R, bdw_finalizeT";
char*s1584_62A=">";
char*s1581_63A="\?";
char*s2338_1883030297A=" (discarded)\n";
char*s1584_64A="@";
char*s1655_1684808173A="Invalid empty file";
char*s2182_1216329562A="if (!strcmp(attr,\"";
char*s1652_67A="C";
char*s1652_1268871407A="Bad inline agent definition (\"do...end\" routine body expected).";
char*s2179_219498506A="Unknown \"$";
char*s1581_1202957293A=": missing file path name after -output_error_warning_on flag.\n";
char*s1585_212160365A="require_check";
char*s2174_80037A="else ";
char*s1584_12376A="REAL";
char*s1668_325166540A="Can\'t join these two concrete features. What\'s called a concrete feature here is a feature which is not deferred. You may consider to undefine one feature or to add a redefine.";
char*s1665_77A="M";
char*s1976_77A="\011"" ";
char*s2354_79A="\011""\"";
char*s1665_1206795525A="c_plus_plus";
char*s1665_441192857A="initialize_eiffel_runtime(argc,argv);\n";
char*s2157_82A="R";
char*s2376_306811962A=" object;union \173""void*flag;gc";
char*s2378_1665297219A=",\n(void(*)(mch*))gc_sweep";
char*s2090_251231528A="generating";
char*s1665_1645835456A=");\nimax=argc";
char*s2182_84A="T";
char*s1665_2189840A="se_ums(";
char*s1663_301485A="Cygwin";
char*s1665_392938270A="init_profile(agent_profile+";
char*s2157_585895143A="(se_dump_stack*caller,";
char*s2172_91A="[";
char*s1665_93A="]";
char*s1584_94A="^";
char*s1584_251231540A="generation";
char*s1652_916596A=" items.";
char*s2354_2008215484A=" (not in a loadpath)";
char*s1661_99A="c";
char*s2378_101A="e";
char*s1827_376816512A="external_header_path";
char*s1665_273430505A="return 0;\n";
char*s1581_104A="h";
char*s2174_105A="i";
char*s1661_109A="m";
char*s1988_178490A=" class";
char*s1584_112335826A="signal_number";
char*s1665_114A="r";
char*s1647_772983982A="Problem with undefine of \"";
char*s2114_1399364920A="/*auto-unlock tmp";
char*s1581_118A="v";
char*s2031_123A="\173""";
char*s1584_124A="\174""";
char*s1584_126A="\176""";
char*s1665_273430530A="return 1;\n";
char*s1665_391886489A="])(FILE*,void*)";
char*s2261_6284A="(((T";
char*s1919_1485085274A="..... unique buffer 1 .....";
char*s1950_1089483711A=" must not be expanded. (";
char*s2179_579867211A="(T6)(C==a1)";
char*s1652_629850238A="An expression has a result value. This is not an instruction.";
char*s1665_1629400044A="#define SE_BOOST 1\n";
char*s1584_80109A="fifth";
char*s2174_252339A="=NULL;";
char*s1668_612971904A="\n\nSecond \"insert\" path (from parent to child):\n   ";
char*s1988_202915491A="Same class name appears twice.";
char*s1948_446205995A="Same local name appears twice in this \"local\" variable list.";
char*s2174_6305A=")&&(";
char*s1652_280897875A=" for the left-hand side of an assignment.";
char*s1956_1324593410A="Overflow of infix \"*\" with INTEGER_32 operands. (";
char*s1585_1473988901A="c_linker_options";
char*s2117_168A="\011""\173""";
char*s1974_145102259A="(The type of this expression is actually ";
char*s1652_339436953A="Compiler limitation: separate classes are not supported. SCOOP attempt implementation currently abandoned (December 2006).";
char*s1661_539873441A="\" (default mode) selected.\n";
char*s1665_1853640928A="se_local_profile_t local_profile;\nstatic se_profile_t prof;\n";
char*s2006_1876110531A="Value out of INTEGER_32 range.";
char*s1652_470853074A="The base type is no longer used. Class PROCEDURE now has only one formal argument. Just remove this unused type mark.";
char*s2116_6330A="();\n";
char*s1661_180A="\"\n";
char*s1584_961210799A="allocated_bytes";
char*s1665_116813823A="default:\nerror0(\"Internal error in agent launcher (";
char*s1665_1368099455A="se_msi1();\n";
char*s1665_30942A=") */ ";
char*s1665_37095A="(T6)(";
char*s2375_61699A="NULL,";
char*s1585_436911A="rescue";
char*s2174_1341914655A="/*count*/=((";
char*s1653_1604340919A="Bad clients list.";
char*s1827_1341859296A="Keyword \"system\" expected. Invalid ACE file.";
char*s1652_194A=" \"";
char*s2191_42706587A="The type ";
char*s1659_195A="%\n";
char*s1665_475921520A="memcpy(sorted_agent_switch_profile, agent_switch_profile, ";
char*s2156_619030689A="fprintf(file,\"\\n\\t]\");\n";
char*s1837_200A=" (";
char*s2174_117385886A="/*[inspect";
char*s2263_786221024A="GC support: generating switch functions.\n";
char*s1665_6355A=" R;\n";
char*s2262_1409981632A=")REVEAL_POINTER(";
char*s1665_204A="\"\"";
char*s2172_205A="!(";
char*s2375_85966583A="(o);\nGC_enable();\n";
char*s1658_580488532A=" nodes and ";
char*s2378_212314278A="->first_object)));\n";
char*s1652_639285944A="Missing \')\' to end `c_inline_c\' call.";
char*s1968_1085830094A="ifthen (empty)";
char*s1659_215A=")\n";
char*s1936_905138318A="Invalid unicode string at index ";
char*s1827_216A="\".";
char*s1885_2070057757A="Loop_invariant";
char*s1584_217A="#*";
char*s2024_218A=" :";
char*s1584_218A="#+";
char*s2179_160146A="))))))";
char*s1665_993675817A="if(fd.assertion_flag)\173""\nfd.assertion_flag=0;\n";
char*s1584_220A="#-";
char*s1652_873294598A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous manifest STRING as target).";
char*s1584_54688766A="se_atexit";
char*s2179_4638080A="(T6)((!(";
char*s2172_226A="!=";
char*s1652_1922692108A="Replaced misspelled \"True\".";
char*s1665_227A=" C";
char*s1827_1302880443A="Error in the \"";
char*s1885_1306325004A="Void_call_target";
char*s1665_585944489A="Define C main function.\n";
char*s2171_230A="&(";
char*s2172_230A=",\n";
char*s2174_236A="\')";
char*s2155_237A=" M";
char*s1665_240A="((";
char*s1661_240A=".\n";
char*s2263_241A="()";
char*s1652_241A="\'.";
char*s2172_36137368A="INT64_MIN";
char*s2375_6395A=" R=(";
char*s2122_244A=" T";
char*s1665_245A=")(";
char*s2261_246A="))";
char*s2157_247A=" W";
char*s1584_1682815431A="manifest_make";
char*s1665_249A="),";
char*s1665_251A="*)";
char*s1647_251A=").";
char*s1837_252A=", ";
char*s2157_254A=",\"";
char*s2179_255A="+(";
char*s2123_255A=" _";
char*s1659_542094038A="Expanded Target Procedure Call";
char*s2153_257A=" a";
char*s1665_257A="*/";
char*s2171_258A=",&";
char*s2157_259A=" c";
char*s2174_259A=",\'";
char*s2261_6411A="(-1)";
char*s1659_262A=". ";
char*s1585_10703002A="no_check";
char*s1665_1312728230A="print_profile(profile_file, &runinit_profile);\n";
char*s2174_264A=");";
char*s2179_265A="-(";
char*s2172_184795A="(T0*)(";
char*s2157_436987A="resexp";
char*s1997_1428348580A="This type mark is not a TUPLE type mark.";
char*s1669_270A="--";
char*s1956_190952A=" with ";
char*s1974_271A=".)";
char*s1665_272A="&R";
char*s2179_6425A="))/(";
char*s2172_1097836905A="/*$*/(void*)&";
char*s2157_274A=" r";
char*s1653_116346440A="Unknown special character.";
char*s1665_1017947719A="manifest_initialize(";
char*s2102_276A="..";
char*s1665_277B=" u";
char*s1665_277C="*C";
char*s1665_277A="/*";
char*s2354_277A="./";
char*s1927_278A=".0";
char*s1659_1255776138A="Overflow while computing \"";
char*s1659_1131876546A="Starting collect";
char*s1665_282A="0*";
char*s1584_282A="//";
char*s1665_284B="0,";
char*s1665_284A="(T";
char*s2079_287A="->";
char*s2079_80251A="empty";
char*s2185_293A="10";
char*s2185_294A="11";
char*s2031_594795843A=", each bunch must have exactly ";
char*s2185_295A="12";
char*s2179_296A=")[";
char*s1584_296A="/=";
char*s1661_297A=".C";
char*s2174_244699380A="default:;\n";
char*s1661_298A="-I";
char*s1988_299A=".E";
char*s1837_300A=":\n";
char*s1661_301A="-L";
char*s2545_302A=".H";
char*s1665_6455A="));\n";
char*s2031_305A=";\n";
char*s1665_1754886761A="se_agent*);\n";
char*s1665_317A=",a";
char*s1584_406284A="fourth";
char*s1584_42134669A="Precursor";
char*s1975_325449730A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_put\').";
char*s1665_1238750212A="get_profiler_started(&master_profile);\n";
char*s1652_1088075316A="Cannot use a formal generic argument as a valid parent.";
char*s1833_90592250A="Cannot undefine ";
char*s1674_322A=": ";
char*s2263_35343969A="FSOC_SIZE";
char*s2334_324A="-c";
char*s2179_325A="._";
char*s1661_326A="-e";
char*s2157_327A="*u";
char*s2179_197159A=";\n*((T";
char*s1661_327A=".a";
char*s1910_327A="; ";
char*s1583_329A=".c";
char*s2123_1710309A="Tid id;";
char*s1583_331A=".e";
char*s1665_10739979A="mspalloc";
char*s2157_815493762A="\n/*agent launcher*/";
char*s1661_333A="-l";
char*s1661_334A="/c";
char*s1583_334A=".h";
char*s1668_107193812A="It is useless to mark as \"redefine\" this deferred feature.";
char*s1586_336A="-o";
char*s2117_142931125A=" has no creation list. You must use the default creation method (named `default_create\' in class ANY, or just omit the method name).";
char*s1661_340A="-s";
char*s1661_341A=".o";
char*s1665_881278717A="#ifdef SIGINT\n                                                       signal(SIGINT,se_signal_handler);\n#endif\n#ifdef SIGTERM\n                                                       signal(SIGTERM,se_signal_handler);\n#endif\n";
char*s2172_345A="=(";
char*s1584_1501191A="Current";
char*s2025_348A="::";
char*s1585_437070A="prefix";
char*s2298_351A=":=";
char*s1670_1568216255A="internal_exception_handler(Void_call_target)";
char*s1659_36611104A="You seem to have too classes named ";
char*s1584_1578334651A="open_arguments";
char*s2211_301503927A="Incompatible actual argument for agent call. Cannot pass `Void\' into formal argument of type ";
char*s2074_360A="<<";
char*s1927_360A="0x";
char*s1584_361A="<=";
char*s1961_1136256141A="Cannot use such a strange create expression for type ";
char*s2024_2140868216A="Value expected";
char*s2262_8033571A="]!=NULL)";
char*s2182_754574290A=";\nif (_r==NULL) \173""R=&_r; *id=0;\175"" else \173""\nswitch(_r->id) \173""\n";
char*s2174_366A="==";
char*s2156_775396A="(&((*o)";
char*s1653_1700247488A="Unexpected character in hexadecimal ascii code.";
char*s1584_371A=">=";
char*s2074_372A=">>";
char*s1950_376A="\?=";
char*s2378_377A="=H";
char*s1665_379A="C,";
char*s1584_548214405A="REAL_GENERAL";
char*s2017_898426A=".......";
char*s1661_1561265653A="No default configuration file for Liberty Eiffel was found.\nPlease just re-run the Liberty Eiffel installation program.\nOn Unix-like system, just \"cd\" to the Liberty Eiffel directory and\nthen, type \"make\".\nOn Windows-like system, re-run the \"install.exe\" of Liberty Eiffel.\nNote: if you prefer, you can still rely on the \"";
char*s1665_175857472A="manifest_make(";
char*s1665_382A="=M";
char*s2116_6534A="*((T";
char*s2156_197373672A="fprintf(file,\"";
char*s1661_62728285A="The configuration file seems invalid. Correct the above errors first.";
char*s2172_1639500234A="NULL/*_POINTER*/";
char*s1673_397A="BC";
char*s2263_6550A=") \173""\n";
char*s2006_1962655329A=" has an argument list";
char*s1663_402A="CC";
char*s2157_2054563574A="se_frame_descriptor fd=\173""\"create expression wrapper\",0,0,\"\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s1953_1442631340A=". (See explaination below.)";
char*s1585_9909665A="creation";
char*s1665_6559A="*/\nT";
char*s2378_1748680500A="=n->header.next;\n\175""\nelse if(";
char*s1652_1011636926A="Void cannot be used after unary \"-\" operator.";
char*s2179_1340573954A="memcpy(&R,C,sizeof(R))";
char*s2157_1484470448A="rc.top_of_ds=&ds;\n";
char*s2157_1212159A="==a2->c";
char*s1652_1733505988A="Unexpected \"reference\" keyword.";
char*s1665_1601653158A="se_local_profile_t local_profile, *parent_profile;\n";
char*s2179_419A="=r";
char*s1910_892535123A="Same argument name appears twice in this formal argument list.";
char*s1665_1957408550A="invariant of ";
char*s1665_781060556A="Internal stacks size used: ";
char*s1665_726728775A="=2;\175""\nelse\173""\n";
char*s1975_1604599495A="Feature `manifest_semicolon_check\' must be a constant (INTEGER or BOOLEAN).";
char*s1961_343527626A=" Actually, just replace this create expression with ";
char*s1653_74239A="]foo\"";
char*s2263_6580A="*);\n";
char*s1934_1808265259A="This is not an CHARACTER expression.";
char*s2153_86545A="open_";
char*s1988_205111678A="\" in cluster \"";
char*s1653_696478167A="Bad (empty\?) ascii code.";
char*s2006_1604408825A="Must not use such a non-static type mark for a constant-attribute definition.";
char*s1830_38905513A="This is not a constant feature.";
char*s2191_1447552176A=" the conforming parent(s) for ";
char*s1584_1603529235A="to_natural_8";
char*s2378_526175446A="*)(&(c->first_object)));\nif((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store";
char*s1584_80416A="first";
char*s1665_1793244543A="fclose(profile_file);\175""\n";
char*s2375_733445699A="void bdw_finalizeT";
char*s1584_878996813A="TYPED_INTERNALS";
char*s1659_408537579A=". The number of dots\ngives the number of \"when\" clauses:\n";
char*s1665_10666295A="\175""/*--*/\n";
char*s1665_339308075A="/*The generic se_agent0 definition:*/\nstruct _se_agent0\173""\nTid id;\nTid creation_mold_id;\nvoid(*afp)(";
char*s1956_1297676933A=" would give ";
char*s2378_6614A="((gc";
char*s1885_1489034545A="Routine_failure";
char*s2545_1935504882A="Strange dependency: location <";
char*s1665_471A="R=";
char*s2185_471A="T3";
char*s2211_1084920002A="Bad number of actual arguments for agent call. (The agent you are trying to call has ";
char*s2185_474A="T6";
char*s1976_1240817101A="Bad comment to end a class.";
char*s2185_476A="T8";
char*s1661_1192507148A="Unknown os \"";
char*s1584_1639475718A="UNICODE_STRING";
char*s2180_529853775A=");\n\175""\nelse\173""\n";
char*s2208_1937147216A="Cannot assign newly created ";
char*s1659_1459577427A="Void target Function Call";
char*s1988_397816412A="   include ";
char*s1661_1721407046A="Math=IEEE Parameters=Both Code=Far";
char*s2025_1577658176A="... unique local buffer ...";
char*s2157_283801480A="void*afp;\n";
char*s2191_1655357614A="Keyword \"require\" replaced with \"require else\" because there is an inherited require assertion.";
char*s2343_498A="X:";
char*s1585_2073386A="inspect";
char*s1652_2117894368A="Void is not a valid BOOLEAN expression (just after keyword \"until\" of a loop).";
char*s2116_6655A=")->_";
char*s1581_613587359A="Flag or argument \"";
char*s2172_506A="])";
char*s1665_215791A="(void)";
char*s2174_1181502A="==0 \174""\174"" ";
char*s2375_1544707291A="void*bdw_na_assignT";
char*s1652_1524784203A="Exponent part of a real value expected.";
char*s2545_1942892277A="Including header ";
char*s1665_365905049A="init_profile(&root_profile, \"<root>\");\n";
char*s2262_1970645590A="#define BDW_GC 1\n#define GC_I_HIDE_POINTERS 1\n#include <gc/gc.h>\n#define malloc(s) GC_MALLOC(s)\n#define calloc(n,s) GC_MALLOC_IGNORE_OFF_PAGE((s)*(n))\n#define realloc(p,s) GC_REALLOC((p),(s))\n#define free(p) p=NULL\n";
char*s2020_334725631A="Error in variant part of loop definition.";
char*s2338_1000694404A="].\nOriginal definition ";
char*s1892_25373399A="Incompatible signatures. (One has a result type and not the other.)";
char*s1665_526A="]=";
char*s2262_1477636806A="#ifndef GC_DEBUG\n#define GC_DEBUG \"";
char*s2174_1084495643A="\175""\175""/*manifest INSPECT]*/\n";
char*s1956_889865702A=" which is out of INTEGER_8 range.)";
char*s1584_534A="a1";
char*s2179_535A="a2";
char*s1661_6687A=" To ";
char*s2046_2057854492A=" is 9223372036854775808 which is out of INTEGER_64 range.";
char*s1665_932172292A="]=root_profile;\n";
char*s1652_955638361A="Bad use of predefined type ARRAY.";
char*s1652_9897510A="built_in";
char*s1585_10315778A="indexing";
char*s1584_552A="\\\\";
char*s2024_1490203324A="Unexpected keys found\n";
char*s1665_1906398440A="#ifdef SIGQUIT\n                                                    signal(SIGQUIT,se_signal_handler);\n#endif\n#ifdef SIGILL\n                                                    signal(SIGILL,se_signal_handler);\n#endif\n#ifdef SIGABRT\n                                                    signal(SIGABRT,se_signal_handler);\n#endif\n#ifdef SIGFPE\n                                                    signal(SIGFPE,se_signal_handler);\n#endif\n#ifdef SIGSEGV\n                                                    signal(SIGSEGV,se_signal_handler);\n#endif\n#ifdef SIGBUS\n                                                    signal(SIGBUS,se_signal_handler);\n#endif\n#ifdef SIGSYS\n                                                    signal(SIGSYS,se_signal_handler);\n#endif\n#ifdef SIGTRAP\n                                                    signal(SIGTRAP,se_signal_handler);\n#endif\n#ifdef SIGXCPU\n                                                    signal(SIGXCPU,se_signal_handler);\n#endif\n#ifdef SIGXFSZ\n                                     "
"               signal(SIGXFSZ,se_signal_handler);\n#endif\n";
char*s1665_1901889757A="/*\nANSI C code generated by ";
char*s1672_557A="_R";
char*s2378_25822456A=";\ngc_free";
char*s2245_559A="_T";
char*s1652_1471861047A="Syntax error inside \"local\" variable list definition. Encountered keyword \"";
char*s2174_550508910A="assertion_depth=1;\nfree_exception_frames();\n";
char*s1585_1532343833A="cpp_compiler_path";
char*s2338_68224A="The \'";
char*s1923_1744510279A=" Cannot assign ";
char*s1837_22396357A=" columns ";
char*s2172_570A="\\n";
char*s1675_570A="__";
char*s2174_1832703325A="/*UNUSED_EXPRESSION:*/(void)(";
char*s1585_54418471A="reference";
char*s1652_1228072329A="Such a constant cannot be used in \"when\" part of an inspect statement.";
char*s1665_1988895671A="start_profile(parent_profile, &local_profile);\n";
char*s2123_166654A="* o1,T";
char*s1827_1476966395A="More than one class in the system is named ";
char*s1665_1290234339A="int se_argc";
char*s1652_1961160815A="The \"separate\" keyword is still a reserved keyword in case of a new implementation attempt...";
char*s1953_1037594318A=" (Error occurs while checking the code in ";
char*s1652_751585121A="Error while reading hexadecimal number.";
char*s1585_2233396A="runtime";
char*s2261_273418685A="se_calloc(";
char*s1581_1724187394A=": missing output name after -o flag.\n";
char*s1585_48390502A="all_check";
char*s1656_589A="bc";
char*s2185_591A="_t";
char*s1661_2077353217A="\" (alternate mode) selected.\n";
char*s1827_2132072515A="\" ACE file.\n";
char*s1586_594A="cc";
char*s1584_9713026A="as_32_ne";
char*s1584_36193081A="INTEGER_8";
char*s2066_2080244194A="Division by zero.";
char*s1585_600A="as";
char*s1653_1317175740A="Too long hexadecimal sequence for a single unicode value.";
char*s1659_1463938603A="Polymorphic Proceduire Call";
char*s1663_603A="cl";
char*s2378_6755A="++;\n";
char*s2378_604A="o1";
char*s1652_1207921682A="Manifest real value not compatible with this type.";
char*s1659_801894175A="Unknown prefix operator \"";
char*s1979_1773450779A="A formal generic argument must not use the name of some existing class.";
char*s1652_437331A="result";
char*s1961_1260488135A=" and you are done.";
char*s1652_611A="do";
char*s1584_548331507A="NATIVE_ARRAY_INTERNALS";
char*s1661_614A="gc";
char*s2263_185146A="(T0*o)";
char*s1665_1419097826A="),c,(int16_t*)s,sc,lsv,lsi);return (T0*)";
char*s1659_427937988A="Total Number of Merged \"when\" clauses (cumulated): ";
char*s1661_179868158A="Unknown system name in file\n\"";
char*s2179_475042348A="internal_exception_number";
char*s1988_620A="es";
char*s2157_68284A="a1->c";
char*s2174_6775A="))\173""\n";
char*s1665_625A="\173""\n";
char*s1665_5395053A="(void*)0";
char*s1585_627A="if";
char*s2174_693716559A="error1(\"Invalid ::= assignment (inserted type).\",";
char*s1674_354654986A="Environment variable $\173""";
char*s1584_51915068A="is_normal";
char*s1668_1661847054A="\" come from the same original feature via multiple \"inherit\" paths.\nBelow, you get the feature evolution step by step. Note that in the end (type ";
char*s1653_85511833A="Right hand side expression of ::= assignment expected here.";
char*s2172_1367878466A="se_manifest";
char*s1665_635A="\175""\n";
char*s1584_636A="io";
char*s1649_1861287086A="not_computed";
char*s2026_449661A="struct";
char*s1585_640A="is";
char*s2174_2251910A="switch(";
char*s2169_5395074A="(void)0;";
char*s1659_1174466439A="during inlining of dynamic dispatch";
char*s1665_651A="p[";
char*s1585_1690381566A="invariant_check";
char*s2262_12955A="]);\n";
char*s1584_1744399653A="type_attribute_generating_type";
char*s2179_6810A="))\174""(";
char*s1656_660A="ms";
char*s1827_661A="no";
char*s1658_97543221A="Recompute RUN_TIME_SETs..";
char*s2169_4570857A="/*:RF1*/";
char*s2174_1175100011A=" /* has_empty */ if (";
char*s1584_669A="or";
char*s2179_670A="\176""(";
char*s1585_670A="os";
char*s2117_671A="\175"".";
char*s1581_525197655A="\" specified for the -is_output_error_warning_on flag.\n";
char*s2157_43730A="*se_i";
char*s1955_925886099A=" (this is not BOOLEAN).";
char*s2179_351281A="a1ptr=";
char*s1663_674A="sc";
char*s1652_1135641353A=" is not writable.";
char*s2378_6830A=" e;\n";
char*s2191_378711602A="Keyword \"ensure then\" replaced with \"ensure\" (There is no inherited ensure assertion here).";
char*s1661_1087245292A="#: config file corrupted!";
char*s1641_685A="ti";
char*s1661_686A="rt";
char*s1661_689A="vc";
char*s1665_1713607783A="if (expression != NULL) error2(expression,/*unknown-position*/0);\n";
char*s2263_1824264277A="void once_function_mark(void)";
char*s2116_905827712A="manifest_string_mark";
char*s2376_699A="\173""T";
char*s2154_619166512A=";\n#define M";
char*s2157_228498053A="se_dump_stack ds=\173""NULL,NULL,0,NULL,NULL,NULL\175"";\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s1833_875060418A="You cannot inherit \"";
char*s2179_1375807179A="Unknown WEAK_REFERENCE built-in: ";
char*s2262_564564093A=",(void*)0,0";
char*s1584_1115958189A="open_argument_indices";
char*s1584_1206543966A="object_attribute";
char*s2169_4570907A="/*:RF3*/";
char*s1580_1325879523A=": missing loadpath file path after -loadpath flag.\n";
char*s1652_316863332A="No parent after \"inherit\" keyword (an empty list is not allowed here).";
char*s2191_1197649626A="Precursor call is allowed only when the enclosing routine is redefined.";
char*s2090_1899804731A="adapting features";
char*s2157_10937200A="return (";
char*s1665_6877A=");/*";
char*s1663_13028A="UNIX";
char*s1584_80694A="floor";
char*s2123_1290234494A="int se_cmpT";
char*s2038_1767084619A="Please consider writing an explicit open argument list for your agent creation.";
char*s1655_1385667261A=".\nIts retained value will be the last read.\n";
char*s1584_849712179A="print_run_time_stack";
char*s2169_4570932A="/*:RF4*/";
char*s1836_740A="\173""\175""";
char*s2174_744A="\174""\174""";
char*s2375_854811368A="o->bdw_generation=g;\175""\n";
char*s1663_1772235A="Windows";
char*s2157_750A="\175""\175""";
char*s2174_1261705A="=NULL;\n";
char*s2240_1601130656A="Duplicate directory";
char*s1659_1460051321A="Unsafe covariant redefinition of argument number ";
char*s1827_527202963A="The \"debug\" assertion level is deprecated. Please use \"all\" and debug statements.";
char*s1665_1195084695A="ds.fd=&root;\nds.current=((void*)(&";
char*s1956_613384625A="Overflow of infix \"+\" with INTEGER_32 operands. (Adding ";
char*s2114_2007779419A="/*reusing tmp";
char*s1661_643573734A="If Liberty Eiffel is correctly installed, you should find\nmore information in the file \"";
char*s2031_589832448A="Must not use the \";\" (semicolon) separator for manifest ";
char*s2263_40031469A="RSOC_SIZE";
char*s2169_4570957A="/*:RF5*/";
char*s2180_68406039A="\n#if BYTE_ORDER == BIG_ENDIAN\n";
char*s2090_1280946519A="collecting features";
char*s2378_5161461A="(fsoc*c)";
char*s2174_644847010A=";\nbreak;\n\175""\n";
char*s1584_567319806A="to_integer_16";
char*s2174_1124563501A="))\173""switch(((T0*)";
char*s1666_6926A=",...";
char*s1663_51699930A="lcc-win32";
char*s1950_7867907A="Invalid ";
char*s1584_1597390874A="Character_bits";
char*s1584_567319812A="to_integer_32";
char*s1665_7720290A="Function";
char*s2169_4570982A="/*:RF6*/";
char*s1670_899910547A="se_print_run_time_stack(),exit(1)";
char*s2378_2092663259A="goto begin;\n";
char*s2179_6946A=",0))";
char*s1665_1994813154A="];\nse_profile_t sorted_all_profile[";
char*s1584_567319829A="to_integer_64";
char*s1975_282823780A="Invalid creation procedure. A \"once\" procedure is not allowed as a creation procedure.";
char*s2179_1824713404A="deep_memcmp(";
char*s1584_9676326A="capacity";
char*s2156_926003101A="if(*o==NULL)\173""\n   fprintf(file, \"void\");\n   return;\175""\n";
char*s2157_80771A="u->R=";
char*s1827_1091711046A="\" (and there may be more). Search started from ";
char*s2179_6965A=")<<(";
char*s2169_4571007A="/*:RF7*/";
char*s2122_1710532409A="/*BUG:NA@runtime!*/";
char*s1584_1671553525A="WEAK_REFERENCE";
char*s1665_1981256377A="Assignment test (\"\?:=\") function";
char*s1661_10937305A="return;\n";
char*s2157_173055A="*)u2;\n";
char*s2026_55156846A="signature";
char*s2090_958892525A="Total time spent ";
char*s1652_52979396A="loop body";
char*s2053_1083118122A="Type mark \"like <argument>\" must not reference another \"like <argument>\" type mark. (One level of indirection is always possible and always better ;-)";
char*s2174_400650A="else\173""\n";
char*s2174_86950A="rawci";
char*s1585_400652A="elseif";
char*s2179_427390771A=")==FP_SUBNORMAL";
char*s1827_1707020207A="The \"use\" clause is not yet implemented.";
char*s2169_4571032A="/*:RF8*/";
char*s2157_345908476A="ds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\nset_dump_stack_top(&ds);/*link*/\n";
char*s2179_6995A=")==(";
char*s1647_142319A="\" in \"";
char*s1585_11251026A="undefine";
char*s1975_170383550A="Manifest generic creation not yet implemented for expanded types (";
char*s2182_7006A=" _r=";
char*s1661_373286592A="\".\nCurrently handled system names:\n";
char*s1652_1275558331A="A routine must be ended with \"end\".";
char*s2169_4571057A="/*:RF9*/";
char*s1652_888875725A="Missing \";\" added.";
char*s2378_1648235130A="->header.state_type=FSO_USED_CHUNK;\nn=";
char*s1584_1498845794A="NATIVE_ARRAY[CHARACTER]";
char*s2024_1331532446A="module_name";
char*s1953_1769582063A=" Expression ";
char*s2179_7025A=")>>(";
char*s2375_719514099A="bdw_na_assignT";
char*s2378_1288623074A=")(r+1));\n\175""\nreturn((T";
char*s2041_672729595A="Invalid generic constraint cycle.";
char*s2380_730579755A="=(void*)0;\n";
char*s1827_1130154866A="Bad Environment variable.\n(Closing \"\175""\" not found.)";
char*s1956_923532A=" minus ";
char*s2545_7037A=" at ";
char*s1659_1814748872A="\" from ACE file. (Parsing \"";
char*s1892_345225764A="Different arguments types.";
char*s2174_1291760099A=";\nbreak;\n\175""\nbreak;\n";
char*s1584_80854A="flush";
char*s1584_13194A="TYPE";
char*s1830_1820580025A="Probably infinite or too long generic derivation of this type mark (see next warnings to find the cause of the problem... and good luck).";
char*s2179_1689502217A="Bad prototype for C struture get external.";
char*s2169_185428A="/*RF1:";
char*s1585_10193105A="expanded";
char*s1583_831708366A="Feature `copy\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s1674_1972884945A="The old \"SmallEiffel\" variable is not valid anymore. Please use Liberty Eiffel.\n";
char*s1584_10377643A="is_equal";
char*s2169_185438A="/*RF3:";
char*s1661_703496930A="\"[General] sys\" key is missing.";
char*s2380_1295032451A=".store_chunk=NULL;\n";
char*s1659_604558099A="Loaded Classe";
char*s2169_185443A="/*RF4:";
char*s2211_501491947A=" is expanded. (The whole type of the agent your are trying to launch is ";
char*s2169_185448A="/*RF5:";
char*s1659_1786429697A=" cannot be a root class since it is a generic class.";
char*s1956_1552156565A=" which is out of range 0..15 because target type is INTEGER_16.";
char*s2169_185453A="/*RF6:";
char*s1585_1975394A="cluster";
char*s1584_1594034A="ROUTINE";
char*s1652_75996531A="Discarded empty convert clause";
char*s1584_2246041A="storage";
char*s2169_185458A="/*RF7:";
char*s2378_1012357115A="(unsigned int size)";
char*s1659_24235871A="2011-2013";
char*s2262_323156020A="int bdw_delayed_finalize";
char*s2169_185463A="/*RF8:";
char*s1826_51017327A="Bad external signature (missing \")\" delimiter.";
char*s1665_934A="\"\n\"";
char*s1924_1809213019A="ref-status: ";
char*s2006_1284372793A="A function cannot be an assigner.";
char*s2018_1204053035A="c_inline_c(";
char*s1585_1839765037A="Cyclic anchored definition.";
char*s2169_185468A="/*RF9:";
char*s1661_830570470A="-cc specified more than once; last is used.\n";
char*s2123_481249030A=") != (o2->_";
char*s2296_495673125A=") is not smaller than upper bound (";
char*s1668_1752297822A="A frozen feature must not be undefined. What is frozen _is_ frozen.";
char*s1665_1642367158A=", sizeof(se_profile_t), profile_comparator);\n";
char*s1665_273431355A="return R;\n";
char*s1827_708319A="\" and \"";
char*s1674_7106A=" day";
char*s2262_15009395A="\"\n#endif\n";
char*s2378_915251302A=";\nif((o!=NULL)";
char*s1978_171706123A=" which is the generic constraint.";
char*s1661_50863580A="exit(0);\n";
char*s2018_1204053060A="c_inline_h(";
char*s2091_1747846A="\\SE.CFG";
char*s2174_7118A="-1)\?";
char*s1584_1607595572A="to_character";
char*s2191_557767498A=" in order to use it as a unique parent qualifier.";
char*s1585_1992063831A="ensure_check";
char*s2052_1962243783A="Bad anchor. Unknown feature name.";
char*s2263_207160501A="#ifndef FIXED_STACK_BOTTOM\nint valid_stack_bottom = stack_bottom != NULL;\n#endif\n";
char*s2182_124454155A=";\n*exp=1;\n";
char*s2031_1496963692A="Wrong usage of \";\" (semicolon) separator in manifest notation. Each bunch-size must be a multiple of ";
char*s2174_54714119A="sedb(&ds,";
char*s2179_87090A="pow((";
char*s1665_1586448448A="uint16_t lsv";
char*s2378_77282146A=".space_used+=size;\n";
char*s2179_185515A="(T6)((";
char*s1997_540477054A=", this type mark is not a TUPLE. (This is actually ";
char*s1636_1761241425A="Adding Cecil file: ";
char*s1669_992A="   ";
char*s1665_1500500537A=" live TYPEs:\n";
char*s1665_437715A="se_ms(";
char*s1652_1587734026A="Void cannot be the left-hand side of the binary \"\\\\\" operator.";
char*s2375_903312259A="return wr->o;\n";
char*s2378_160930A="))-1)\175""";
char*s1652_1703575813A="Bad character constant. Closing \"\'\" expected.";
char*s2182_160937A="(*C)->";
char*s1827_89867121A="\" section.";
char*s1956_205616643A="Overflow of infix \"-\" with INTEGER_32 operands. (";
char*s1665_514187710A="#ifdef __cplusplus\nextern \"C\" \173""\n#endif\n";
char*s2001_1615634978A="Unable to find the default creation procedure for expanded type ";
char*s1652_2080029331A="Slash \"/\" character expected after decimal value in CHARACTER constant.";
char*s1652_266191698A="The keyword \'creation\' is now replaced by \'create\'. Please update your code.";
char*s1661_851047233A="\nThe type of your operating system was automatically  computed. Please verify.\n";
char*s1665_1346694814A="if (sedb_status != SEDB_EXIT_MODE) ";
char*s1659_1365578385A="Starting simplify";
char*s1652_1090616383A="Unable to find a class definition in \"";
char*s1665_308580A="NULL;\n";
char*s2224_247541875A="copy index";
char*s2006_1436450217A="A string constant cannot be an assigner.";
char*s1659_713806135A=" (For this call, the target ";
char*s1901_646901709A="Call on a Void target.";
char*s1652_1581435442A="Bad external clause (manifest string expected).";
char*s2016_743946038A=" is expanded. The generic argument of WEAK_REFERENCE must not be expanded. (It does not makes sense to do so.)";
char*s2378_1413869902A="gc_update_weak_ref_item_polymorph((Tgc*)&(o1->object));\n";
char*s2238_1043A=" (+";
char*s2006_69279758A="A unique constant cannot be an assigner.";
char*s1661_17494489A="compile_to_c: \"";
char*s2239_1047A=" + ";
char*s1837_7207A=" in ";
char*s1585_10876026A="redefine";
char*s1665_437780A="se_msi";
char*s1652_1380562254A="Boolean expression expected (until).";
char*s2191_1092806174A=" The final export list is ";
char*s1964_1719402393A=".............................................";
char*s1658_23085765A=".(done).\n";
char*s2263_1102979933A="gc_is_off=0;\n";
char*s2378_1574324912A="dead=0;\175""\nelse\173""\n";
char*s1586_87180A="relax";
char*s1647_439490016A="\" does not belong to a creation clause of ";
char*s1659_385188989A="Before collect cycle";
char*s1652_1934613587A="Simple identifier expected just after a dot. Nothing else but a simple feature name is meaningful just after a dot.";
char*s1665_965818786A="No support found in directory sys/runtime for \"";
char*s2029_68732A="This ";
char*s1827_208962844A="*** Looking for ";
char*s1652_2091587115A="Void is not a valid target (i.e. just after a dot).";
char*s1665_4620481A="(T0*)(g[";
char*s2034_7232A=" is ";
char*s2174_7235A=");\175""\n";
char*s2006_1305581590A="An attribute cannot be an assigner.";
char*s1956_156630152A=" which is out of INTEGER_64 range.)";
char*s2172_167166A=")->id)";
char*s1581_1090A="\".\n";
char*s2263_1102979958A="gc_is_off=1;\n";
char*s2091_1027113524A="USERPROFILE";
char*s2174_1348915394A="DynamicDispatch";
char*s1665_1901755A="ac_req(";
char*s2172_580292587A="/*SFN*/(C->";
char*s2012_99702656A=" Feature `";
char*s1659_1839715989A="The feature called has no formal argument while the actual argument list has ";
char*s2122_302501127A="typedef union _se_agent se_agent;\ntypedef struct _se_agent0 se_agent0;\n";
char*s2006_1630520481A="The type of this constant feature should be REAL.";
char*s1665_197932A=";\n*C=M";
char*s2354_1101A="\").";
char*s2015_1554555636A="Cannot change exportation status of ";
char*s1652_879341913A="No more \"reference\" keyword allowed. The obsolete \"reference FOO\" notation is no longer accepted. Just use the REFERENCE class instead.";
char*s1956_1277330071A="Violated assertion (target value is ";
char*s1665_893005A="\"\\n\"),\n";
char*s2378_2136427942A="............ unique local buffer ...................";
char*s2031_1034900711A="Cannot pass Void into formal argument which is of type ";
char*s1988_1112A="\". ";
char*s1652_1617443474A="No sign allowed before an hexadecimal constant value.";
char*s1665_588411932A="void se_atexit(void)";
char*s2006_1051699101A="A constant cannot be an assigner.";
char*s2074_1330923746A="\175"". See the next error message.";
char*s1647_1121A="\".)";
char*s1919_327012886A=" but there is _no_ when clause selected. (Also note that there is no else part for this inspect statment, hence this error message.)";
char*s1652_1717397235A="Corresponding closing \')\' expected here.";
char*s1652_1003875089A="No more \"expanded\" keyword allowed here. The obsolete \"expanded FOO\" notation is no longer accepted.";
char*s1586_2141685A="no_main";
char*s2172_1446625A="INT8_C(";
char*s1901_1759986771A="This feature is only exported to ";
char*s1665_4620546A="(T0*)(t[";
char*s2378_7296A=" na=";
char*s2088_927498134A="run-time-set-count: ";
char*s2263_10322525A="\175""\nelse\173""\n";
char*s1966_1099750743A="Feature found is not writable (i.e. not an attribute).";
char*s1835_1133285999A="Cannot find the default class ";
char*s2375_1524126691A=" bdw_mallocT";
char*s1584_1157A="#//";
char*s1884_1981041429A="CODE_ACCUMULATOR code_stack";
char*s1665_273443870A="se_atexit(";
char*s2153_7317A=" of ";
char*s1665_1350760769A="assertion_depth++;\n\175""\n";
char*s1659_1535001676A="Details regarding Monomorphic calls:\n";
char*s2263_419443A="na_env";
char*s2020_1867518592A="Expression of the loop variant must be of INTEGER type. (The actual ";
char*s1661_1964046235A="\"[General] short\" key is missing.";
char*s1956_905382A=" gives ";
char*s1665_1142598643A="local_profile.profile=inv_profile+";
char*s2375_1858599648A="void*bdw_weakref_new(int n)";
char*s1827_305465997A="Quoted identifiers are deprecated. Please remove quotes here.";
char*s1584_1944903A="ceiling";
char*s2230_235492225A="Attributes cannot have a rescue compound.";
char*s1584_55040341A="put_16_be";
char*s2091_28418819A="/etc/serc";
char*s1585_10648581A="obsolete";
char*s1935_1552710436A="Internal error inside WHEN_ITEM_1 (compiler error).";
char*s1652_1819737650A="Must use exactly 4 hexadecimal digits for INTEGER_16.";
char*s1659_1206593669A="Monomorphic Procedure/Function Call";
char*s1568_1210A=".\n\n";
char*s1586_2246326A="verbose";
char*s1661_1215A="\'.\n";
char*s1827_767646015A="\" while the second is in the cluster \"";
char*s1830_1641573945A="The following path was misdetected as an inheritance cycle";
char*s1665_1839365502A="T0*se_ms(int c,char*e)";
char*s1665_1319581398A="se_dump_stack ds=\173""NULL,NULL,0,NULL,NULL,NULL,0\175"";\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s1584_9529116A="add_last";
char*s2172_11300605A="unsigned";
char*s2179_52075585A=" cannot be converted to a memory address.)";
char*s2378_7374A=" new";
char*s1674_1430004157A=" used in file \"";
char*s2179_1671074150A="((uint32_t)(";
char*s1956_1324951230A="Overflow of infix \"+\" with INTEGER_64 operands. (Adding ";
char*s1583_1897129554A="Feature `is_equal\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s1837_188916891A=" . The validation context is used to compute all anchored type marks.)";
char*s1652_155929078A="Incorrect TUPLE (type expected).";
char*s1659_646243744A="Symplify interrupted (infinite inlining ... or infinite recursion detected.).";
char*s1584_276937706A="slice_copy";
char*s2375_1180476551A=",NULL,NULL,NULL);\n";
char*s1584_1235A="#<<";
char*s1652_911265735A="Missing the \"is\" keyword\?";
char*s2172_1240A="(((";
char*s2378_407207A="fsoc H";
char*s1975_1700082283A="Invalid creation procedure. A function is not allowed as a creation procedure.";
char*s2179_520388145A="((int64_t)(";
char*s1584_55040391A="put_16_le";
char*s2179_704592146A="Invalid usage of feature `to_pointer\' of class ANY. (The target which is of type ";
char*s1584_1247A="#>>";
char*s2179_837784A=");\n*((T";
char*s2015_1377394679A=" does not have feature ";
char*s1652_445001496A="This is not a feature name, but a class name.";
char*s1934_1088174660A="(The corresponding feature definition is in the next error message.)";
char*s2263_52555395A="->header.flag)==FSOH_UNMARKED)\173""\n";
char*s1581_513843490A=") is used.\n";
char*s1584_55040401A="put_16_ne";
char*s1665_499425548A="NULL/*Unused Target*/";
char*s1837_4479182A=" column ";
char*s2157_1485929081A="int (*eq)(se_agent*,se_agent*);\n";
char*s2262_1208340604A="bdw_mallocT";
char*s1584_2067995A="implies";
char*s2179_870841390A="<<16)\174""((uint32_t)";
char*s1665_1919660703A="];\nse_profile_t sorted_agent_switch_profile[";
char*s1665_1264A="();";
char*s1659_1265A=").\n";
char*s2157_1269A=" R;";
char*s1665_1271B=")))";
char*s1665_1271A=" R=";
char*s1647_74133124A="\" is not a creation procedure of this class).";
char*s2379_1274A=")),";
char*s1665_148900A="!=0)\173""\n";
char*s2114_38182A="/*tmp";
char*s2157_182255408A="Deferred \173""";
char*s2180_1431664982A=">>24)&0xFF));\n#else\n";
char*s2180_1280A=")+(";
char*s2261_1281A="(0)";
char*s1665_1284A="((T";
char*s2172_1285A="),(";
char*s2262_1286A="(1)";
char*s2180_1291A="))=";
char*s1661_932412928A="                ";
char*s2208_1083579905A=" while building type ";
char*s1665_81256A="evobt";
char*s1665_1295B="*/\n";
char*s1665_1295A="*)(";
char*s2174_25900A=" && (";
char*s2172_1298A=", &";
char*s1988_1642232185A="Cannot find include \"";
char*s2006_1952642401A="The type of this constant feature should be BOOLEAN.";
char*s2174_685204250A=": switch(*(";
char*s2170_7454A="\'\\0\'";
char*s2169_1312A=")->";
char*s1883_855586967A="Cannot use agents type marks or TUPLE type marks inside cecil files (Liberty Eiffel limitation, sorry). To work around, just use an extra Eiffel routine/object to perform agent or TUPLE manipulation in pure Eiffel.";
char*s1585_1988096A="feature";
char*s2157_7475A=" se_";
char*s1584_747962924A="type_item_is_expanded";
char*s1665_32080A=")));\n";
char*s2090_902076231A="Type-system safety check not performed in this mode\n(use the -safety_check flag).\n";
char*s1895_10414970A="item_xxx";
char*s1920_1686701A="Result.";
char*s1585_945182441A="Environment";
char*s1665_1330A=");\n";
char*s2378_26635163A=")new_na(&";
char*s1584_1245671098A="set_object_attribute";
char*s1661_1335A=",-\n";
char*s1959_13637A="The ";
char*s2375_1542419950A="if(bdw_na_assign_innerT";
char*s1652_2097430832A="Underscore notation _ not supported inside fractional part.";
char*s1653_140920753A="You must use an even number of hexadecimal digits to denote a sequence of CHARACTERs.";
char*s2157_37202594A="Feature \"";
char*s2031_412142950A="Only static type can be used for this form of creation.";
char*s1975_1304837581A="First argument of `manifest_put\' must be an INTEGER.";
char*s1585_87466A="retry";
char*s1665_411134193A="........ local buffer ........";
char*s1833_413151726A=" because type ";
char*s1830_1136866084A="\n      inserted as ";
char*s2182_1068122514A="void* se_introspecT";
char*s2263_2077255577A="fprintf(SE_GCINFO,\"C-stack=%d \",gc_stack_size());\nfprintf(SE_GCINFO,\"main-table=%d/%d \",gcmt_used,gcmt_max);\nfprintf(SE_GCINFO,\"fsoc:%d(\",fsoc_count);\nfprintf(SE_GCINFO,\"free=%d \",fsocfl_count());\nfprintf(SE_GCINFO,\"ceil=%d) \",fsoc_count_ceil);\nfprintf(SE_GCINFO,\"rsoc:%d(\",rsoc_count);\nfprintf(SE_GCINFO,\"ceil=%d)\\n\",rsoc_count_ceil);\nfprintf(SE_GCINFO,\"GC called %d time(s)\\n\",collector_counter);\nfprintf(SE_GCINFO,\"--------------------\\n\");\n";
char*s2179_116864219A="local buffer...";
char*s1975_1081673178A="First argument of `manifest_make\' must be an INTEGER.";
char*s2033_869266852A="Cannot rename feature `c_inline_c\' because this name is used as a keyword to handle the corresponding \"built_in\" feature of ANY.";
char*s1892_590983311A="While checking this call in ";
char*s1669_1382A="-- ";
char*s1923_762122588A=" Error detected while checking this code in the ";
char*s1827_139303084A="c_compiler_options";
char*s2157_2028521226A="se_dump_stack ds;\n";
char*s1653_996106634A="Invalid unicode notation (see also http://www.unicode.org as well as feature \173""UNICODE_STRING\175"".valid_unicode).";
char*s1652_1910692676A="Routine body expected.";
char*s1652_1466196812A="Error while reading real number.";
char*s2378_1396A=" o)";
char*s2375_1043020315A=";\nreturn R;\n";
char*s1665_1618833880A="fd.assertion_flag=1;\n\175""\n";
char*s2191_1846931416A=" is not a valid ancestor for this method.";
char*s1827_86060043A="Just finished parsing of \"";
char*s2545_1807195960A=" does not provide any .h or .c file, nor a cecil.se file!";
char*s2114_7557A=" tmp";
char*s1957_1127350535A="Void must not be the right-hand side of an assignment test (always True).";
char*s1836_87520A="\173""ANY\175""";
char*s2116_1407A=")=M";
char*s2263_1994331A="gc_free";
char*s2262_1582973561A="bdw_weakref_setlink((bdw_Twr*)(";
char*s1956_1705796732A="Overflow of infix \"*\" with INTEGER_8 operands. (";
char*s2376_1414A=" gc";
char*s1653_181806522A="Unexpected new line in manifest string.";
char*s1665_1417A="/* ";
char*s2174_32175A=")) \173""\n";
char*s2182_32176A="(*C).";
char*s2191_39109479A=" is different from the one explicitly listed here.";
char*s1652_342864313A="An anchored type cannot be used to indicate exportation status in a client list.";
char*s1961_1732344459A=" and the default creation procedure (see `default_create\' in class ANY) is not allowed. You must use one of the available creation procedure here.";
char*s1652_2110077371A="Must use exactly 8 hexadecimal digits for INTEGER_32.";
char*s2157_1426A="*C)";
char*s1584_87541A="print";
char*s1584_1427A="#\\\\";
char*s1674_210310269A="Removing \"";
char*s1672_489233515A="agent_launcher";
char*s1919_1459510708A=" is of type ";
char*s2375_1114679499A=" bdw_malloc_innerT";
char*s1961_1382321814A="Cannot assign newly created object of type ";
char*s2180_29107967A="*((int32_t*)(";
char*s1665_1540494783A="]=((void(*)(FILE*,void*))se_prinT";
char*s1661_1438A=".00";
char*s2174_1241777620A="if (NULL==(";
char*s1665_2087300232A="void*(*se_introspecT[";
char*s2179_1124779458A="if(R)R=((C->_";
char*s1581_941571923A="output_error_warning_on";
char*s2239_1452A=" \174"" ";
char*s1906_1440516445A="Invalid type for the target of this function call.";
char*s1675_150325744A="can_assign_to";
char*s2052_90494969A=" is a procedure. Anchored type is not valid.";
char*s2262_308117350A="GC_enable();\n";
char*s1827_1689176777A="external_c_plus_plus_files";
char*s1665_1924772383A="/*Aliased storage area or unicode storage.*/\n";
char*s2263_1246790712A="gc_mark(u->";
char*s2024_486705491A="Unexpected trailing character";
char*s2263_530955790A="GC support: generating functions.\n";
char*s2376_81437A="fsoc*";
char*s1665_1476A=")R)";
char*s2180_813409A="))=*((T";
char*s1990_1478A="0.0";
char*s1665_188283590A="T0*se_ums(";
char*s2174_1307328870A="/*until*/if(";
char*s1892_934695142A="Different result types.";
char*s1665_1273572186A="se_local_profile_t local_profile, master_profile;\n";
char*s1581_579450289A=": the new name of the \"-trace\" flag is now \"-sedb\".\n";
char*s1652_54634669A="precursor";
char*s2156_340114884A="7(file,(EIF_STRING*)";
char*s1665_1493A="/*l";
char*s1584_1375414302A="type_generating_type";
char*s1652_1744209811A="Bad use of predefined type NATIVE_ARRAY.";
char*s2263_1770234694A="(!gc_is_off)";
char*s1665_13801A="]=p[";
char*s1665_586511651A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_agent_profile+i);\n\175""\n";
char*s2247_511703191A="Cannot rename ";
char*s2378_479982486A="!=NULL)\173""\nn=";
char*s1665_1404852998A="sedb_breakpoint(&ds,";
char*s1950_35382059A="\?=  assignment (an assignment attempt).";
char*s1652_49203356A="attribute";
char*s1665_2142659303A="se_profile_t inv_profile";
char*s1956_2480364A="Overflow for opposite of Minimum_integer_16.";
char*s1950_354065377A=" (\"::=\" is not necessary).";
char*s1668_582925635A="Can\'t join these two attribute definitions. Because an attribute cannot be undefined (using an undefine clause), you may consider to modify parents themselves. May be.";
char*s1652_2047201942A="Substitute with \",\".";
char*s1652_1909979286A="Feature name expected here.";
char*s1674_1680762272A="\" not found.\n";
char*s1584_880412606A="generating_type";
char*s1585_2234341A="variant";
char*s1827_1709309070A="Unable to load class \"";
char*s1661_1102814319A="System is \"";
char*s2179_1530A="->_";
char*s2375_7682A="*R=M";
char*s1652_833080669A="End of text expected.";
char*s2261_49806180A="s->id=7;\n";
char*s2179_1679636650A="((real32_t)(";
char*s2026_413651A="inline";
char*s2378_129037214A="(fsoc*c,gc";
char*s1584_279656751A="std_output";
char*s1956_2480394A="Overflow for opposite of Minimum_integer_32.";
char*s1652_962885232A="Expression ";
char*s1584_859431564A="type_attribute_generator";
char*s1665_490869799A="_external_cpp";
char*s1652_791727511A="Bad generic list. Expected \',\' or \']\', but found \'";
char*s1665_1164920984A="se_profile_t profile";
char*s1652_2099054905A="Correct the previous error";
char*s2211_643795973A="Incompatible actual argument for agent call. Cannot pass ";
char*s2263_1111954737A="void gc_mark_";
char*s1585_1957581A="default";
char*s1827_1553744164A="external_object_files";
char*s1665_1565A="&ds";
char*s2179_511943145A="),(double)(";
char*s1652_2037548A="Bad create instruction (type expected).";
char*s2157_491029751A="/*agent is_equal*/int ";
char*s2378_1111960899A="void gc_sweep";
char*s1665_1471782099A="switch (expression->id) \173""\n";
char*s1652_955584028A="Expression expected after the \"elseif\" keyword.";
char*s1585_407540A="frozen";
char*s1584_438300A="second";
char*s1899_242535516A="Invalid type for the target of this procedure call.";
char*s2261_161521A="))->o)";
char*s2174_283285900A="while(1)\173""\n";
char*s1665_1661632742A="]=atexit_profile;\n";
char*s2263_2006740748A="\173""int i=o->id;\n";
char*s1584_761722990A="mark_native_arrays";
char*s2031_1319735562A="Cannot use anchored type for this form of creation.";
char*s1652_1208507031A="Obsolete manifest string expected.";
char*s2157_1185483839A="ds.locals=NULL;\n";
char*s1665_341357508A="(c+1));\nmemcpy(s->_storage,e,c+1);\nreturn((T0*)s);";
char*s1674_3556890A="\" file.\n";
char*s1653_1038536453A="Extra blank or tab character removed in multi-line manifest string.";
char*s2156_1191155066A="(FILE* file,T";
char*s1661_2011772281A="Unknown C mode: ";
char*s1584_185934049A="NATURAL_16";
char*s1661_1626A="/Fe";
char*s1956_2480479A="Overflow for opposite of Minimum_integer_64.";
char*s1584_185934055A="NATURAL_32";
char*s1581_7779A=".ACE";
char*s1652_2055333675A="Slash \"/\" or decimal digit expected (inside CHARACTER constant).";
char*s1665_1607940692A="se_profile_t agent_switch_profile";
char*s1665_860532685A="handle(SE_HANDLE_NORMAL_EXIT, NULL);\n";
char*s1661_2139128753A="The environment variable \"";
char*s2263_1783951564A="if(gc_info_nb_agent)\n   fprintf(SE_GCINFO,\n   \"%d\\tagent(s) created. (store_left=%d).\\n\",\n   gc_info_nb_agent,store_left_agent);\n";
char*s1665_1639A=";\nr";
char*s1585_1532344910A="cpp_compiler_type";
char*s1584_619776399A="Integer_bits";
char*s1585_479921113A="c_compiler_type";
char*s2024_522818189A="default_value";
char*s2354_1644A=": \"";
char*s1584_185934072A="NATURAL_64";
char*s2180_32400A="));\n\175""";
char*s2157_1923813010A="\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.current=";
char*s2156_1646A="*o)";
char*s2015_2141380032A="Any given feature name should appear at most once in one export clause for each parent clause. Feature ";
char*s1652_1254996328A="Cannot use hexadecimal notation for this type.";
char*s2378_687744958A="o=(void*)o->_";
char*s2174_1650A=")\173""\n";
char*s2378_1651A="*p)";
char*s1975_265238926A="Feature `manifest_put\' must have at least two argument and the first one must be an INTEGER argument.";
char*s1661_7809A=".BAT";
char*s2174_180037A=" else ";
char*s2153_386149138A="pending_c_function_counter_tag";
char*s1652_401981819A="..........................................................";
char*s1665_1164208A="#ifdef _BASE_H\n#define _HAD_BASE_H\n#endif\n";
char*s2117_1046299075A=" (from -cecil \"";
char*s2263_1676A="*u)";
char*s1584_1326673961A="object_size";
char*s2262_112977096A="(GC_gc_no)";
char*s2179_32435A=")))\174""(";
char*s2378_44739A="=((gc";
char*s1586_1994621A="gc_info";
char*s1652_1289042164A="Void cannot be the left-hand side of the binary \"//\" operator.";
char*s2179_32456A=")+.5)";
char*s1665_1946737844A="Order of evaluation for pre-computed once functions:\n";
char*s1665_14005A="[];\n";
char*s1665_192841706A="NULL, NULL";
char*s1924_1348774A="AT_EXIT";
char*s1956_1337425939A=" which is out of range 0 ..63 because target type is INTEGER_64.";
char*s1668_1875884480A="The local definition in ";
char*s2091_142089811A="/etc/issue";
char*s1979_1110386385A="You have to use another name for this formal generic argument. The common usage is to add an extra trailing underscore character (see for example COLLECTION, ARRAY or DICTIONARY).";
char*s1665_7869A="&ds,";
char*s2262_636642526A="(!GC_dont_gc)";
char*s1837_2082988666A=" (The validation context is ";
char*s1661_7878A=".CMD";
char*s2174_1727A=":/*";
char*s1966_183516812A="Attribute ";
char*s2179_1586596820A="<<8)\174""((uint16_t)";
char*s2180_29126717A="*((int16_t*)(";
char*s1585_14036A="True";
char*s1584_55926626A="std_input";
char*s1665_48520827A="cecilcrea";
char*s2174_1060489498A="requireresult=";
char*s2154_161665A=" NULL\n";
char*s1975_1857191624A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_semicolon_check\').";
char*s1670_1797674551A="internal_exception_handler(Incorrect_inspect_value);\n";
char*s1661_1744A=".cc";
char*s2174_1115076A="=((T0*)";
char*s2174_180128A=" else\173""";
char*s1652_941240074A="Keyword \"end\" expected at the end of check clause.";
char*s1827_608446371A="You have to fix the problem in your ACE file. Valid assertion level tags are: \"no\", \"require\", \"ensure\", \"invariant\", \"loop\", \"check\", \"all\", and \"debug\".";
char*s2030_1753A="0e0";
char*s2031_112048371A=" creation.";
char*s1665_1852104762A=" C;\nint i=0;\nva_list pa;\nva_start(pa,argc);\nC=";
char*s1668_22612837A=" in type ";
char*s1665_1765A="=((";
char*s1961_176104896A=" ... << ... >> \175"" manifest creation notation.";
char*s1927_1712194128A="\' is out of INTEGER_8 range.";
char*s1653_256559978A="Useless keyword deleted.";
char*s1961_1458557644A="Creation clause exists for type ";
char*s1647_1052333303A=" (compare usage and definition below).";
char*s1652_1296817101A="). Instruction or keyword \"";
char*s1661_1775A=".id";
char*s1580_1128710280A="Liberty Eiffel does not (yet) support precompiled headers for\nthis C compiler. Please drop an e-mail liberty-eiffel@gnu.org%N";
char*s1652_376006259A="Missing manifest STRING for `c_inline_c\'.";
char*s1665_1364588829A=" se_manifest";
char*s1926_7506001A="Current.";
char*s1665_36778611A="local_profile.profile=profile+";
char*s1652_970900228A="\" while waiting for some local variable name. Cannot use \"";
char*s2154_565063403A="/* C Header Pass 2: */\n";
char*s2006_2108232434A="The type of this constant feature should be STRING.";
char*s1665_4049151A="((T0*)C)";
char*s2378_1523807481A="*o1,*o2;\no1=((gc";
char*s2046_920757291A="The value of ";
char*s1950_1801A="::=";
char*s2262_539192311A="void*bdw_markna;int bdw_generation;";
char*s1652_1917483795A="Error while reading manifest number.";
char*s2191_1658151484A=" misses some clients of the conforming parent(s) for ";
char*s1665_1630601156A="during C code generation (backend)";
char*s1659_89019087A="\" in type ";
char*s1585_2185421A="require";
char*s1585_251171752A="flat_check";
char*s1652_1778077539A="Void cannot be the left-hand side of the binary \"-\" operator.";
char*s1584_312005144A="type_can_be_assigned_to_attribute";
char*s1652_1665385073A="The base type is no longer used. Class FUNCTION now has only two formal generic arguments. Just remove this unused type mark.";
char*s1905_1771711260A="Symplify interrupted (infinite inlining\?) in CALL_0.\n";
char*s1580_1464431905A="Usage: compile_to_c [options] <RootClass> <RootProcedure> ...\n   or: compile_to_c [options] <ACEfileName>.ace\n\nFor information about and examples of ACE files, have a look\nin the SmartEiffel/tutorial/ace directory.\n\nMost of the following options are not available when using\nan ACE file.\n\nOption summary:\n\nInformation:\n  -help               Display this help information\n  -version            Display Liberty Eiffel version information\n  -verbose            Display detailed information about what the compiler is\n                       doing\n\nWarning and Error levels:\n  -style_warning      Do print warnings about style violations\n  -no_warning         Don\'t print any warnings\n  -relax              Performs less checks by considering less dead code, hence\n                       using less memory and less compilation time. Useful to\n                       prototype or to deliver safe code. (Useful too for very\n                       small computers.)\n\nOptimization and debugging levels (specify at most one; default is"
" -all_check):\n  -boost              Enable all optimizations,\n                       but disable all run-time checks\n  -no_check           Enable Void target and system-level checking\n  -require_check      Enable precondition checking (implies -no_check)\n  -ensure_check       Enable postcondition checking (implies -require_check)\n  -invariant_check    Enable class invariant checking (implies -ensure_check)\n  -loop_check         Enable loop variant and invariant checking\n                       (implies -invariant_check)\n  -all_check          Enable \'check\' blocks (implies -loop_check)\n  -debug              Enable \'debug\' blocks\n  -flat_check         Each assertion will be executed in no_check mode\n                      Use with any mode from require_check to all_check\n\nClass lookup:\n  -loadpath <file>    Specify an extra loadpath file to read\n\nC compilation and run-time system:\n  -cc <command>       Specify the C compiler to use\n  -c_mode <C mode>    Specify a C mode to use. This option is incompatible\n        "
"               with -cc\n  -cecil <file>       Take CECIL information from <file>\n                       (may be used more than once)\n  -o <file>           Put the executable program into <file>\n  -no_main            Don\'t include a main() in the generated executable\n  -no_gc              Disable garbage collection\n  -bdw_gc             Use Boehm-Demers-Weiser conservative GC\n  -gc_info            Enable status messages from the garbage collector\n  -no_strip           Don\'t run \'strip\' on the generated executable\n  -no_split           Generate only one C file\n  -split <split mode> Selects the split mode\n                       Either \'no\', \'legacy\', or \'by_type\'\n  -sedb               Enable sedb, the Liberty Eiffel debugger\n  -profile            Generates profile on Eiffel calls at program exit\n  -manifest_string_trace\n                      Enable the trace support to track non-once\n                      manifest string creation\n  -no_rescue          Don\'t compile rescue sections\n\nMiscellaneous:\n  -high_memory_c"
"ompiler\n                      Allow the compile_to_c to use more memory; if you\n                      have enough physical memory, compilation should\n                      be faster (note: generated C code is not affected)\n";
char*s2091_1826A=".se";
char*s1675_75639A="_from";
char*s2031_1832A="<< ";
char*s2261_54714979A="se_malloc";
char*s2179_1651828280A="/* same_dynamic_type */\n";
char*s1892_1813679543A="In the redefinition context (i.e in ";
char*s2179_1214258443A="0;\nerror0(\"Invalid is_deep_equal.\",NULL)";
char*s2179_167916A="((uint";
char*s2179_1840A="<<(";
char*s2179_108351709A="),sizeof(T";
char*s1584_94407393A="collection_off";
char*s1584_14150A="Void";
char*s2378_32605A="*)(&(";
char*s1652_50040236A="else part";
char*s1665_1154403080A="print_profile(profile_file, &atexit_profile);\n";
char*s2024_1468725331A="Required key \"";
char*s1665_426087775A="#ifndef _HAD_BASE_H\nextern void*eiffel_root_object;\n\ntypedef T3*T9;\n#endif\n/* Available Eiffel routines via -cecil:\n*/\n";
char*s1665_57150800A="atexit(se_atexit);\n";
char*s1652_1021024803A="Manifest string expected for \"obsolete\" clause.";
char*s2378_47598300A="o);\n\175""\n\175""\n\175""";
char*s1830_1188332009A="This call should be some constant feature call (i.e. a statically computable value). (See the definition found in the next error message.)";
char*s1652_603076667A="Writable entity expected here.";
char*s2180_534333098A="<<8)&0xFF0000)\174""(((uint32_t)";
char*s2378_692075493A="*)o)->header.flag==FSOH_UNMARKED))";
char*s1665_107312226A="*sizeof(se_profile_t));\nqsort(sorted_agent_switch_profile, ";
char*s2006_90390825A="Cannot use type ";
char*s1665_267478119A="if(se_rci(caller,C))";
char*s1586_2191641A="profile";
char*s2156_565069653A="/* C Header Pass 4: */\n";
char*s2180_2001063662A="\173""/*slice_copy*/\nint a3tmp=";
char*s1586_822199910A="style_warning";
char*s1652_2047202317A="Substitute with \";\".";
char*s2179_32650A="))>>(";
char*s2155_2057228449A="\173""Tid id;T0*o;\175"";\n";
char*s1665_438660461A="Cannot produce C code.";
char*s1652_502181838A="Missing \"\175""\" to terminate manifest generic creation.";
char*s1652_307717976A="Error while reading a number. Missing \"\175""\" \?";
char*s1659_327902A="TUPLE ";
char*s2179_1900A=">>(";
char*s2179_10089540A="floorf((";
char*s1652_1938643327A="This call has a result value (and you must use it).";
char*s1665_1580612071A="se_profile_t runinit_profile";
char*s2123_1747685533A="typedef void*T";
char*s1584_735034101A="storage_lower";
char*s1652_376006384A="Missing manifest STRING for `c_inline_h\'.";
char*s2006_573004463A="A character constant cannot be an assigner.";
char*s1584_50778415A="exception";
char*s2157_505232755A="/*agent creation*/T0*";
char*s2172_36126743A="INT32_MIN";
char*s1665_7918258A="SE_MAXID";
char*s2376_413927315A="(x) (((se_agent0*)(x))->gc_mark_agent_mold((se_agent*)(x)))\n\n";
char*s1835_1185293475A="). Cannot go on: please send a mail at smarteiffel@loria.fr";
char*s2263_1994852A="gc_mark";
char*s1584_1530432238A="valid_generating_type_for_internals";
char*s2179_887295984A="\n#if BYTE_ORDER == LITTLE_ENDIAN\n(";
char*s1652_2061122069A="Error while reading a real. Missing separator after the value \?";
char*s1652_945201499A="\'. May be, you just miss to add the \"is\" keyword\?";
char*s1652_1933A="C++";
char*s2117_992810240A="The type for a creation procedure cannot be INTERNALS.\n";
char*s1584_88048A="put_0";
char*s1665_950675891A="local_profile.profile=&runinit_profile;\n";
char*s1584_88049A="put_1";
char*s2116_942808765A="void manifest_string_mark";
char*s1652_246527867A="Incorrect hexadecimal notation. Wrong number of hexadecimal digits (";
char*s1661_69601A="a.exe";
char*s1584_55041091A="put_32_be";
char*s1652_4492176A="........";
char*s2157_2111741A="locals[";
char*s2378_27909038A="if(NULL==gc_find_chunk(o))\nreturn; /* external NA */\n";
char*s1584_36200588A="INTERNALS";
char*s2117_724183788A="The type for a creation procedure cannot be deferred.\n";
char*s1661_683870135A="cc/warning=disable=(embedcomment,longextern) ";
char*s1584_261093457A="make_blank";
char*s1652_1991246741A="Void is not a valid BOOLEAN expression (just after keyword \"inspect\").";
char*s2031_909851733A="Irregular number of items in bunches. The previous bunch is smaller.";
char*s1584_1286698901A="element_sizeof";
char*s1652_1505459217A="Keyword \"end\" added to terminate inherit/insert parent.";
char*s1652_1421116705A="Slash \"/\" character expected after hexadecimal value in CHARACTER constant.";
char*s2179_9794360A="deeptwin";
char*s1661_1115301A="-x none";
char*s1674_124992A="      ";
char*s2157_2072064738A="struct rescue_context rc;\n";
char*s1584_1680885744A="default_rescue";
char*s1661_5525574A="-x \"c++\"";
char*s2262_1933391A="bdw_ms[";
char*s2378_525205114A="*o=(&(p->object));\n";
char*s2262_1949186219A="/*mark_item*/";
char*s1665_11086084A="sizeof(T";
char*s2157_4996600A="*a1=(se_";
char*s1652_676728857A="Error in manifest constant or \"\?:=\" type test \?";
char*s1585_451011A="unique";
char*s2179_86195952A="((T0*)se_string(se_argv[";
char*s1584_55041141A="put_32_le";
char*s1668_1127406485A="An attribute cannot be undefined.";
char*s1659_2029530601A="Polymorphic Proceduire/Function Call";
char*s1665_1492394528A=";while (i-->0) \173""\nsumup_profile(profile_file, sorted_all_profile+i);\n\175""\n";
char*s1584_55041151A="put_32_ne";
char*s2179_19199275A="!=NULL)\173""\n";
char*s1674_1711985232A="Cannot write file \"";
char*s2156_2039095413A="0(file,(T0**)";
char*s1652_1284361566A="Character \'%\"\' inserted after \"infix\".";
char*s1659_1378502623A="Before simplify cycle";
char*s1953_729510616A=" with expression ";
char*s2174_28032126A="=((void*)";
char*s2031_1646704683A="Unexpected \";\" (semicolon) separator in manifest generic expression. Less items found in this bunch than in the previous one.";
char*s1665_1965252672A="]=((void*(*)(void*,char*,int*,int*))se_introspecT";
char*s2378_2121801775A="* old_gc_free = gc_free";
char*s2172_161951A="((T0*)";
char*s1830_1281353746A="\n      inherited as ";
char*s1665_772432310A="local_profile.profile=agent_profile+";
char*s1830_169314461A="No feature found for this call.";
char*s1885_971287994A="Precondition";
char*s1584_586229245A="type_is_expanded";
char*s2179_484454800A="\" argument in external C inline definition.";
char*s2182_1150927957A="*C,char*attr,int*id,int*exp)";
char*s1584_1395184171A="same_dynamic_type";
char*s2179_10089690A="floorl((";
char*s1665_1307483215A="(&ds,&local_profile,C);\n";
char*s1659_891552598A=" cannot be a root class since it is a deferred class.";
char*s1665_1724182721A="local_profile.profile=&prof;\n";
char*s2179_476433922A="deep_twin_from(";
char*s1659_1145029170A="Internal compiler error (set_agent_creation_error_trap).";
char*s1653_446380143A="Unexpected comma (deleted).";
char*s2157_826425832A="se_dump_stack*caller";
char*s2172_21020045A="((void*)(";
char*s2179_9954400A="if(!R)\173""\n";
char*s1661_186217457A="... unique once buffer ...";
char*s2179_162010A="));\n\175""\n";
char*s1665_1656195746A=" main(int argc,char*argv[])";
char*s1659_1483967746A="Polymorphic Distribution of \"inspect\" Statements. Measurement\ndone ";
char*s1950_1747372019A=" The left-hand side expression must conform to the right-hand side. The expression ";
char*s2172_162019A="((T3)\'";
char*s2179_162020A="((T3)(";
char*s2182_5279655A="*id=-1;\n";
char*s1957_1993565801A=" can be normally assigned into the left-hand side which is of type ";
char*s1665_506210947A="se_general_trace_switch=1;\n";
char*s1584_1300046706A="last_result";
char*s1584_2104A="ANY";
char*s2180_32860A="));\175""\n";
char*s1665_8260A=";\n\175""\n";
char*s2180_2110A=";\175""\n";
char*s1665_32869A="(&ds,";
char*s1652_2001191A="current";
char*s2157_1032053803A="se_dump_stack ds;\nds.fd=&fd;\nds.current=NULL;\nds.p=(caller->p);\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s2375_788978585A="if(o->bdw_markna==NULL)\173""\nT0**markna;\nGC_disable();\nbdw_in_assign=1;\nmarkna=se_malloc(sizeof(T0*));\nGC_REGISTER_FINALIZER_NO_ORDER(markna,(GC_finalization_proc)bdw_na_markT";
char*s2031_1427483140A="Missing argument before << ... >> item list.";
char*s2375_546112503A="void bdw_run_finalizers(void)";
char*s1884_977955761A="SEDB object";
char*s1585_408086A="export";
char*s1665_531983658A="local_profile=global_profile;\n";
char*s2090_1806821466A="specializing and checking";
char*s1585_251916328A="cpp_strip_path";
char*s1652_1176245553A="Anchor expected. An anchor could be `Current\', a feature name or an argument name.";
char*s1647_1781104140A="Deferred class should not have creation clause (VGCP.1).";
char*s1663_57487A="Amiga";
char*s1665_451157A="unlink";
char*s2179_8291A="(int";
char*s2156_205124A="(file,";
char*s2030_2009909053A="...........................................................";
char*s2179_162070A="((T5)(";
char*s1585_69805A="Tools";
char*s2182_1113554587A="void*R=NULL;\n";
char*s1665_389672A="char*p";
char*s1665_389675A="char*s";
char*s2116_147115629A="=/*alloc*/((T0*)(";
char*s2378_1927425A="begin:\n";
char*s2379_14464A="\\n\",";
char*s1924_202031759A="STD_OUTPUT";
char*s1652_2051403723A="Added \"end\" to finish this \"if\" statement.";
char*s2174_162095A="((T6)(";
char*s2261_2138778683A="se_malloc(sizeof(T";
char*s1830_32926A=", ...";
char*s1674_461074983A="The old \"SmallEiffelDirectory\" variable is not valid anymore. Please use SmartEiffelDirectory or,\nbetter still, don\'t use it at all.\n";
char*s1956_900982204A="Overflow of infix \"+\" with INTEGER_16 operands. (Adding ";
char*s1663_2178A="DOS";
char*s1585_401994A="flavor";
char*s2375_1744880961A=")se_calloc(*n, sizeof(T";
char*s1584_2035472654A="type_attribute_count";
char*s2375_42739336A="(&n);\nif(GC_should_invoke_finalizers())bdw_run_finalizers();\nreturn R;\n";
char*s2545_482960256A=">. The plugin seems to depend on itself! Ignored.";
char*s1661_69851A="a.out";
char*s2090_1243691337A="getting started";
char*s1665_1826935309A="memcpy(sorted_inv_profile, inv_profile, ";
char*s1585_2032026A="exclude";
char*s2179_1726920051A="se_deep_equal_start();\n";
char*s1585_264667428A="assertion_flat_check";
char*s1665_351488799A="/*unknown position*/";
char*s1652_4750778A=" warning";
char*s1665_383570A="agents";
char*s2375_1005223232A="void bdw_na_markT";
char*s2179_1240185282A="Bad prototype for C struture set external.";
char*s1585_820292A="****** ";
char*s1668_1585514726A=", features \"";
char*s2157_1637927398A="se_local_profile_t*parent_profile";
char*s1827_698011541A="Cluster tree:\n";
char*s1944_529996976A="Conflict between local/feature name (VRLE).";
char*s1668_1297180456A=" because there is a local definition in this class. Redefine has been automatically added. Please check.";
char*s1584_1447702A="INTEGER";
char*s1661_1255802680A="emxbind -qs";
char*s2074_922867504A="This obsolete manifest ARRAY creation is no longer supported. See our \"SmartEiffel/tutorial/manifest_notation.e\" in order to use the new notation.";
char*s1585_88336A="short";
char*s1652_599810839A="There is no need for the \"expanded\" keyword in an \"insert\" clause.This keyword will be ignored.";
char*s2156_1112927266A="void se_prinT";
char*s1584_840111968A="collection_on";
char*s2031_115013643A="Actually, for class ";
char*s2179_234933541A="_t)-((uint";
char*s1583_1181006553A="Feature `default_rescue\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s1652_1023251859A="Replaced misspelled \"False\".";
char*s2297_2114672999A="Using range inside inspect of type STRING is not possible.";
char*s1956_442652821A=" which is out of range -31..31 because target type is INTEGER_31.";
char*s1659_601041072A="class-path: \"";
char*s1975_797085749A=". An expanded type must have one unique creation procedure with no argument: the creation procedure used for automatic initialization.";
char*s1584_1297432701A="is_infinity";
char*s2378_5839580A=".store;\n";
char*s1584_2067759348A="from_pointer";
char*s2157_832670A="(*afp)(";
char*s2182_8436A="*id=";
char*s1988_408035024A=" is hiding the definition in ";
char*s2191_1679625106A="The final client list for ";
char*s1883_864187036A="Loading cecil entries:\n";
char*s2263_1155996628A="/*mark_item*/\175""";
char*s1584_1209184326A="object_invariant";
char*s1652_700613496A=" is not a valid feature name to start a new feature definition. Parser lost. Sorry. Check before and after that point.";
char*s2179_45355A="=*C;\n";
char*s2182_1245850444A="\173""\nstatic T0*_r=NULL;\n_r=";
char*s1668_1041926341A="The feature ";
char*s2157_2301A="R&=";
char*s1652_1689577436A="Expression expected after \"elseif\" keyword.";
char*s1584_1604515261A="to_internals";
char*s2179_1096165867A="is_deep_equal(";
char*s1652_860582570A="\" cannot be a valid feature name or a valid local name (only lower case letters are allowed here). Furthermore \"";
char*s2179_245384155A="clear_all(";
char*s1665_1816632501A="se_local_profile_t local_profile;\n";
char*s1668_1811139659A=" type.\n\nFirst \"insert\" path (from parent to child):\n   ";
char*s1584_728963476A="type_item_generating_type";
char*s1584_9647090A="and then";
char*s2263_8475A="(se_";
char*s2378_945011211A="=(((void*)obj_ptr)<=((void*)item));\nobj_ptr = (T0*)(((char*)obj_ptr) + obj_size);\nif (swept != (((fso_header*)obj_ptr)->flag==FSOH_UNMARKED)) /* **** TODO: was FSOH_UNMARKED\?\?\?\? (incoherent with comment below) */\n/* (already swept) xor marked */\nitem->o=NULL;\n\175""\n";
char*s1652_28789007A="Actually, a creation list must not be empty. You must have at least the `default_create\' procedure inherited from ANY. The `default_create\' indicates that one can also create an object with no creation procedure. The `default_create\' has been added here automatically.";
char*s1652_1874765620A="A missing client clause is interpreted as \173""ANY\175"". It is better to be explicit.";
char*s1663_395994A="distcc";
char*s2179_8485A="(vc(";
char*s1660_546635553A="SMART_EIFFEL_SHORT_VERSION";
char*s2179_1553763390A=")==(a1ptr->_";
char*s1665_20552830A="(&ds,C);\n";
char*s2190_1664721281A="........... unique buffer ...............";
char*s1652_1752914319A="Instruction expected here. False alone is not an instruction.";
char*s1652_2020913390A="Added missing \"then\" keyword.";
char*s1585_414461A="insert";
char*s2157_1426099398A=".............................";
char*s1652_156243902A="Void cannot be the target of prefix operator \"";
char*s2171_1476205446A="fcstrangeisnotunlock";
char*s2174_1936367907A="/*inspect]*/\n";
char*s1827_1955866577A="external_lib_path";
char*s2190_1025503229A=" using range tmp0 .. tmp";
char*s2002_914877497A="Same feature name appears twice.";
char*s2378_1653483427A="typedef struct Sgc \173""Tid id;T0*o;\175"" Tgc;\n";
char*s2179_244793715A="deep_twin(";
char*s1921_1360462097A="reference: ";
char*s2334_1121854A="/bin/sh";
char*s1892_2084982239A=" context, it appears to be a call to an obsolete feature:\n";
char*s1584_175767198A="EXCEPTIONS";
char*s2191_1238684603A="The client list computed from the \"export\" clauses";
char*s1661_45436A=".make";
char*s2378_737599544A="=o1;\n\175""\n\175""\n\175""\nelse\173""\nint dead=1;\ngc";
char*s1665_419316052A="/*Force definition of non-live NATIVE_ARRAY[CHARACTER] for manifest strings*/\ntypedef T3* T9;\n";
char*s1665_2382A="T0*";
char*s1665_732574181A=";\nwhile (i < argc ) \173""\n";
char*s1647_1452647150A="Forbidden creation call (i.e. exportation rules violated). Creation is only allowed from ";
char*s1921_41841490A="FIXED_STRING";
char*s1661_217674A=".h.gch";
char*s1665_149822297A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_agent_switch_profile+i);\n\175""\n";
char*s2153_1359151955A="internal_c_local_tag";
char*s2153_8545A=":*/\n";
char*s2187_2394A="T11";
char*s2157_126319331A="rescue_context_top = rc.next;handle(SE_HANDLE_EXCEPTION_CLEAR,NULL);\n";
char*s1665_2395A="R=(";
char*s2187_2395A="T12";
char*s1652_1478844272A="Removed that non-significant digit in integral part or real constant.";
char*s1652_1223700793A="Inside a function, a Precursor call must be a function call (not a procedure call).";
char*s1652_529554293A="Removed unexpected blank space(s) just before this dot (assume you really want to call a function using the previous manifest expression as the target).";
char*s1837_63912A="Line ";
char*s1652_2117988535A="Void is not a valid BOOLEAN expression (just after keyword \"elseif\").";
char*s1659_2114217978A="Monomorphic Function Call";
char*s2263_1327517381A="#ifndef FIXED_STACK_BOTTOM\nif(!valid_stack_bottom) stack_bottom = NULL;\n#endif\n";
char*s2174_2065182209A="if(!requireresult)\173""\n";
char*s1665_1530032908A="fprintf(profile_file, \"\\n-------------------------------------------------------------------------------\\n\");\ni=";
char*s1953_1222747401A=". (This would always yield to a ";
char*s1827_2070822678A="The \"adapt\" clause is not yet implemented.";
char*s1585_76226A="adapt";
char*s1652_439136A="select";
char*s1665_2417A="T7*";
char*s1988_146113272A="The definition of ";
char*s1647_2123229206A=" is obsolete:\n";
char*s1827_763815152A="\nYou are in command line mode (i.e. no ACE file is used).\nThe load path can be changed using a file called\nloadpath.se in the current working directory.\nUsually, this loadpath.se file is a simple list of directories.\nIt is also possible to use system variables or include files. See\nthe documentation for the finder command for more information.\n";
char*s1827_957054969A="-debug_check is deprecated. Please use -debug and another -*_check assertion level. This defaults to -all_check.";
char*s2037_180503525A=".......................";
char*s1663_2440A="OS2";
char*s1827_556698697A=": error: No <Root-Class> in command line.\n";
char*s1661_6159594A="C mode \"";
char*s2375_82948679A=")bdw_malloc_innerT";
char*s2155_199280A=",NULL\175""";
char*s2262_645592960A="s=(T7*)bdw_mallocT7(1);\n";
char*s1674_1974940930A="\" variable used";
char*s2179_8779932A="Unknown ";
char*s2179_168532A="*)R)=M";
char*s2182_1956008156A="\175"" else \173"" *id=0; \175""\n";
char*s1653_274238642A="Deleted extra comma.";
char*s1584_2090604340A="full_collect";
char*s1584_591414963A="standard_copy";
char*s1666_1753572602A="Infinite inlining loop (bad recursion \?\?). ";
char*s1652_614881029A="Syntax error while trying to parse a conversion clause. Expected either \'(\' or \':\'";
char*s2122_11381817A="typedef ";
char*s2174_48939825A="default:\n";
char*s1653_332623945A="Bad creation/create (procedure name expected).";
char*s2378_8624A="*new";
char*s1956_282345691A=" which is out of range -7..7 because target type is INTEGER_8.";
char*s2116_1119207694A="&gc_local_profile";
char*s2263_118716790A="fprintf(SE_GCINFO,\"==== Last GC before exit ====\\n\");\ngc_start();\n";
char*s2174_48939847A="default: ";
char*s1652_554066118A="\" is not valid identifier. For a better readability Liberty Eiffel _is_ case sensitive. Hence \"";
char*s1652_1439398002A="A Precursor type mark annotation must not be anchored.";
char*s2024_1917908900A="feature_name";
char*s1652_1193216533A="A type mark is not a valid item for a manifest array. Keep in mind that Liberty Eiffel is case-sensitive and that ";
char*s2174_279959115A="\173""\nse_dump_stack *caller=&ds;\n\173""\nse_dump_stack ds=\173""NULL,NULL,caller->p,caller,NULL,NULL\175"";\n";
char*s1652_277837020A="Missing items in manifest creation \"<< ... >>\" list. The last bunch should have ";
char*s1584_2504A="SET";
char*s1655_1656731300A=" in the section [";
char*s2263_49917876A="if(NULL!=";
char*s2091_193194A="/.serc";
char*s1663_207986277A="OpenVMS_CC";
char*s1652_180894A=" error";
char*s2375_2075405A="na=o->_";
char*s2373_125876584A="GC_call_with_alloc_lock((GC_fn_type)bdw_na_assignT";
char*s1840_1477688005A=": unsupported option \"";
char*s1885_1777506207A="Check_instruction";
char*s1585_402346A="ensure";
char*s2179_33291A="((int";
char*s1674_2537A="No ";
char*s1652_761631659A="Cannot use an uppercase letter inside such an identifier. Yes, this rule is strict, but it is better for all of us to be able to distinguish at a glance a CLASS_NAME from another name. Furthermore, it would be really too bad for example to use `IsEmpty\' or `isEmpty\' at one place while all other places are using `is_empty\'. Finally, this strict constraint will help us to improve error messages of the compiler.";
char*s1927_2126200255A="................................";
char*s1670_584218374A="setup_signal_handler();\n";
char*s1665_2545A="\n*/\n";
char*s2157_1575353618A="static se_frame_descriptor fd=\173""\"Agent launcher\",0,0,\"\",1\175"";\n";
char*s2375_886939850A="**markna,void*_)";
char*s2123_33316A="* o2)";
char*s1584_1223768616A="NATURAL_GENERAL";
char*s2376_2082029949A="\173""0,NULL,NULL,NULL,(void(*)(T0*))";
char*s2243_2565A="[1-";
char*s1652_1909918820A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure to the previous `False\' constant as target).";
char*s2191_1711825865A="Multiple Precursor found (must use Precursor \173""...\175"" ancestor selection).";
char*s1584_744845610A="valid_generating_type_for_native_array_internals";
char*s2263_1637706318A="GC support: adding root functions.\n";
char*s1956_1670460393A="Overflow of infix \"-\" with INTEGER_16 operands. (";
char*s2091_64080A="Linux";
char*s2179_2571A="]))";
char*s2179_1079001A="(void*)";
char*s2157_1489891655A=" features).\n";
char*s1953_1182157125A="The declaration type of ";
char*s2179_37173080A="R,a1-1);\n";
char*s2123_3920780A="(&(o1->_";
char*s1663_76405A="bcc32";
char*s1668_305596576A=") there are two versions of the same initial feature with two different names. To  fix this, either use an \"insert\" link in place of one of the \"inherit\" links or rename the feature to get the same name in ";
char*s1665_1361175839A="init_profile(profile+";
char*s1827_22915075A=" items):\n";
char*s1665_218061703A="*/\nse_signal_handler(14/*System_level_type_error*/);\n";
char*s1661_98806116A=" Data=Auto";
char*s1585_82570A="infix";
char*s2263_411283072A="/*Ordinary once functions:*/\n";
char*s1652_1731250773A="Empty generic list (deleted).";
char*s1583_1194182360A="Feature `default_create\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s1652_1564737054A=" after the $ operator. ";
char*s1581_8771A=".ace";
char*s1653_894954671A="In extended form of manifest string. Bad character after \'%\'.";
char*s2117_950159899A="Error while loading features of cecil path file \"";
char*s1652_2992013A="Unknown external language specification.";
char*s1665_2630A="];\n";
char*s1585_114085235A="# End of parallelizable section";
char*s1661_1247935972A="\" environment variable\nwith the absolute path of your own hand-made SmartEiffel\nconfiguration file.\n";
char*s1665_1308400309A="#define SE_EXCEPTIONS 1\n";
char*s2180_1773508175A="<<24\174""(((uint32_t)";
char*s1661_8801A=".bat";
char*s2179_524787520A="((uint8_t)(";
char*s1661_530877013A=" StripDebug";
char*s2006_789877170A="Unique feature must have INTEGER type.";
char*s1652_1098712729A="Manifest value not compatible with this type.";
char*s2179_1116064705A="(T6)!memcmp(C,&a1,sizeof(T";
char*s2180_1053613605A=";\nmemcpy(&((";
char*s2006_783418632A=". Bad constant-attribute definition.";
char*s2116_2670A="]=(";
char*s1665_33425A=")->id";
char*s1923_292944046A=" Bad assignment.";
char*s2378_1069766146A=".store_left;\n";
char*s1584_88795A="third";
char*s2354_480414235A="Unknown loadpath in ";
char*s1659_1572647306A="The feature called has ";
char*s2380_585110409A=".store->header.size=";
char*s1665_1082664800A="start_print_profile(profile_file);\n";
char*s1671_138929174A="\" seems to be empty.";
char*s2179_1263916320A="fpclassify(";
char*s1581_1010347497A="Flag -is_output_error_warning_on must be used only once.\nYour command was:\n";
char*s1585_2063276A="include";
char*s1584_201970776A="force_to_integer_64";
char*s1585_396356A="create";
char*s2179_1023363018A=")=*C;\nse_deep_twin_register(((T0*)C),";
char*s2024_1089314041A="An external \"plug_in\" must be described with an alias clause. (Have a look in our standard library or in our tutorial for examples.)";
char*s1584_201970793A="force_to_integer_32";
char*s1830_2089269822A="The huge generic derivation related to the previous warning is: ";
char*s1584_756809447A="Minimum_real";
char*s2169_23647157A="/*empty*/";
char*s1586_234165132A="manifest_string_trace";
char*s1584_201970799A="force_to_integer_16";
char*s2122_15019A="_t T";
char*s1585_479922190A="c_compiler_path";
char*s2179_15020A="_t)(";
char*s1665_33475A="((se_";
char*s2015_1172758533A="There should be at most one export clause with the \"all\" keyword in each parent clause. The client lists will be merged, but please fix the export clauses.";
char*s2191_1912840703A="Keyword \"ensure\" replaced with \"ensure then\" because there is an inherited ensure assertion.";
char*s1665_1934139A="caller,";
char*s1892_1646268668A=" These two inherited features have the same name in type `";
char*s1665_8880A=",lsi";
char*s1661_8884A="-x c";
char*s2179_8885A=")\174""\174""(";
char*s2090_520647979A="The system is type safe.\n";
char*s1953_112006296A=" context.)";
char*s1661_8889A=".com";
char*s1665_941548611A="memcpy(sorted_all_profile+";
char*s2263_1637595774A="(eiffel_root_object);\nmanifest_string_mark1();\nonce_function_mark();\n";
char*s1583_8897A=".cpp";
char*s1652_45224899A="Keyword \"until\" expected (in a loop).";
char*s1660_1359484467A="(C) #(1) - #(2)";
char*s1665_162838175A="se_dump_stack*caller,";
char*s1584_30191860A="type_attribute_is_expanded";
char*s1665_2753A="]=\173""";
char*s1827_1251030042A="End of text expected (invalid ACE file).";
char*s2180_851596A=" a1tmp=";
char*s1665_900404594A="/* CECIL creation */\n\173""\n";
char*s1580_1525604536A="Only the flags -verbose, -version, -help and -relax are allowed in ACE\nfile mode.\n";
char*s1584_1673345408A="open_argument_count";
char*s1584_954385774A="Pointer_bits";
char*s1837_10926944A="prefix \"";
char*s1978_1666936074A=" must insert ";
char*s2375_1004947005A="g=o->_generation;\n";
char*s1956_2004103151A="Overflow of infix \"+\" with INTEGER_8 operands. (Adding ";
char*s1647_672350142A="\nassertion-level: ";
char*s2262_1517878904A="GC_gcollect();\nif(GC_should_invoke_finalizers())bdw_run_finalizers();\n";
char*s2020_946986142A=" type is not allowed as a variant type.)";
char*s2378_236525A="==1)\173""\n";
char*s1584_827429162A="type_item_generator";
char*s2262_1215237414A="#ifndef GC_DEBUG\n#define GC_DEBUG 1\n#endif\n";
char*s2378_2142119302A="* obj_ptr = (gc";
char*s2263_444775459A="\173""int i=SE_MAXID-1;\nwhile(i>=0)\173""\nif(t[i]!=NULL)gc_mark7(t[i]);\ni--;\175""\n\175""\n";
char*s1884_311661671A="No SEDB objects added.\n";
char*s1826_758913190A="Correct part: \"";
char*s2375_1020256883A=")bdw_weakref_new(*n);\n*R=M";
char*s1584_253393261A="for_object";
char*s1665_1040899642A="C Compiler options used: ";
char*s1826_319940936A=".... local unique buffer ....";
char*s1585_1509818A="General";
char*s1661_8976A=".exe";
char*s1653_1581369567A="Decimal CHARACTER code out of range.";
char*s1652_2137524537A="Inside an \"inspect\" statement for type STRING, the slice notation \"..\" is not allowed.";
char*s2263_1246644455A="gc_info();\n";
char*s1665_1136523103A="union _se_agent\173""T0 s0;se_agent0 u0;\n";
char*s1663_2833A="g++";
char*s1975_1529695024A="Invalid manifest equipment (must be greater than 1).";
char*s1892_556920526A=" is not a valid redefinition for ";
char*s1988_1026844627A="\" (check your ACE file).";
char*s2263_567426438A="u->gc_mark_agent_mold=gc_mark_";
char*s1661_8991A="/fe=";
char*s2179_2217200A="sizeof(";
char*s1956_1143055473A=" which is out of range 0..31 because target type is INTEGER_31.";
char*s1661_1331737400A="Local Loadpath";
char*s2038_76659A="agenT";
char*s1665_985140858A="])(void*,char*,int*,int*)";
char*s1827_961330339A="Cannot open \"";
char*s2180_177459204A="\n#if BYTE_ORDER == LITTLE_ENDIAN\n";
char*s1966_936707889A=" not found in type ";
char*s1668_612334905A="A frozen feature must not be redefined. What is frozen _is_ frozen.";
char*s1661_1431838787A="\" environment\nvariable whatever the kind of your operating system is.\nIf you prefer that way, set the \"";
char*s2378_52067A="=c;\n*";
char*s1959_1721243342A=" type cannot be used here. Actually this is only a compiler implementation facility.";
char*s1652_1207880883A=" Unable to parse definition of `";
char*s1665_400297641A="se_local_profile_t*parent_profile,";
char*s2179_4204001A="((void*)";
char*s1924_2870A="_P_";
char*s1665_1746979137A=",expression,/*unknown-position*/0);\n";
char*s1665_1591358844A="if(assertion_depth)\173""\nassertion_depth--;\n";
char*s1584_52347889A="mark_item";
char*s1584_76691A="agent";
char*s1659_1574136045A="Finished optimization (";
char*s1883_36115402A="All type marks used in a cecil file have to be static (no anchors).";
char*s1936_527180488A=" of this Unicode manifest string. ";
char*s1665_2883A="i++";
char*s1652_1910823336A="\" has been automatically replaced with \"";
char*s2378_618166083A="++;\n\175""\n\175""\nn->header.flag=FSOH_UNMARKED;\n";
char*s1584_1095772782A="collector_counter";
char*s1661_218174A="-s -d1";
char*s2179_907447617A=";\nif(o1==o2)\173""\175""\nelse if(NULL==o1)\173""R=0;\175""\nelse if(NULL==o2)\173""R=0;\175""\nelse \173""R=";
char*s1665_786180653A="se_frame_descriptor irfd=\173""\"<runtime init>\",0,0,\"\",1\175"";\nse_dump_stack ds = \173""NULL,NULL,0,NULL,NULL,0\175"";\nds.fd=&irfd;\n";
char*s2375_1871081731A=";\nif(na)for(i=0;i<c;i++)\173""\ne=na[i];if(e)na[i]=(T0*)HIDE_POINTER(e);\175""\n";
char*s2021_1057882626A="Expression of until must be of BOOLEAN type. (The actual ";
char*s1834_15195A="_ix_";
char*s1584_869539012A="sedb_breakpoint";
char*s2157_1728089446A="se_frame_descriptor se_ifd";
char*s2179_1671063525A="((uint64_t)(";
char*s1636_522142839A="Collecting Cecil features.\n";
char*s2375_15205A="o);\n";
char*s1665_54734511A="se_prinT[";
char*s2191_1691484858A="The export clause is ignored, the redefinition \"feature\" client list will be used instead.";
char*s2179_520377520A="((int32_t)(";
char*s1584_1574640467A="trace_switch";
char*s1661_9073A=".lib";
char*s2179_39831A=",NULL";
char*s2153_1971245A="closed_";
char*s1885_580435889A="Postcondition";
char*s1584_48958735A="deep_twin";
char*s1652_727272566A="Entity `Current\' is not writable. Cannot use `Current\' for the left-hand side of an assignment.";
char*s1655_1377150320A="\'. Maybe the program name is incorrect, or process execution is not yet supported on this platform.";
char*s1584_170256464A="FAST_ARRAY";
char*s1652_1953566687A="The type mark must be specified just after the \"Precursor\" keyword.";
char*s2191_81368369A="The client list computed from the \"export\" clauses is narrower than the one from";
char*s1840_624587783A="string_command_line";
char*s1673_2947A="fBC";
char*s1585_8054609A="Loadpath";
char*s1661_9107A=".lnk";
char*s2006_947318471A=" to define a constant.";
char*s1661_9121A=".obj";
char*s1924_181352A=" from ";
char*s2263_497096041A="gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));\n#ifdef FIXED_STACK_BOTTOM\nif (!stack_bottom) stack_bottom=((void**)(void*)(&argc));\n#endif\n";
char*s2545_387651299A=">, module_name <";
char*s2179_2118444283A="R=(C->id==a1->id);\nif(R)\173""\n";
char*s1665_9130A="=0;\n";
char*s2342_1182938696A="a_file_name";
char*s1661_2109537640A="...This is a local once buffer...";
char*s1583_2057783129A="Feature `deep_twin\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s2157_759184012A="rc.next = rescue_context_top;\nrescue_context_top = &rc;\n";
char*s1665_374291339A="char* se_atT[";
char*s1665_712350300A="init_profile(&atexit_profile, \"<atexit>\");\n";
char*s1661_415107A="lcclnk";
char*s1652_1775667520A="In an object-oriented language, the receiver of a call is always associated to some existing object (i.e. `Current\' is never Void). Hence, such a weird comparison is not allowed.";
char*s2179_2996A="_t)";
char*s2378_998144220A=".store=((rsoh*)(((char*)(";
char*s1665_1582839830A="qsort(sorted_all_profile, ";
char*s1584_180965424A="INTEGER_16";
char*s1924_732402575A=" (magic count = ";
char*s1584_180965430A="INTEGER_32";
char*s2262_1110320023A="void* bdw_ms[";
char*s1924_44462444A="c-type: T";
char*s1665_1281004126A="eiffel_root_object=((T";
char*s1665_1450568746A="/* Void call detected in back-end (function called: \173""";
char*s1652_188494264A="else of inspect";
char*s1665_1982839385A=");\n\175""\nva_end(pa);\nreturn ((T0*)C);\n";
char*s1584_11001014A="set_item";
char*s1584_180965447A="INTEGER_64";
char*s1652_167445550A="Inside a procedure, a Precursor call must be a procedure call (not a function call).";
char*s1584_10945665A="print_on";
char*s1665_3040A="ci(";
char*s2116_1757386798A="se_frame_descriptor gcd=\173""\"Garbage Collector at work.\\n\"\n\"dispose called (during sweep phase)\",0,0,\"\",1\175"";\nse_dump_stack ds = \173""NULL,NULL,0,NULL,NULL\175"";\nds.fd=&gcd;\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s1653_1708886163A="Invalid free operator (the last character must be a member of this +-*/\\=<>@#\174""& character list.).";
char*s1837_1661812564A="Internal Error";
char*s1827_2028436769A="The \"case_insensitive\" option is no longer supported.";
char*s1665_15351A="base";
char*s2191_214672950A="The \"feature\" clause declares a client list that";
char*s1584_2174354A="realloc";
char*s2157_1111279623A="void**locals[";
char*s2191_1961403182A=". This type should be marked as deferred.";
char*s2182_2117730851A="**)C)+atoi(attr));\n";
char*s1834_15370A="_px_";
char*s1668_69115705A="FEATURE_STAMPs total number = ";
char*s1661_9220A=".res";
char*s1663_3069A="ccc";
char*s1833_1492303331A=" is not generic.";
char*s1661_9222A=".scf";
char*s1652_723705127A="Dot expected here because a manifest-string alone is not an instruction.";
char*s1668_1008693261A="Assigner feature is not a command in type ";
char*s1827_3073A="all";
char*s1584_3075A="and";
char*s1652_1922694958A="Replaced misspelled \"Void\".";
char*s2378_33836A="* wr)";
char*s1827_817932306A=" without point of view!\n";
char*s1668_840703310A="\n\nSecond \"inherit\" path (from parent to child):\n   ";
char*s1585_3085A="bin";
char*s1585_51843716A="invariant";
char*s1665_1145546877A="...........................";
char*s1950_1896547075A="assignment attempt (\"\?=\").";
char*s2024_1014770470A=":\" not found";
char*s1661_3094A="dcc";
char*s2157_1125599189A="return((T0*)u);\n";
char*s1581_546820847A=". Bad flag ";
char*s1663_1663868A="OpenVMS";
char*s1586_89216A="split";
char*s2182_138425A="\")) \173""\n";
char*s2378_15405A="o->_";
char*s2022_384465A="basic_";
char*s1653_1923039443A="Underscore in number must group exactly 3 digits.";
char*s2263_1197879602A="gc_dispose_before_exit();\n";
char*s1584_1856946950A="Minimum_character_code";
char*s1584_39154229A="PROCEDURE";
char*s1652_370754643A="Bad external alias clause.";
char*s1652_188014584A="Replaced misspelled \"Current\".";
char*s1659_1066764899A="Void target Procedure/Function Call";
char*s2378_33875A=");\n\173""\n";
char*s1652_1502870799A="Bad empty character constant.";
char*s1665_1737592965A="*/: return 1;\n";
char*s1652_144939139A=" cannot be used just after agent keyword (it does not denote a feature call).";
char*s1652_1409701608A="No more class BIT since release 2.1. Just use bit operations from  INTEGER_8, INTEGER_16, INTEGER_32, INTEGER or INTEGER_64.";
char*s1652_1550836304A="Keyword \"class\" expected.";
char*s1901_1186844731A="Bad target type. The expected type is ";
char*s1927_30745830A="\' is out of INTEGER_32 range.";
char*s1975_1134247532A="Found two possible default creation procedures for expanded type ";
char*s1665_375072661A="char**se_argv";
char*s2375_1278999019A="GC_invoke_finalizers();\nhandle(SE_HANDLE_EXIT_GC,NULL);\175""\n";
char*s2300_849265556A=". Please check unicode charts.";
char*s1659_298390A="Done.\n";
char*s1652_734506354A="Opening \"<<\" of manifest generic creation expected.";
char*s1661_721564652A=" NoVersion NoIcons";
char*s1584_15448A="call";
char*s1932_3147A="cpp";
char*s2157_26975282A="(void*)&C";
char*s1652_822318035A="Replaced misspelled \"Result\".";
char*s1665_756717624A="Procedure without Current";
char*s1584_207673214A="force_to_real_64";
char*s1652_1926379486A="Ignored extra \",\".";
char*s2190_1901947715A="/*[INTERNAL_C_LOCAL list*/\n";
char*s2157_26975293A="(void**)&";
char*s2035_1329824754A="Using `Void\' as an item of a manifest TUPLE is not good practice because `Void\' has no accurate type. You can work around by using an extra non-initialized local variable of some accurate type. Another work around is to use an explicit creation of the TUPLE. As an example `create \173""TUPLE[STRING,ANY]\175"".make_2(Void,Void)\' can be used to create a TUPLE[STRING,ANY] with default values.";
char*s1827_2040665077A="Invalid collect value: must be either yes, no, or \"bdw\"";
char*s1665_1811657197A="se_frame_descriptor fd=\173""\"<atexit wrapper>\",0,0,\"\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=NULL;\nds.exception_origin=NULL;\nds.locals=NULL;\nds.depth=0;\n";
char*s1663_3169A="gcc";
char*s1584_207673231A="force_to_real_32";
char*s2174_3175A="if(";
char*s1586_2248290A="version";
char*s1585_3175A="end";
char*s2179_653639191A="The `deep_twin\'/`is_deep_equal\' problem comes from this attribute.";
char*s1668_938738041A="It is useless to undefine this deferred method.";
char*s2378_884381655A="*)o)->header.flag=FSOH_MARKED;\n";
char*s2263_3181A="elt";
char*s2263_156962A="(&(u->";
char*s2244_46245A=".secd";
char*s1653_1452518781A="Expected \"]\" (to finish generic argument list).";
char*s1659_689013605A="Expanded Target Function Call";
char*s1827_1389956963A="Please, also note that you can use the \"ace_check\" command\nto view all informations stored into your ACE file.\n";
char*s1665_36460172A="Defining ";
char*s1584_7095298A="FUNCTION";
char*s2026_3196A="get";
char*s1665_323348966A="se_general_trace_switch=(";
char*s1665_2101369329A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_profile+i);\n\175""\n";
char*s1584_280482649A="Boolean_bits";
char*s2378_244523906A="=o1;\n\175""\n\175""\nif (dead)\173""\ngc_free";
char*s2378_3209A="\173""\nT";
char*s2179_802840A="))))\174""((";
char*s2179_1679626025A="((real64_t)(";
char*s2157_3212A="u->";
char*s2035_2088401A="make_..";
char*s2174_602573626A="\173""int requireresult=1;\n";
char*s1895_97896378A=" into formal type ";
char*s1661_9366A=".txt";
char*s1652_1898638542A="Expression expected (\"inspect ... \").";
char*s1652_1460213717A="End of manifest array expected.";
char*s1653_92397395A="Closing \"\175""\" expected.";
char*s2172_7224500A="INT16_C(";
char*s2179_15533A="ceil";
char*s1652_1452100558A="No more DOUBLE type mark (update your code). This DOUBLE type mark is automatically replaced with REAL which is actually equivalent to REAL_64. Also consider to use REAL_32 or REAL_80 when you prefer. Also consider command pretty to replace automatically all DOUBLE with REAL.";
char*s1652_850458948A="Expression expected after the \"if\" keyword.";
char*s1584_421505A="method";
char*s1919_336696676A="\") this expression is the ";
char*s2296_2068836731A="Overlapping slices. (Wrong inspect statement.)";
char*s1652_1389575653A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure using the previous CHARACTER constant as the target).";
char*s2031_1088102843A="..........................";
char*s2174_4179775A=")->id)\173""\n";
char*s1668_2035830473A="\nFEATURE_STAMPs with rename  = ";
char*s1652_638895319A="Missing \')\' to end `c_inline_h\' call.";
char*s2172_40427625A="UINT16_C(";
char*s1885_770157670A="Loop_variant";
char*s2374_80501401A="Internal problem while searching for \"mark_item\".";
char*s1965_835850355A=".....         local unique buffer          .....";
char*s1659_498062040A="#(1)\nOriginal SmartEiffel code:\nCopyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE\nCopyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE\nD.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER, F.MERIZEN\n    http://smarteiffel.loria.fr\n";
char*s2090_651043570A="specializing one type";
char*s2157_1610470399A="\" is deferred in type ";
char*s2378_834589410A="*)o)->header.flag==FSOH_UNMARKED)\173""\n";
char*s2157_46337A="=(u->";
char*s1827_1811847991A="Non empty unquoted name expected here.";
char*s1665_660780608A="void se_prinT9(FILE* file, T9*o)";
char*s1584_7704337A="PLATFORM";
char*s1665_15589A="argc";
char*s2179_1206509635A="o1,o2);\175""\n\175""\n";
char*s1661_3291A="int";
char*s1661_1346168095A="Unable to find the compiler type of \"";
char*s1665_46350A="=1;\173""\n";
char*s1584_33120277A="CHARACTER";
char*s2263_38305571A="unsigned int rsoc_count_ceil";
char*s1661_3294A="lcc";
char*s1659_1255397791A="Will generate live type: ";
char*s1665_616198177A="switch(((se_agent0*)a)->creation_mold_id)\173""\n";
char*s1659_1928938448A=" formal generic arguments while the maximum allowed is ";
char*s1892_70962A="Type ";
char*s1665_960414291A="Agent call wrapper";
char*s1585_1072344038A="SmartEiffel";
char*s1652_1725672511A="Type mark expected after a colon mark inside a local variable list.";
char*s1665_2115332211A="\175""\nreturn 0;\n";
char*s1673_287218105A=".... unique buffer ....";
char*s1652_2008366323A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous CHARACTER constant as the target).";
char*s1659_1896793334A="\". This is not possible as this class is basically used by Liberty Eiffel internals. Please pick another name.";
char*s2179_83277A="isinf";
char*s1830_1897894366A="Expanded classes can be inserted only.";
char*s2025_1810101146A="Bad external \"C++\" definition.\nexternal \"";
char*s1661_3320A="man";
char*s1956_276773717A=" which is out of range -15..15 because target type is INTEGER_16.";
char*s2019_1050501857A="` in class ";
char*s2179_104084395A="((int8_t)(";
char*s2117_13424808A="\011""create \173""";
char*s2172_15629A="ddt1";
char*s1895_83290A="item_";
char*s2025_34086A="*)a1)";
char*s2180_105695965A=")+a3tmp,((";
char*s2191_58505493A="The Precursor routine is a deferred routine.";
char*s1652_147793411A="Void is not a valid BOOLEAN expression (just after keyword \"if\").";
char*s1585_1223234252A="debug_check";
char*s2006_221949868A=" Actually, feature ";
char*s1924_3337A="no ";
char*s1652_1297544492A="\" is not valid keyword.\"";
char*s2263_259021955A="s=new7();\n";
char*s2123_1500847347A="R = R \174""\174"" ((o1->_";
char*s1661_150382995A="\"[General] bin\" key is missing.";
char*s1835_360205908A="Too many live types (the maximum is ";
char*s1927_1731781A="Value `";
char*s1652_760340765A="Syntax error while trying to parse the header of routine `";
char*s2300_1398420907A=" Missing character number ";
char*s2180_129654140A=";\nmemcpy((";
char*s2297_89481A="state";
char*s1665_511465169A="Compiling routines for ";
char*s1919_240593583A="\" (i.e. when the type of Current is \"";
char*s1919_611824887A="In the context \"";
char*s2263_3374A="new";
char*s2031_192265186A="Cannot pass ";
char*s2179_83345A="isnan";
char*s1581_1102047298A="\" is not allowed when an ACE file (";
char*s1652_1109293176A="Void cannot be used after unary \"+\" operator.";
char*s1659_292482A="Class ";
char*s1584_698215697A="Maximum_real";
char*s1659_763853019A="\".\nToo long TUPLE (the TUPLE you want has ";
char*s2174_23451005A="/*i*/=0;\n";
char*s1665_3393A="lsv";
char*s1652_883016350A="Missing \",\" added.";
char*s1961_739187517A="Creation call on formal generic type (";
char*s1584_89510A="stdin";
char*s1584_1297876698A="is_not_null";
char*s1665_42279221A="Procedure";
char*s1652_1390190909A="An expanded class cannot inherit from other classes, it can only have an \"insert\" clause (replaced).";
char*s2174_2024156039A="/*[manifest INSPECT*/\n";
char*s2180_1062582514A=")-a3tmp+1)*sizeof(T";
char*s1827_1977886A="collect";
char*s1585_3415A="old";
char*s2211_22122412A=" because ";
char*s1663_15721A="dice";
char*s1584_3421A="not";
char*s1665_5164112A=", agent_profile, ";
char*s2179_1338608648A="R=se_deep_twin_search((void*)C);\nif(NULL==R)\173""\n";
char*s2375_1808489692A="(void*obj,void*_)";
char*s1665_3430A="\175"";\n";
char*s1652_2053250287A="\')\' expected to end arguments list.";
char*s2174_169510A="++;\n\175""\n";
char*s1665_1855175789A="se_profile_t atexit_profile";
char*s1661_759424351A=" is not supported as a C++ compiler. I will continue, but expect some problems.\n";
char*s1652_2060176323A="Expression expected.";
char*s2026_83406A="macro";
char*s1584_15751A="code";
char*s1656_1449185201A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
char*s1665_2123070311A=", agent_switch_profile, ";
char*s2378_1242450095A="if (size<=(";
char*s1652_239621812A="Bad create expression (\'\175""\' expected).";
char*s1665_3457A="orp";
char*s1833_1534075159A=" does not have ";
char*s1953_362752532A="Invalid comparison of expression ";
char*s1899_1742784741A="Feature found is not a procedure.";
char*s1919_1485100899A="..... unique buffer 2 .....";
char*s1652_95110222A="Added missing \")\"";
char*s1584_3460A="\174""<<";
char*s2263_1203674198A="#ifndef FIXED_STACK_BOTTOM\nif(!valid_stack_bottom) stack_bottom = (void**)(void*)&valid_stack_bottom;\n#endif\n";
char*s1661_1067454155A="Reading loadpath files\n";
char*s2378_46525A=">1)\173""\n";
char*s1584_3472A="\174"">>";
char*s1661_270309168A="Currently handled compiler names:\n";
char*s1584_3474A="pow";
char*s1665_3475A="se_";
char*s1665_2038260346A="else fprintf(SE_ERR, \"Cannot open profile.se for writing.\\n\");\n\175""\n";
char*s2545_10220290A="function";
char*s2172_3485A="vc(";
char*s1661_592781506A="Local Cluster";
char*s2179_1821634438A="(((se_agent*)C)->u0.eq==((se_agent*)a1)->u0.eq)&&(((se_agent*)C)->u0.eq((se_agent*)C,(se_agent*)a1))";
char*s2169_22854451A="/*:RF2*/)";
char*s1665_120095614A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_inv_profile+i);\n\175""\n";
char*s1584_1418282620A="INTEGER_GENERAL";
char*s2157_20240284A="),&(a2->c";
char*s1663_3494A="tcc";
char*s1665_325655889A="#define SE_SEDB 1\n";
char*s2026_3496A="set";
char*s1924_1317154036A="live id-field: ";
char*s1957_176211197A=" which is of type ";
char*s1584_3501A="put";
char*s1665_1572014572A=";\nwhile (i < imax) \173""\n";
char*s1919_1626899946A="inspectExpression";
char*s1652_46597328A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous `True\' constant as target).";
char*s1652_1631593164A="Void cannot be the left-hand side of the binary \"*\" operator.";
char*s2378_1973244310A="))+sizeof(rsoh);\nsize=((size+(sizeof(double)-1))&\176""(sizeof(double)-1));\n";
char*s2378_1173325215A="void gc_update_weak_ref_item";
char*s1670_253892190A="exceptions";
char*s2379_27492334A="*sizeof(T";
char*s2033_1387816739A="Cannot rename feature `c_inline_h\' because this name is used as a keyword to handle the corresponding \"built_in\" feature of ANY.";
char*s2379_136857117A=",(unsigned long)(";
char*s2156_1199805276A="fprintf(file,\"\\n\\t[ \");\n";
char*s1957_256961544A="The left-hand side of an assignment attempt must not be expanded. (Actually, the left-hand side is of type ";
char*s1668_1129671576A="Assigned feature is not a query in type";
char*s1641_3520A="ti_";
char*s1661_15828A="cpml";
char*s2378_1058430701A="o1->header.next=gc_free";
char*s1665_1728206941A="((/*UT*/(void)(";
char*s1584_15831A="copy";
char*s2006_1606367935A="Using a static constant expression just after the \"is\" keyword is suitable only for a constant attribute definition. The constant found (i.e. ";
char*s1584_1947246A="bit_set";
char*s1580_1767481079A="precompile_header";
char*s1659_1225577982A="Reference Target Monomorphic Procedure Call";
char*s1652_1522646678A="Missing \'(\' after `c_inline_c\'.";
char*s1584_1947251A="bit_put";
char*s2263_1713875121A="GC support: generating header.\n";
char*s1585_77350A="alias";
char*s1652_1931146896A="Bad procedure definition.";
char*s1978_1379248421A="Formal generic name appears twice in formal generic list (VCFG.2).";
char*s1652_201048978A=" cannot be used just after agent keyword. The type of the target must be given. Consider using the curly braces notation, e.g. `\173""TARGET_TYPE\175""\'.";
char*s2338_789213750A=" (kept)\nRedundant definition ";
char*s2379_692716864A=".space_used);\n";
char*s2172_4622950A="/*NAI*/(";
char*s2182_646768902A=";\n\173""\nstatic ";
char*s1652_1167481808A=" digits). You must use exactely 2, 4, 8 or 16 digits only. A 2 digits value denote an INTEGER_8, a 4 digits value denote an INTEGER_16, a 8 digits value denote an INTEGER_32, and, finally, a 16 digits value denote an INTEGER_64. (See examples in file \"SmartEiffel/tutorial/hexadecimal.e\".)";
char*s2241_1499315956A="No split enabled.\n";
char*s1641_1462938943A="NATIVE_ARRAY[NATIVE_ARRAY[...]] is not currently supported by the introspection system.";
char*s2114_3557A="tmp";
char*s1665_1965730A="break;\n";
char*s1653_176469602A="In extended form of manifest string. Bad character before \'%\'.";
char*s1827_2100317873A="Unquoted filenames are deprecated. Please add quotes here.";
char*s2374_936093505A="native_array_collector_tag";
char*s2298_858562A=" _NULL ";
char*s2172_23186700A="/*NVND*/(";
char*s2261_28273584A=",sizeof(T";
char*s1665_357794960A="T0* se_manifest";
char*s1652_161325869A="Empty manifest array is not a valid notation. If you want to create an empty ARRAY, just use an ordinary creation call of class ARRAY.";
char*s2179_304601115A="signal_exception_number";
char*s1585_3595A="sys";
char*s2025_852437A="*)a1)->";
char*s1665_77412A="case ";
char*s1585_3601A="use";
char*s1647_1229059519A="Bad root procedure name (\"";
char*s1665_726227573A="*sizeof(se_profile_t));\nqsort(sorted_profile, ";
char*s1665_434116584A="*sizeof(se_profile_t));\nqsort(sorted_agent_profile, ";
char*s2263_15915A="if((";
char*s1652_1061217192A="Classes with an external type must be expanded or deferred.";
char*s2261_1193180751A="s=((T7*)se_malloc(sizeof(T7)));\n";
char*s1645_1554312113A=".... local buffer ....";
char*s1584_279523519A="to_pointer";
char*s1827_551231644A="Multiple ACE files in the command line: \"";
char*s1647_620670284A="\nparent-count: ";
char*s2090_965507650A="inlining dynamic dispatch";
char*s1665_1065652086A="\173""\nFILE *profile_file = fopen(\"profile.se\", \"w\");\nif (profile_file!=NULL) \173""\nint i;\nse_profile_t sorted_profile[";
char*s2263_1549077634A="handle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s2174_206626A=";\nelse";
char*s1827_3645A="yes";
char*s2181_54686040A="return ((";
char*s1581_1009954795A="\". Must not use Eiffel source file suffix with option \"-o <executable_name>\".";
char*s2262_1527912055A="GC_disable();\n";
char*s1665_1723513855A="stop_profile(parent_profile, &local_profile);\n";
char*s1585_89771A="trace";
char*s2263_961294240A="if(!gc_is_off && !garbage_delayed())\173""\n";
char*s1659_2106290588A="Exponent of infix \"^\" must be a positive INTEGER. Exponent actual value is \"";
char*s1652_1522646803A="Missing \'(\' after `c_inline_h\'.";
char*s1584_577213499A="is_not_a_number";
char*s2157_1115628985A="handle(SE_HANDLE_EXCEPTION_SET,NULL);if(SETJMP(rc.jb)!=0)\173""/*rescue*/\n";
char*s1652_375534514A="Bad creation instruction (type or \'!\' expected).";
char*s1584_3669A="xor";
char*s2190_1750246116A="Declared INTERNAL_C_LOCAL: ";
char*s2156_1199620901A="fprintf(file,\"\\n\\t  \");\n";
char*s1584_911175911A="internals_from_generating_type";
char*s2174_1631421108A="/*storage*/=((";
char*s2545_28287A="\" at ";
char*s1827_261396584A="The value of the environment variable \"SmartEiffel\" is:\n\"";
char*s1584_169371474A="DISPOSABLE";
char*s1835_1539722017A=" correct items).\n";
char*s1585_16001A="else";
char*s1665_395316170A=" */\nif (expression == NULL) return 1;\n";
char*s1584_1947419A="bit_xor";
char*s1665_1565125654A="];\nse_profile_t sorted_inv_profile[";
char*s2003_1087076085A="Double definition of feature ";
char*s1961_581709925A=" is not in the creation list of type ";
char*s2263_89821A="store";
char*s1665_1773201687A="\n#ifdef __cplusplus\n\175""\n#endif\n";
char*s1647_1914699291A="Wrong number of generic argument";
char*s1668_429361964A="Can\'t join these two concrete features. What\'s called a concrete feature here is a feature which is not deferred. You may consider to undefine one feature. May be.";
char*s1652_1453066751A="Must use exactly 16 hexadecimal digits for INTEGER_64.";
char*s1665_56845112A="volatile ";
char*s1974_1288915017A="... unique buffer ...";
char*s1956_1469170081A="Overflow of infix \"*\" with INTEGER_64 operands. (";
char*s2354_1635136368A="\" (resolved as \"";
char*s1585_937397683A="The $ operator must be followed by the final name of a feature which is not a constant attribute or by the name of some local variable as well.";
char*s1892_1524252299A=". Signature of the redefined feature is not valid.";
char*s1885_560316788A="No_more_memory";
char*s1584_2218105A="rounded";
char*s1661_89862A="strip";
char*s1835_411001267A=" in any cluster. Don\'t expect the compilation to succeed.\n";
char*s1957_1933023161A=".) Invalid assignment test.";
char*s1955_1140411454A="The declaration type of this expression is ";
char*s1584_203589551A="manifest_initialize";
char*s2179_9905A="C->_";
char*s2179_34510A="))\174""\174""(";
char*s2174_3760A="\175""\175""\n";
char*s1647_510352234A="A class cannot be expanded and deferred (VTEC.1).";
char*s1950_1128496981A=" can be assigned into ";
char*s1652_407741255A="_inline_agent";
char*s1665_22971612A="];\nmemcpy(sorted_profile, profile, ";
char*s2297_560556710A="\") in the same inspect.";
char*s1956_944882A=" times ";
char*s2179_437573617A="((T6)((C->id==a1->id)\?!memcmp(C,a1,sizeof(*C)):0))";
char*s1665_1316373138A="/*se_evobt*/";
char*s2179_2030510390A=",C->_capacity);\n";
char*s1659_956422775A="Simplify done";
char*s1966_1931700734A="Here is the corresponding feature definition (not an attribute).";
char*s2198_638047023A="Call on a Void target in the live code (when the type of Current is ";
char*s1827_1737556726A=". The first one is in the cluster \"";
char*s1584_275488632A="Maximum_double";
char*s1827_2044479327A="\nEiffel class file searching is being done according to the ACE file \"";
char*s1586_77608A="cecil";
char*s2179_9980719A="if(R)R=r";
char*s1674_113009969A=" in file \"";
char*s1665_122027336A="init_profile(&prof, \"se_msi";
char*s1585_2593373A="cpp_linker_options";
char*s2015_907165587A=" appears at least twice. The client lists will be merged, but please fix the export clauses.";
char*s2183_2187411A="se_atT[";
char*s2545_1760616840A="Could not load the plugin; one dependancy is not satisfied: location <";
char*s1827_1799491166A="\" in any known cluster.";
char*s1988_892969089A="   default assertion (";
char*s1659_1194472660A="Reference Target Monomorphic Function Call";
char*s1652_1943393816A="Argument name ";
char*s2025_9808515A="delete((";
char*s2338_65332A="] in ";
char*s2157_2187432A="return ";
char*s2262_357653724A=")GC_call_with_alloc_lock((GC_fn_type)bdw_weakref_getlink,(bdw_Twr*)(";
char*s2298_16139A="il2@";
char*s1653_372047073A="Deleted extra separator.";
char*s2211_1864907075A="To many actual arguments for agent call. (The agent you are trying to call has no arguments.)";
char*s1584_440571A="target";
char*s1652_2082787810A="Error while reading a real. Missing \"\175""\" \?";
char*s1659_388205767A="Total Number of \"inspect\" used for Dynamic dispatch: ";
char*s1584_1604522960A="to_integer_8";
char*s2375_888029880A="c=o->_capacity;\n";
char*s1837_2064444A="infix \"";
char*s1584_2187464A="se_argc";
char*s1665_697705640A="sorted_all_profile[";
char*s1835_188525860A="Corrupted *.id file (after ";
char*s1585_49076540A="assertion";
char*s1825_1587749191A="Aliased STRINGs: ";
char*s1661_143937264A="-subsystem";
char*s1827_452889A="system";
char*s1665_1450791030A="[hc]\" not found).";
char*s2380_1411018665A=".store_left=0;\n\175""\n";
char*s1975_2134616155A=" is expanded).";
char*s1953_333554149A="Such a weird comparison with Void is not allowed because it would be always ";
char*s1665_397592212A="\",1\175"";\nse_dump_stack ds;\n";
char*s1586_16177A="help";
char*s1953_461679483A="Cannot compare an expanded expression with a reference expression.";
char*s1584_2187483A="se_argv";
char*s2180_1502256459A="]),&a1tmp,sizeof(T";
char*s2155_11241768A="struct S";
char*s1585_59251A="False";
char*s1837_1224218969A="The source lines involved by the message are the following:\n\n";
char*s2378_54686284A="return((T";
char*s1837_1750778A="Warning";
char*s1660_2107398012A="\nLiberty Eiffel The GNU Eiffel Compiler, Eiffel tools and libraries\n    release #(1)\n\nCopyright (C), #(2) - #(3)\n    http://www.liberty-eiffel.org\n";
char*s1655_745978733A="\' is defined more than once";
char*s2378_384078512A="\173""rsoh*h=((rsoh*)o)-1;\nif((h->header.magic_flag)==RSOH_UNMARKED)\173""\nh->header.magic_flag=RSOH_MARKED;\n\173""\n";
char*s2211_191115496A=". Its type is ";
char*s1665_522691310A="ds.caller=NULL;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s1658_1442714837A="Assignment graph: ";
char*s1661_1056930268A="You can also have a look at http://liberty-eiffel.blogspot.com/wiki/index.php/";
char*s2180_2187545A="se_die(";
char*s1652_1687580001A="Void is not a valid expression inside \"when\" part of an inspect statement.";
char*s1652_1301660112A="Bad formal arguments list.";
char*s2040_455005721A="Same type appears more than once.";
char*s1665_1136118256A="............ unique buffer ...........";
char*s2021_779913846A="Error in until part of loop definition.";
char*s1923_389128515A=" Cannot assign Void into ";
char*s2191_7440512A="Feature ";
char*s2179_77767A="ceilf";
char*s1665_2060090728A="fprintf(file, \"NATIVE_ARRAY[CHARACTER]#%p\\n\",(void*)*o);";
char*s1827_641030424A="Non empty quoted string expected here.";
char*s2179_77773A="ceill";
char*s2378_1869083728A="void gc_update_weak_ref_item_polymorph(Tgc* item)";
char*s1585_16264A="from";
char*s1585_9790205A="deferred";
char*s2122_1476287022A="typedef T0 T";
char*s2375_646707803A=")se_malloc((*n)*sizeof(T";
char*s1665_984785217A="/* Allocate an Eiffel STRING by copying C char*e (must be a well-formed C string with terminal \\0) */\nint c=strlen(e);\n";
char*s1652_99041221A="\' instead.";
char*s2172_7225250A="INT32_C(";
char*s2172_2187584A="se_cmp1";
char*s2172_2187585A="se_cmp2";
char*s1585_265093627A="loop_check";
char*s1665_1234811086A="memcpy(sorted_all_profile, profile, ";
char*s1955_435568604A="\"if\" (or \"elseif\" as well) must be followed by a BOOLEAN expression.";
char*s1583_635943583A="Feature `is_deep_equal\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s1653_175744216A="Added \"(\".";
char*s1665_700572143A="init_profile(inv_profile+";
char*s1584_1223936132A="deep_memcmp";
char*s2172_40428375A="UINT32_C(";
char*s1885_1207039342A="Void_attached_to_expanded";
char*s1956_511502716A="Cannot divide ";
char*s1584_37186806A="NATURAL_8";
char*s2354_1847764413A="Cycle detected:\n";
char*s2157_2187619A="se_cmpT";
char*s2174_809795A="((T0*)(";
char*s1924_4488096A=" feature";
char*s2157_208313786A="ds.caller=caller;\n";
char*s1653_175744241A="Added \")\".";
char*s1584_77832A="blank";
char*s1827_1667312535A="Cluster path expected after cluster name.";
char*s1827_90141A="wedit";
char*s1944_1814961148A="Unused local variable.";
char*s2006_161769183A=") cannot be used as the definition of the feature ";
char*s1921_432936020A="Cannot find Base Class for ";
char*s1665_889346373A="global_profile=local_profile;\n";
char*s1665_4980205A=",NULL);\n";
char*s1652_872019014A=" or the whole expression as well. It\'s up to you to decide now.";
char*s1668_7612837A="In type ";
char*s1885_41769343A="Os_signal";
char*s1827_1984169029A="Cannot find the class \"";
char*s1652_1476889913A="Empty list not allowed for manifest generic creation.";
char*s2263_2039472678A="stack_bottom=((void**)(void*)(&argc));\n";
char*s2117_26108906A="Unknown feature name ";
char*s1584_65574A="TUPLE";
char*s1665_136593176A="s->_count=c;\ns->_capacity=c+1;\ns->_storage_lower=0;\ns->_storage=((T9)";
char*s1584_197002151A="force_to_natural_64";
char*s2174_440120430A=")->_storage_lower;\n";
char*s2263_533301931A="void(*gc_mark_agent_mold)(se_agent*);\n";
char*s2180_388821092A="Class NATIVE_ARRAY has been tampered with. Unknown procedure: ";
char*s1652_1160088831A="\" cannot be a valid class name (only upper case letters are allowed in class names). \"";
char*s1652_902126A=" first.";
char*s2174_2089246593A="if(requireresult)\173""\n";
char*s2179_234855416A="_t)(((uint";
char*s2378_2051940780A="\173""\173""FSOC_SIZE,FSO_STORE_CHUNK,\n(void(*)(mch*,void*))gc_align_mark";
char*s1584_550709268A="NATIVE_ARRAY_COLLECTOR";
char*s1665_253935823A="];\nse_profile_t sorted_agent_profile[";
char*s1647_1468715266A=". This creation call is thus not allowed.";
char*s1584_197002168A="force_to_natural_32";
char*s1652_732932648A="Load class \"";
char*s2157_657822788A="ds.fd=&se_ifd";
char*s2174_2353775A="\175""else\173""\n";
char*s1653_1836169859A="Unexpected character in hexadecimal unicode.";
char*s1585_434665A="option";
char*s1653_175744316A="Added \",\".";
char*s1966_626532654A="This feature name is not an expression (no result and not writable).";
char*s1584_197002174A="force_to_natural_16";
char*s2025_397949195A="\"\n_________";
char*s1952_1543474532A="Actually, `Void\' has no accurate type. Keep in mind that `Void\' is just a way to denote the default value for a type or to denote the lack of an object. One can use `Void\' as the left-hand-side of an assignment or to replace some actual argument. (See \"http://liberty-eiffel.blogspot.com/wiki/en/index.php/Void\" for details.) At time being, the type ANY will be used for this occurrence `Void\'. Please update your code with a more accurate expression, may be by adding an extra non-initialized local variable.";
char*s1665_1099040180A="(&local_profile);\n";
char*s1827_1805205737A="Files are being searched for in the following list of clusters (";
char*s1584_573080478A="raise_exception";
char*s1953_2089449608A="An expanded value can be compared only with the same other expanded value. Expression ";
char*s2300_1139569132A="Invalid byte in UTF-8 sequence. This character is  number ";
char*s1661_1832417772A="Bad use of command `";
char*s2180_84085A="\174""(1<<";
char*s1652_1732402521A="Instruction expected.";
char*s2376_742356016A="typedef struct B";
char*s2174_47187A="==0) ";
char*s2153_1152812249A="/* Extra external prototype for line ";
char*s1668_1248054333A="Add undefine or redefine to all inherited version of feature ";
char*s1584_53339A="ARRAY";
char*s1581_1335263213A=": missing file name after -cecil flag.\n";
char*s2263_1085305030A="gc_align_mark";
char*s1835_838840612A="Previous IDs reloaded (max_id = ";
char*s1658_1616517694A="destination-graph-nodes: ";
char*s2122_1476281050A="typedef uint";
char*s2123_742356033A="typedef struct S";
char*s2375_1456062714A=",NULL,NULL,NULL);\no->bdw_markna=(void*)HIDE_POINTER(markna);\n*markna=(T0*)o;\nGC_GENERAL_REGISTER_DISAPPEARING_LINK(&(o->bdw_markna),markna);\nbdw_in_assign=0;\nGC_enable();\nif(bdw_delayed_finalize)\173""\nbdw_delayed_finalize=0;\nreturn NULL;\175""\175""\nreturn o;\n";
char*s1584_49076823A="clear_all";
char*s1665_1858528797A="\n(fprintf(SE_ERR,\"%s\\n\",";
char*s2157_1949908058A="*u=(void*)new_agent(";
char*s1665_10940631A="se_evobt";
char*s2261_870210728A="fprintf(SE_ERR,\"No GC compiled in, no information available\\n\");\n";
char*s1659_218672210A=".............. once unique buffer ......................";
char*s1988_397660162A="   exclude ";
char*s1581_375350487A=": the \"-case_insensitive\" flag is no longer supported.\n";
char*s1661_1361085152A="@linkit.com\ndelete linkit.com;";
char*s2263_1403828457A="store_chunk";
char*s2029_1610077639A=" open operand expression is out of \"agent\" keyword scope.";
char*s1665_16487A="int ";
char*s1652_398318341A="\' does not fit on INTEGER_64).";
char*s1895_731327330A="Agent calls need a tuple!";
char*s1653_595894613A="Unexpected character in decimal ascii code.";
char*s1652_1174611449A="Separator expected to end hexadecimal constant.";
char*s2297_2027238465A="Only manifest strings are accepted in \"when\" clauses of \"inspect\" (in order to ensure that the STRING won\'t change at runtime). Note that even a constant of type STRING can have its content changed at runtime.";
char*s2375_718028873A="int i,c,g;T0*e;T0**na;T";
char*s1585_78002A="check";
char*s1919_165601417A="CHARACTER ";
char*s2300_1927020241A="Invalid unicode value: 0x";
char*s1892_1246984134A=") this type mark is resolved as ";
char*s2262_1062817045A="GC support (root functions).\n";
char*s2174_16510A="\175""\n\175""\n";
char*s1584_1202672333A="with_capacity";
char*s1652_897447412A="Cannot use ";
char*s1661_19761224A=" Data=Far";
char*s1665_1201497496A="*C;\nva_list pa;\nint i=0;\nint imax;\nva_start(pa,argc);\nC=";
char*s2354_1959331451A="Empty loadpath: \"";
char*s2378_1990989A="if(((gc";
char*s1652_521861207A="The convert support is EXPERIMENTAL (work in progress).";
char*s1665_5367889A="*eiffel_root_object";
char*s1652_586311386A="Bad creation instruction (\'!\' expected).";
char*s2157_422487A="locexp";
char*s1665_47278A="==0)\173""";
char*s1652_1093012317A="Second identifier of a \"rename\" pair expected.";
char*s2182_41131A=";\n_r=";
char*s1652_1437345301A="Syntax error while trying to parse the beginning of a new feature definition. Feature name expected. Class name ";
char*s2545_2072196164A="The default key \"function\" was not found. Invalid auto_init file.";
char*s1584_1744612358A="is_basic_expanded_type";
char*s1652_1759774576A="You are probably trying to use the new inherit/insert mechanism. With Liberty Eiffel, this can be achieved thanks to the new \"insert\" clause. The new \"insert\" clause comes just after the traditional \"inherit\" clause with a similar syntax.";
char*s1997_1118729658A="When the context of the validation is ";
char*s1665_2096892436A="p[0]=\"\?\?\?\";\n";
char*s2182_1659544035A=");\nR=&_r;\n\175""\n";
char*s1652_4235A=" \011""\000""\n";
char*s1659_1610926534A="Void target Procedure Call";
char*s1652_1154110220A="Cannot use anchored type mark definition as a valid parent.";
char*s1826_956361723A="Remainder: \"";
char*s1665_1110850242A="fprintf(profile_file, \"\\n===============================================================================\\n\");\n";
char*s1665_1377391529A="Executable is up-to-date (no C compilation, no linking done).\n";
char*s2179_884813300A=";\nT0*o2=a1ptr->_";
char*s2179_4881995A="->id)==(";
char*s1665_1197714671A="(T0* expression)";
char*s2174_840791A="((void)";
char*s1653_543076045A="Type mark expected.";
char*s2263_280766651A="store_left";
char*s1655_42698349A="The key \'";
char*s2244_928596125A="\" not changed.\n";
char*s1665_246893097A="v=ac_lvc(c++,v,";
char*s1665_1911279888A=")));\nC[i]=element;\ni++;\n\175""\nva_end(pa);\nreturn C;\n";
char*s1660_346563905A="2013.09 (Charles Adler, Jr.)";
char*s1950_332834879A="forced assignment (\"::=\").";
char*s1924_78082A="dead ";
char*s1661_1223801083A="Selecting C++ compiler: ";
char*s1957_1907958363A=". (This assignment test is always True.)";
char*s2031_94643563A=" is deferred. (Cannot create object.)";
char*s2179_17743770A=")\n#endif\n";
char*s1665_1964848975A="start_sumup_profile(profile_file);\ni=";
char*s2375_871385705A="GC_dump();\n";
char*s1652_688657949A="Empty \"when\" clause in \"inspect\" statement.";
char*s1585_90408A="until";
char*s2378_1314337673A=".store_left))\173""\nrsoh*r=";
char*s1653_1242149539A="Right hand side expression of := assignment expected here.";
char*s1584_7748406A="REAL_128";
char*s2074_840796792A="Empty manifest array not allowed. (If you really need to do it, just replace it with something like:\ncreate \173""ARRAY[ANY]\175"".make(1, 0)";
char*s1885_198146473A="Class_invariant";
char*s1652_126038302A="Writable entity expected here (`Current\' is not writable).";
char*s1584_16616A="last";
char*s1661_2121681051A="Unknown C++ compiler type \"";
char*s2172_36122993A="INT16_MIN";
char*s2375_182705A="0*));\n";
char*s1956_1718483009A="Overflow for opposite of Minimum_integer_8.";
char*s1585_16630A="jobs";
char*s1652_494839979A="Empty argument list (deleted).";
char*s1655_1784452489A="Could not execute \'";
char*s1585_10208843A="external";
char*s1585_56255230A="undefined";
char*s1661_725963810A="\". Please fix your configuration file or choose another C mode.";
char*s1584_16639A="item";
char*s1584_78150A="atan2";
char*s1652_2016523575A="In compound (";
char*s1997_1888871872A="TUPLE type expected for open arguments of agent type. (See also the next fatal error message.)";
char*s1585_1730514379A="cpp_compiler_options";
char*s2048_1879799154A="Must not use old inside some old expression (VAOL.2).";
char*s2174_1553642381A="default: error1(\"Invalid ::= assignment (inserted type).\",";
char*s2222_1166590709A="Deferred feature must not have rescue compound.";
char*s2378_1396798042A=".store_left-=size;\nif(";
char*s1584_705019679A="die_with_code";
char*s1584_1339128A="BOOLEAN";
char*s1584_451899881A="type_attribute_name";
char*s1663_59731A="Elate";
char*s2088_2014364610A="run-time-set:\n";
char*s1661_39204698A="SCOPTIONS";
char*s1661_61342149A="No information available about the system used (check your\nLiberty Eiffel installation).\n";
char*s1652_768172015A="Hexadecimal digit expected while reading CHARACTER constant.";
char*s2024_1979303915A="\":\" expected";
char*s2179_17743865A=")\n#else\n(";
char*s1895_416499A="item_1";
char*s1653_1226144723A="Variable `Result\' is valid only inside a function.";
char*s1895_416500A="item_2";
char*s1919_61858840A=" which is not allowed.)";
char*s1584_16686A="make";
char*s2378_1279738389A="++;\n\175""\nelse\173""\nc=gc_fsoc_get1();\nif(";
char*s1913_881547256A="Cannot use here a manifest STRING because the previous one used in this \"inspect\" statement is not a manifest STRING.";
char*s1586_385751A="c_mode";
char*s2379_666336072A=")\nfprintf(SE_GCINFO,\"%d\\t%lu\\t%d\\t";
char*s2379_41300A=";\nif(";
char*s2243_355003A="][0-9]";
char*s2298_78209A="ddt1@";
char*s2375_1037766A="(int n)";
char*s1665_561301605A="*/: error2(expression,/*unknown-position*/0);break;\n";
char*s1665_988839165A="se_frame_descriptor root=\173""\"<system root>\",1,0,\"";
char*s1927_31214580A="\' is out of INTEGER_16 range.";
char*s2179_106047655A="),a1ptr->_";
char*s1827_2085574777A="external_lib";
char*s1661_84381A="mieee";
char*s1827_416541A="legacy";
char*s2174_4425A="\nif(";
char*s2156_1511378937A="fprintf(file,\"#%p\",(void*)*o);\n";
char*s1584_90544A="upper";
char*s1665_280139425A="uint16_t s";
char*s1950_29037A=" ::= ";
char*s2300_888288799A="Overlong sequence, must be refused by any UTF-8 complient decoder for security reasons.";
char*s1585_427898753A="# Beginning of parallelizable section";
char*s2174_847125A=");\nif (";
char*s2179_111269879A="R=se_deep_equal_search(C,a1);\n";
char*s1923_1881300092A="Assignment of a reference type into an expanded type is not allowed. ";
char*s1892_2084824380A=" (More explaination below.)";
char*s1826_988261007A="Bad external signature (missing opening \"(\" delimiter.";
char*s1665_1240218271A="se_argc=argc;\nse_argv=argv;\n";
char*s1653_175744666A="Added \":\".";
char*s2245_1085938891A="By-type splitter enabled.\n";
char*s2091_32450971A="C:\\SE.CFG";
char*s2172_920950A="/*IC*/(";
char*s1585_78263A="debug";
char*s2174_958274895A="!=NULL)\173""error1(\"Invalid ::= assignment (inserted type).\",";
char*s2180_804085A="&(\176""(1<<";
char*s1665_561947515A=" element=((";
char*s1585_16761A="like";
char*s2296_786403659A="Internal error inside WHEN_ITEM_2 (compiler error).";
char*s1652_1559455194A="Expression \"old\" can be used in ensure clause only (VAOL.1).";
char*s1665_21391495A=",((void)(";
char*s1653_175744691A="Added \";\".";
char*s1652_1421961899A="The basic = operator cannot be redefined. (This is a hard-coded builtin that we must trust.)";
char*s1906_1479430694A="This call has no result.";
char*s1988_597973944A="Could not load class in cluster ";
char*s1665_16782A="link";
char*s1585_84443A="local";
char*s2237_161074567A="<Universe>";
char*s1961_182862A=" into ";
char*s1659_1914558593A="The root class must not be expanded (sorry, but this is a limitation of the compiler).";
char*s1659_1450022771A="Unknown feature `";
char*s2157_430519127A="ds.locals=locals;\n";
char*s1652_611217054A="Error in constant or manifest creation.";
char*s1950_138555764A=" by using an ordinary \":=\" assignment ";
char*s1661_1615398571A="..................................";
char*s2323_1400894751A="... once unique buffer ..................................";
char*s1656_1880881887A="................";
char*s2300_263008962A=" bytes sequence.";
char*s1584_839855894A="TEXT_FILE_WRITE";
char*s1652_1075925125A="Must not use local variable in ensure assertions (VEEN).";
char*s1652_488830629A="Void cannot be the left-hand side of infix operator \"";
char*s1892_2050169721A="In the parent context (i.e in ";
char*s2179_1174230416A="_t)((((uint";
char*s1659_1661328107A=". Yours is in the cluster \"";
char*s1584_2126626A="or else";
char*s1665_179423058A="if(ds.fd->assertion_flag)\173""\nds.fd->assertion_flag=0;\n";
char*s1659_42846255A="No such TUPLE definition in file \"";
char*s1950_1816745449A="::= assignment (a forced assignment).";
char*s2024_56907446A="type_name";
char*s2263_614557109A="/*NON_VOID_NO_DISPATCH:*/\n";
char*s2024_10559665A="location";
char*s2123_1208522276A="typedef int T";
char*s2263_1215177661A="\173""int i=SE_MAXID-1;\nwhile(i>=0)\173""\nif(g[i]!=NULL)gc_mark7(g[i]);\ni--;\175""\n\175""\n";
char*s1668_576322499A=" cannot be an assigner of the feature ";
char*s1956_1592935176A=" which is out of range 0..7 because target type is INTEGER_8.";
char*s1584_324411A="STRING";
char*s1584_1739790308A="type_generator";
char*s1647_15142174A="Bad root class (this class has no creation clause).";
char*s1665_1483072174A="T0*se_string(char*e)";
char*s2179_195246A="->id))";
char*s2123_1502207936A="R = R \174""\174"" se_cmpT";
char*s2247_1345295929A="Multiple rename for the same feature is not allowed.";
char*s1661_149455415A="Unknown compiler type \"";
char*s2179_1605175681A="se_deep_twin_start();\n";
char*s1659_22271191A=" argument";
char*s2006_375578482A="Value out of INTEGER_8 range.";
char*s2157_948421114A=";\nds.current=((void*)&C);\n";
char*s2157_35330A=" afp_";
char*s1668_784841421A="Unable to solve cyclic anchored types.";
char*s1652_107634778A="Because of the usual low priority of prefix minus, `-foo.bar\' is actually equivalent to `-(foo.bar)\'. In order to avoid a possible mistake here, it is mandatory for you to add extra parentheses here. You can wrap ";
char*s1956_350193314A="Overflow of infix \"-\" with INTEGER_64 operands. (";
char*s2263_269141588A="\173""/*mark_item*/\n";
char*s1655_1043946153A="Unexpected text continuation";
char*s1661_1515266530A="You must choose either -cc or -c_mode, but you cannot use them both.";
char*s1665_1065942137A="print_profile(profile_file, &root_profile);\n";
char*s1652_104977558A="Inline agent or expression expected after agent keyword.";
char*s1674_1662662954A="SmallEiffelDirectory";
char*s1953_401707956A=" is obviously expanded (i.e. the written type mark is \"";
char*s2025_16902A="new ";
char*s1975_1878889060A="Feature `manifest_make\' must have at least one INTEGER argument.";
char*s1665_18131599A="se_dump_stack*,";
char*s2091_1185594A="/sys/rc";
char*s2378_784300160A=";\no2=o1+c->count_minus_one;\nfor(;o1<=o2;o1++)\173""\nif((o1->header.flag)==FSOH_MARKED)\173""\no1->header.flag=FSOH_UNMARKED;\n";
char*s1665_355630820A="/* Allocate a Manifest STRING given its length and chars array.*/\n";
char*s2375_1812279886A="void*result=GC_MALLOC_ATOMIC(n*sizeof(bdw_Twr));\nse_check_malloc(result);\nreturn result;\n";
char*s2262_157328735A="GC_enable();\ngc_start();\n";
char*s1584_243411981A="bit_rotate";
char*s1584_1419919903A="Maximum_character_code";
char*s1652_2102385657A="Empty Cecil file (use -verbose flag for details).";
char*s1956_211605167A="Overflow of infix \"-\" with INTEGER_8 operands. (";
char*s1652_762747069A="\"retry\" cannot be outside of a rescue clause.";
char*s1661_466551816A="$ link/exe=";
char*s1661_2009849A="generic";
char*s1665_1743948446A="==2, \"Recursive once function.\");\n\175""\n";
char*s2263_16927A="new9";
char*s2380_1682659883A=".chunk_list=NULL;\n";
char*s2378_1007239A="*b=((gc";
char*s1652_2028592127A="Removed unexpected blank space(s) just before this dot (assume you really want to call a procedure using the previous manifest expression as the target).";
char*s1647_1838187926A="class-name: ";
char*s2025_1163823042A="\nSee SmartEiffel/tutorial/external/C++ directory for more information.\n (Internal state = ";
char*s1585_16942A="loop";
char*s2297_989731302A="Second occurrence of this value (\"";
char*s1950_897982986A=" (\"\?=\" is not necessary).";
char*s2375_1038016A="(int*n)";
char*s1659_1783880762A="Collecting done";
char*s1585_10049231A="generate";
char*s2174_206419907A="fd.assertion_flag=1;\nfree_exception_frames();\n";
char*s2378_931143030A="=n->header.next;\n\175""\nelse\173""\nif(c==NULL)c=gc_fsoc_get2();\n";
char*s2169_810433A="(/*RF2:";
char*s1830_1973946666A="TUPLE type expected for open arguments of agent type.";
char*s1652_1062177790A="Extra \",\" ignored.";
char*s2545_1994165009A="No support found for this external \"plug_in\" (plugin: \"";
char*s2157_46733806A="static se_frame_descriptor fd=\173""";
char*s1830_1838870713A=" has two conflicting external types";
char*s2174_1008067448A="internal_exception_handler(";
char*s1659_485115581A=" (magic_count=";
char*s2021_2101296982A=" type is not allowed.)";
char*s2378_90782A="void ";
char*s2545_1508488213A=" defined in ";
char*s2174_20481355A=") break;\n";
char*s2186_90792A="void*";
char*s1585_78490A="class";
char*s1586_78495A="clean";
char*s1661_146157A=" /link";
char*s2263_1428771266A="void  gc_info(void)";
char*s1895_931579788A="Cannot pass Void as argument (the formal type is expanded).";
char*s2545_1942675017A="Including source ";
char*s2179_252669317A="((void*)a1);\n";
char*s1584_41849945A="Real_bits";
char*s1674_27561173A="Trying to read file \"";
char*s1665_1533928773A=".......................................";
char*s2354_2007377394A="Unknown loadpath";
char*s1653_1658160521A="Expected \"[\" (to start generic argument list).";
char*s2179_933501A="(NULL!=";
char*s2026_1136691048A="\"set\", \"get\", or \"access\" keyword expected.";
char*s1665_1170250908A="(/*UA*/((void)(";
char*s1924_35157672A="Adapting ";
char*s1652_1436398529A="Keyword \"loop\" expected (in a loop).";
char*s2261_1657834530A="Compiling without Garbage Collector!\n";
char*s2375_1619999729A="void bdw_weakref_setlink(bdw_Twr*wr,T0*r)";
char*s1584_447584A="stderr";
char*s1652_1414519430A="Error while reading fractional part of a real value (digit expected after the dot).";
char*s1665_1404148845A="parent_profile,";
char*s1665_958964069A=" agent wrapper: ";
char*s2182_90405963A="*id=(*((T0**)R))->id;\n";
char*s2033_439056951A="New name and old name must be different.";
char*s1901_767649523A="..... unique target buffer .....";
char*s1584_1554777A="POINTER";
char*s1568_1216703285A="Some feature is not yet implemented (i.e. feature `not_yet_implemented\' of\nclass ANY has been called somewhere). Just run this code under the debugger\nto know the `not_yet_implemented\' caller.\n\nThe error occured in the type";
char*s2004_22861847A=" insert: ";
char*s1665_530940601A="\" (i.e. file(s) \"";
char*s1665_724500276A="((/*agent*/void*)a)";
char*s2029_1723490337A=" open operand cannot be the target of an agent call.";
char*s1665_2109816196A="int argc,...)";
char*s1584_591417242A="standard_twin";
char*s2179_10895A="EIF_";
char*s1652_2096474678A="**** Found potentially assignable expression";
char*s2545_1439959996A=">. Strange dependency!";
char*s2262_1061058398A="(GC_get_heap_size())";
char*s1919_1094507536A="For inspect statement, the expression type can be only INTEGER, CHARACTER or STRING. (Actually ";
char*s2179_10430693A="isnormal";
char*s1659_445497083A="Finished inlining of dynamic dispatch.\n";
char*s2378_176986A="--;\nn=";
char*s1665_997623147A="),\nfprintf(SE_ERR,\"-manifest_string_trace: line ";
char*s2157_1623721137A="... once unique buffer ...";
char*s1665_2055072316A="(T7*)se_string(";
char*s1661_631091213A="\"[General] flavor\" key is missing.";
char*s1584_1735712398A="object_as_pointer";
char*s2378_73472312A="(&(o1->object));\n";
char*s1647_625881326A=" is a generic class (missing actual generic";
char*s1585_78591A="boost";
char*s2174_379993A="ac_civ";
char*s2261_1750560930A="se_malloc(1)";
char*s1659_1224226011A="C.ADRIAN, P.REDAELLI, R.MACK";
char*s1956_163270777A=" which is out of INTEGER_32 range.)";
char*s1927_561523426A="...........";
char*s1957_1490189105A=" while expression ";
char*s1892_1060258809A="Incompatible number of arguments.";
char*s1827_2108992007A="external_c_files";
char*s1584_1192911276A="object_memory";
char*s1652_631447998A="Must use exactely two hexadecimal digit for a CHARACTER constant.";
char*s1585_10990481A="separate";
char*s2179_1514442508A="((void*)(&a1));\n";
char*s1652_1632732392A="Slash (\"/\") expected (inside CHARACTER constant).";
char*s1584_167970159A="TEXT_FILE_READ";
char*s1665_1253959973A="Function without Current";
char*s2122_565060278A="/* C Header Pass 1: */\n";
char*s2179_78629A="ds.p,";
char*s1659_1605895597A="\" redefined as \"";
char*s1655_126291003A="Bad program.\n(Closing \")\" not found.)";
char*s1827_1658492806A="\" file.\nACE file not found.";
char*s1584_48856070A="arguments";
char*s1584_1622700141A="deep_twin_from";
char*s2157_1694771411A="typedef struct _se_";
char*s1665_78646A="ds.p=";
char*s1833_722230651A=" which is actually already renamed as ";
char*s2157_404651A="u->eq=";
char*s2172_8087250A="UINT8_C(";
char*s2174_119389596A="/*state*/=";
char*s1652_1453916708A="Unexpected \";\" to end rename list (deleted).";
char*s1652_844703215A="Infix operator name expected.";
char*s1665_2237652A="static ";
char*s1581_1364794873A="Unable to remove existing the file \"";
char*s1957_1256137461A="Invalid assignment test. The left-hand side expression must conforms with the right-hand side. The left-hand side is of type ";
char*s2191_1465905014A=" is deferred in type ";
char*s1655_618869258A="Inserted \':\'";
char*s1580_1852009437A=": missing C mode name after -c_mode flag.\n";
char*s1653_174945438A="Error inside multi-line manifest string.";
char*s1586_1777434714A="safety_check";
char*s1652_501268295A=" to rename a feature. (Feature name expected.)";
char*s2174_380065A="ac_ens";
char*s2156_605650769A=" = \");\nse_prinT";
char*s1659_313299890A="Cannot load root class ";
char*s1652_1950357785A="End of TUPLE expression expected.";
char*s1652_2077708091A="Unable to find the feature name which is mandatory just after the \"frozen\" keyword.";
char*s2219_1760457965A="require else";
char*s1665_850522083A="init_profile(&runinit_profile, \"<runinit>\");\n";
char*s1661_447734A="wcc386";
char*s1665_824324978A="se_introspecT[";
char*s1906_793028699A="Feature found is a procedure.";
char*s1961_2007408328A=" which is a simple and predefined expanded type.";
char*s1585_17176A="none";
char*s1953_1090404950A=" result.) (VWEQ)";
char*s1885_1492212881A="System_level_type_error";
char*s2240_78239462A="Classes path set more than once";
char*s1652_2141291014A="Empty formal argument list (deleted).";
char*s2191_1548937422A="Keyword \"require else\" replaced with \"require\" (There is no inherited require assertion here).";
char*s1674_210141519A="Renaming \"";
char*s1585_2065491A="inherit";
char*s2155_565066528A="/* C Header Pass 3: */\n";
char*s1665_27063164A="init_profile(agent_switch_profile+";
char*s2180_1719326284A="\173""/*dumb copy*/";
char*s1674_349372A="Total ";
char*s1665_106460275A="*)a)->afp(";
char*s1584_84881A="low_8";
char*s1585_17221A="once";
char*s1665_1917882A="agents ";
char*s1950_1424594977A="The expression ";
char*s2380_576790349A=".store_left>0)\173""\n";
char*s1661_129391217A="\" does not contain name of a valid file.\n";
char*s1584_2038667775A="like Current";
char*s2296_1762204931A="Not a good slice. The lower bound (";
char*s2378_1497878015A=";\nif(gc_find_chunk(na)!=NULL)\173""/* non external NA */\n   rsoh*h=((rsoh*)na)-1;\n   if((h->header.magic_flag)==RSOH_UNMARKED)\173""\n      h->header.magic_flag=RSOH_MARKED;\n";
char*s2338_1854402277A="Using the configuration file: ";
char*s1652_2127445170A="Character \'%\"\' inserted after \"prefix\".";
char*s1584_50246319A="generator";
char*s1827_926093361A="The valid values for split are either \"legacy\" or \"by_type\".";
char*s2090_1134353920A="safety checking";
char*s2174_1898591066A="creatinstexp";
char*s1665_545118879A="Precursor routine";
char*s2174_380168A="ac_inv";
char*s1652_23410A=" \011""[\000""\n";
char*s1665_508495830A=").\",NULL);\n";
char*s2378_77562923A="(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;\n";
char*s2006_1790874766A="The type of this constant feature should be INTEGER or REAL.";
char*s1919_7238542A="INTEGER ";
char*s1652_469031018A="Expression expected after \"old\".";
char*s2263_453998A="void X";
char*s2179_1671077900A="((uint16_t)(";
char*s2174_1952787551A="\173""int c=0;int v=0;\n";
char*s2378_1739163321A=";o1++)\173""\nif((o1->header.flag)==FSOH_MARKED)\173""\no1->header.flag=FSOH_UNMARKED;\n";
char*s1584_447851A="stdout";
char*s1830_689575137A="Cyclic inheritance graph: ";
char*s2031_29585A=" >> \175""";
char*s2123_100561530A="), &(o2->_";
char*s1584_2098363273A="is_subnormal";
char*s1659_1004555549A="Internal compiler error. Definition of infix \"^\" of INTEGER_GENERAL is not coherent with compiler builtin simplifications.";
char*s1584_349117293A="NATIVE_ARRAY";
char*s1581_1812938425A="Bad executable name: \"";
char*s1653_1861857328A="Deleted extra semi-colon.";
char*s1668_1816788953A=". The assigner feature is expected to have exactly one more argument than the assigned feature.";
char*s2191_1541882313A=" is inherited more than once.";
char*s1652_179688005A="Expected a non-empty types list.";
char*s1652_928941315A="Constraint Class name expected.";
char*s1659_1836299930A="Measurements done during inlining of dynamic dispatch:\n";
char*s1674_195766720A="Unable to write error(s)/warning(s) redirection output file \"";
char*s1652_1680421289A="Void cannot be the left-hand side of the binary \"+\" operator.";
char*s1956_165614527A=" which is out of INTEGER_16 range.)";
char*s1584_84969A="lower";
char*s2157_2142146116A="int R=1;\nse_";
char*s2174_380218A="ac_liv";
char*s2375_101355036A="if(bdw_in_assign)bdw_delayed_finalize=1;\nelse\173""\nhandle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s1956_1057872442A=" which is out of range -63 ..63 because target type is INTEGER_64.";
char*s2179_204519611A="if(R)\173""\nT0*o1=C->_";
char*s2545_838816886A="). No description file found.";
char*s1668_1998329594A="\" come from the same original feature via multiple \"insert\" paths, but none comes via an \"inherit\" path.\nBelow, you get the feature evolution step by step. Note that in the end (type ";
char*s2375_800004081A="T0*bdw_weakref_getlink(bdw_Twr*wr)";
char*s1652_75828399A="\" as a local variable name.";
char*s1665_701821825A="se_frame_descriptor fd=\173""\"<global-once>\",0,0,\"\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=NULL;\nds.exception_origin=NULL;\nds.locals=NULL;\nds.depth=0;\n";
char*s1652_1204389280A="You are using a case sensitive language in which all class names must use only upper case letters. This decision was made to make the code more readable and to allow better error messages as well as syntax error recovery. The name \"";
char*s1988_1628100917A="Unable to find file for class \"";
char*s1653_1578831409A="Expression expected after assignment test \"\?:=\".";
char*s1652_1307652273A="Expected a feature name to assign.";
char*s1652_1690004585A="Writable entity expected here. Argument ";
char*s2375_486352305A="mark_native_arrays(";
char*s1975_1627141371A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_make\').";
char*s1586_914215870A="high_memory_compiler";
char*s1661_1588150185A="The selected system name is \"";
char*s1661_91157A="wlink";
char*s2338_1932458562A="\' key in the ini file must be an integer.\n";
char*s2019_375013061A="Such an expression cannot be on the left-hand side of an assignment operator. There is no assigner to `";
char*s1647_8198176A="TUPLE...";
char*s2179_60405A="R=1;\n";
char*s2261_1345708525A="\173""/*mark_item*/\175""\n";
char*s2006_1875641781A="Value out of INTEGER_16 range.";
char*s2378_1831440704A="\175"",NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc";
char*s1957_29662A=" \?:= ";
char*s2296_1309017823A="The value is already part of previously encountered slice. (Wrong inspect statement.)";
char*s1584_1487451A="NATURAL";
char*s1827_1453633985A="Unknown assertion level tag.";
char*s1665_495363549A="stop_profile(&master_profile, &global_profile);\n";
char*s2262_1240206596A="void gc_start(void)";
char*s1652_1545228536A="Cannot open Cecil file (use -verbose flag for details).";
char*s1950_277033810A=" while the expression ";
char*s1652_973007162A="Empty debug key list (deleted).";
char*s1661_561720547A="\": unknown C compiler name after -cc flag or in the ACE file.\n";
char*s1913_197895058A="Must use here a manifest STRING because the previous one used in this \"inspect\" statement is a manifest STRING.";
char*s1659_1889118664A="No Polymorphic Call Site in the Live Code.\n";
char*s2157_1387812168A=");\nu->creation_mold_id=";
char*s1935_668815628A="The slice includes an already encountered value. (Wrong inspect statement.)";
char*s1652_2108887750A="The base type is no longer used. Class ROUTINE now has only one formal argument. Just remove this unused type mark.";
char*s1584_240810599A="c_inline_c";
char*s1665_2022630A="error0(";
char*s1663_11253A="BeOS";
char*s1584_240810604A="c_inline_h";
char*s2174_2022635A="error1(";
char*s1669_128358027A="..................................................";
char*s1585_392625A="assign";
char*s2157_4999725A="*a2=(se_";
char*s1652_199494346A="Keyword \"end\" expected at the end of a class.";
char*s2157_706329A="\",1,0,\"";
char*s2376_1777096676A="\n#define gc_mark";
char*s2211_143852403A=". (The whole type of the agent your are trying to launch is ";
char*s2191_831146693A="All ancestors are deferred, hence making this Precursor call not valid.";
char*s1584_17422A="\174"">>>";
char*s1584_2054549840A="manifest_put";
char*s1652_1912621670A="This name cannot be used as a valid class name.";
char*s2190_265537649A="/*INTERNAL_C_LOCAL list]*/\n";
char*s2174_380343A="ac_req";
char*s2211_167300030A=" into formal argument of type ";
char*s2263_1384921237A="handle(SE_HANDLE_EXIT_GC,NULL);\n";
char*s2378_110557057A=" = old_gc_free;\nc->next=fsocfl;\nfsocfl=c;\nc->header.state_type=FSO_FREE_CHUNK;\n\175""\n\175""\n";
char*s1652_922446006A="Overflow while reading integer constant. Value `";
char*s1652_66884963A="Error while reading an integer constant. Missing \"\175""\" \?";
char*s1665_1581747096A="se_msi1(&local_profile);\n";
char*s1652_134219969A="Error while reading an hexadecimal value. Missing \"\175""\" \?";
char*s1581_53561911A="no_rescue";
char*s1665_471553120A="parent_profile=&global_profile;\n";
char*s2263_1374304640A="fprintf(SE_GCINFO,\"--------------------\\nNumber\\tTotal\\tStore\\tName\\ncreated\\tsize\\tleft\\n\");\n";
char*s2174_504830035A=")) \173""switch(";
char*s1934_128333478A="The corresponding feature definition.";
char*s1661_262628264A="linkit.com";
char*s2174_1888091524A="goto retry_tag;\n";
char*s2025_1809088081A="data_member ";
char*s1652_1701980726A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure using the previous STRING as target).";
char*s1584_337331A="Result";
char*s1665_17480A="se_i";
char*s1647_1056980719A="Procedure \"";
char*s1665_1680956616A="se_profile_t root_profile";
char*s1652_2060540980A="Empty formal generic list (deleted).";
char*s2182_5313505A="*exp=0;\n";
char*s1586_17498A="sedb";
char*s1674_1293738877A=" is not set.\n";
char*s1652_1046025807A="The old \"select\" option of the \"inherit\" clause is now obsolete. You have to update your code with the new \"insert\" mechanism. With Liberty Eiffel, this can be achieved thanks to the new \"insert\" clause. The new \"insert\" clause comes just after the traditional \"inherit\" clause with a similar syntax.";
char*s1584_1483884743A="native_array_internals_from_generating_type";
char*s2122_985967445A="; /*NATURAL_";
char*s2180_2102695A="memcpy(";
char*s1665_17507A="prof";
char*s2191_139854341A="Signature of the redefined feature is not valid.";
char*s1652_2176510A="plug_in";
char*s1652_552734069A="The SCOOP attempt implementation has been abandoned (December 2006). ";
char*s1659_1556970935A="Unsafe call site (see also next warning).";
char*s2263_35966A=" elt=";
char*s2182_5313530A="*exp=1;\n";
char*s2180_1416678934A=">>8)&0xFF00)\174""(((uint32_t)";
char*s1935_492964813A="Second occurrence for this value in the same inspect. (Wrong inspect statement.)";
char*s1653_1538234998A="Index value expected (\"indexing ...\").";
char*s1585_306165094A="smarteiffel_options";
char*s1659_921818688A="Monomorphic Procedure Call";
char*s1956_1505530135A="Overflow of infix \"*\" with INTEGER_16 operands. (";
char*s2179_46980416A="_t)((uint";
char*s1668_870131842A=" (given first) can\'t be accepted because a concrete feature is inherited. What\'s called a concrete feature here is a feature which is not deferred. You may consider to add a redefine or an undefine. May be.";
char*s1665_2072467813A="&local_profile";
char*s1956_177461A=" by 0.";
char*s1659_572614135A=" formal argument";
char*s1833_867234734A="Redefinition of ";
char*s2378_97510A="\175""\175""\175""\175""\n";
char*s1647_445214625A=" is invalid. A deferred class must not be expanded.";
char*s1580_386614A="bdw_gc";
char*s1827_929353692A="linker_options";
char*s2122_1316811340A="/*BUG:WR@runtime!*/";
char*s2074_637371887A="Cannot create an ARRAY with only `Void\' items.";
char*s1665_1130602126A="(se_local_profile_t*parent_profile)";
char*s2263_558682149A="void*gc_mark_agent_mold;\n";
char*s2091_11429A="HOME";
char*s1659_170061979A="Target Type Prediction Score: ";
char*s2263_398948A="gc_lib";
char*s2157_5284A="\" (\"";
char*s1652_755120513A="Inside a client list, only plain class names are allowed. (Class names must use only uppercase letters.)";
char*s2065_890319497A=" which is out of INTEGER_64 range.";
char*s1652_2087550139A="Keyword \"end\" added to finish this \"if\" statement.";
char*s2157_21632225A="*)u1;\nse_";
char*s2263_328118105A="manifest_string_mark1();\n";
char*s2378_775406525A="p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));\nfor(;((void*)p)>=((void*)o);p--)\173""\ne=*p;\n";
char*s2030_1370872538A="Invalid notation for 0.0.";
char*s2375_473982927A="if(g!=o->bdw_generation)\173""\n";
char*s2179_520373770A="((int16_t)(";
char*s1586_10714216A="no_split";
char*s2187_448205A="uint32";
char*s2179_1836091144A="Bad number of arguments of external signature.";
char*s1671_300594A="File \"";
char*s1584_1740332382A="Minimum_double";
char*s1659_1379717706A="Now inlining dynamic dispatch (using inspect instructions)\n";
char*s1652_1606714210A="Since february 2006, for SmartEiffel release 2.3, the old legacy NONE type mark is obsolete. Keep in mind that an empty class name list such as \173""\175"" does indicate no exportation at all, hence making NONE useless and probably misleading for newcomers. So, just remove this NONE class name now. Please update your code now.";
char*s1584_1644425991A="manifest_semicolon_check";
char*s2191_1677586033A=". This can lead to catcalls!";
char*s2157_4434071A=" called.";
char*s2174_4766225A=" while (";
char*s1961_1119905623A="`manifest_create\' is not an ordinary creation procedure. Please use the \173""";
char*s2375_1509872874A="*o=*markna;\nGC_disable();\n";
char*s1585_75797981A=" has no compiler-defined `deep_twin\' or `is_deep_equal\' because the corresponding allocated size is not part of the NATIVE_ARRAY object. The client class of this NATIVE_ARRAY type is supposed to use a `capacity\' attribute which contains the corresponding number of allocated items (see STRING or ARRAY for example).";
char*s2263_49680837A="if (i <= ";
char*s1653_744085684A="Right hand side expression of \?= assignment expected here.";
char*s1665_1173628471A="]=runinit_profile;\n";
char*s2114_146251545A=".unlock*/\n";
char*s1584_267647687A="standard_is_equal";
char*s2026_380590A="access";
char*s2375_1832086881A="(o)==NULL&&GC_should_invoke_finalizers())bdw_run_finalizers();\n";
char*s1953_988692517A="\"). You can use the Void comparison only when other type mark is a reference type or, if it is an expanded type, it must be an anchor or some formal generic argument. Fix this error first.";
char*s1933_5382A=" -- ";
char*s2191_2025498932A=") of the concrete feature (inherited from type ";
char*s2019_789350917A=" by a call to \173""";
char*s1652_96053257A="No parent after \"insert\" keyword (an empty list is not allowed here).";
char*s1827_17696A="root";
char*s1652_1066804080A="Missing \":\" before the type mark\?";
char*s1652_1062283098A="Only simple and statically computable expression are allowed here (inside \"when\" of \"inspect\" statement).";
char*s1659_109671582A=" while there is no actual argument list in the call.";
char*s1837_1831619428A="Too many errors.\n";
char*s1883_1262756502A="Parsing Cecil file: ";
char*s2263_444175272A="#define SE_GC_LIB 1\n";
char*s1585_17715A="then";
char*s1827_880804011A="Keyword \"root\" expected. Invalid ACE file.";
char*s2182_300665A="R=(*((";
char*s1653_2004339522A="Added missing brackets to enclose the previous \"once\" manifest STRING.";
char*s1892_1001314405A="Incompatible signatures. (One has argument(s) but not the other.)";
char*s1833_92467250A="Cannot redefine ";
char*s1837_878860A="------\n";
char*s2179_537910373A="se_deep_twin_trats()\n";
char*s1652_112999293A="Instruction expected here. True alone is not an instruction.";
char*s2116_30034A="&(((T";
char*s1665_1968768303A="master_profile.profile=NULL;\n";
char*s1652_783329131A="Total time spent in parser: ";
char*s2157_180709512A="return u->R;\n";
char*s1652_1984637890A=" is not a feature name.";
char*s1668_1605047378A=" type.\n\nFirst \"inherit\" path (from parent to child):\n   ";
char*s1665_1435285930A="Define initialize stuff.\n";
char*s1652_79251A="false";
char*s1652_756929053A="Must use exactly 2 hexadecimal digits for INTEGER_8.";
char*s1652_142936234A=" cannot be used as a feature name to start a new feature definition. Parser lost. Sorry. Check before and after that point.";
char*s2191_21306364A="This Precursor call is ambiguous because the type ";
char*s1665_738771309A="void initialize_eiffel_runtime(int argc,char*argv[])";
char*s1659_295542551A="Polymorphic Function Call";
char*s2157_386819A="caller";
char*s1923_22401251A=" context.";
char*s1653_348041349A="Error in inspect.";
char*s1665_401124480A=" run classes :\n";
char*s1892_1149307517A="Bad redefinition. An attribute must be redefined as an attribute only (VDRD.6).";
char*s1975_1837585965A="Creation procedure not found.";
char*s2263_1642168697A="void(*gc_mark_agent_mold)(se_";
char*s1934_305790140A="This is not an INTEGER expression.";
char*s2157_242108838A=" (1 feature).\n";
char*s2157_56760755A="void*eq;\n";
char*s2157_60837A="R=C->";
char*s2157_1367040625A="retry_tag:\n";
char*s1584_1979951A="dispose";
char*s2034_1965077754A="Such an \"inspect\" statement is for type STRING or FIXED_STRING. (The type of ";
char*s1665_471707221A="*sizeof(se_profile_t));\nqsort(sorted_inv_profile, ";
char*s2012_1809998749A="\' not found.";
char*s1663_17794A="vbcc";
char*s1584_386854A="calloc";
char*s1665_1844536619A="se_local_profile_t*,";
char*s2156_1151663379A="fprintf(file,\"%llu\",(long long unsigned int)((uint64_t) *o));";
char*s1652_776600004A="Explicit creation/create type mark should not be anchored.";
char*s2376_1126647264A="*next;\175"" header;\175"";\n";
char*s1932_2014931627A="External feature must not have rescue compound.";
char*s1652_150329797A="Error while reading hexadecimal value.";
char*s1665_802495724A="\");\nstart_profile(parent_profile, &local_profile);\n";
char*s1674_1723571071A="................................................................";
char*s1665_719604853A="=((T0*)eiffel_root_object);\n";
char*s1663_39617954A="Macintosh";
char*s1661_25704393A="/LIBPATH:";
char*s2117_5515A="\").\n";
char*s1652_397329363A="Inheritance option not at a correct place. The correct order is: \"rename... export... undefine... redefine...\".";
char*s1665_1881374985A="memcpy(sorted_agent_profile, agent_profile, ";
char*s1665_713312393A=", inv_profile, ";
char*s1652_676769302A="Syntax error while trying to parse the beginning of a new feature definition. Expression ";
char*s1584_79341A="count";
char*s2157_882065083A=";\nstruct _se_";
char*s1665_862271166A="ds.fd->assertion_flag=1;\n\175""\n";
char*s1837_60894A="Error";
char*s1584_48672249A="bit_clear";
char*s1665_23988287A="#include ";
char*s1665_1682814572A="manifest_put(";
char*s1584_572288431A="to_natural_16";
char*s1659_1019367716A=" (For this call, the target is the implicit non written `Current\' which is of type ";
char*s2090_1381550903A="simplifying";
char*s1584_572288437A="to_natural_32";
char*s2263_189437896A="unsigned int fsoc_count_ceil";
char*s2263_1891487260A="(gc_memory_used())";
char*s2262_1746735781A="bdw_mallocT9";
char*s1956_530141799A="Violated require assertion. Argument value is ";
char*s2157_560761477A="internal_exception_handler(Routine_failure);\n\175""\n";
char*s1652_202933204A=" cannot be an expression. ";
char*s1584_572288454A="to_natural_64";
char*s1665_1672511676A="global_profile.profile=&root_profile;\n";
char*s2262_6943896A="GC_DEBUG";
char*s1652_120546715A="Left hand side expression of := assignment must be a feature call.";
char*s1659_479236135A="Result type of a once function must not involve formal generic names nor anchored types (VFFD.8).";
char*s2156_5580A="\");\n";
char*s1659_1865554673A="Live_type_map size=";
char*s1652_922212712A="Variant (INTEGER) Expression Expected.";
char*s1659_1162901343A="Starting optimization (";
char*s2157_674382779A="(void**)&R,";
char*s1659_1546692995A=" while the actual argument list has ";
char*s2031_1411247976A=". (Actual bunch size is ";
char*s2262_1665893228A="Adding Boehm-Demers-Weiser Garbage Collector.\n";
char*s1665_4692662A="#define ";
char*s2375_2070967345A="typedef struct bdw_Swr\173""Tid id;T0*o;\175""bdw_Twr;\n";
char*s2174_312808564A=")->_storage + ((";
char*s1665_1994596535A="void(*se_prinT[";
char*s2185_17916A="uint";
char*s2375_42521A=")obj)";
char*s1659_5615A="\".)\n";
char*s1665_4631170A="/*PCO*/\n";
char*s1665_1413407004A="Cecil (C function for external code) :\n";
char*s1584_1680926299A="default_create";
char*s1585_436196A="rename";
char*s2031_1142240176A=" into formal argument which is of type ";
char*s2338_602797481A="Redundant key definition found in section [";
char*s1661_120239233A="1234567890";
char*s2378_28263330A=",size));\n";
char*s1584_506823435A="manifest_creation";
char*s1586_10554609A="loadpath";
char*s1827_816126476A="Unused obsolete flag -wedit / option wedit.";
char*s1652_1869854287A="Unexpected bracket after a comma.";
char*s1652_2009918711A="Error inside feature name definition. Unable to find the synonymous name which must be just after the previous colon mark \",\".";
char*s2243_861846863A="Legacy splitter enabled.\n";
char*s1584_39002989A="PREDICATE";
char*s2090_456083848A="The system is not type safe (read previous warnings carefully).";
char*s1580_85614A="no_gc";
char*s2174_521905705A=")->_count;\n";
char*s2378_291421585A="size=(size*sizeof(";
char*s1665_1586354711A="uint32_t lsi";
char*s2006_865125357A="A \"unique\" definition is actually a constant attribute definition.";
char*s2262_1166044581A="GC_java_finalization=1;\nGC_finalize_on_demand=1;\nGC_finalizer_notifier=bdw_run_finalizers;\nGC_INIT();\nGC_stackbottom=(char*)(void*)&argc;\n";
char*s1652_971408488A="Right hand side expression of ";
char*s2038_1773984820A=" Replace your code with:\n\n      agent ";
char*s1659_866669263A="Handling include of \"";
char*s2025_1961687A="delete ";
char*s1670_51895507A="error1(\"Invalid inspect (nothing selected).\",";
char*s1674_1635864124A="SmartEiffelDirectory";
char*s2378_1815688614A="*)(&(c->first_object)));\nif(c->header.state_type==FSO_STORE_CHUNK)\173""\nfor(;o1<";
char*s1652_210812758A="\" does not contain class \"";
char*s1950_1250079569A="The left-hand side of ";
char*s2191_1722095007A="Signature (adapted in the type ";
char*s1975_1333985363A="Feature `manifest_make\' must be a procedure.";
char*s1665_2041682A="extern ";
char*s1901_786054293A="Forbidden call (i.e. exportation rules violated) when the type of Current is ";
char*s2157_988243818A="\173""Tid id;\nint creation_mold_id;\n";
char*s1584_1937220099A="is_deep_equal";
char*s2157_5720A="\",1\175""";
char*s2378_598811726A=".store_left>sizeof(rsoh))\173""\nr->header.size=size;\n";
char*s1660_1461366457A="Version of command \"#(1)\" is:";
char*s2300_1613492996A="Invalid byte as first character of UTF-8 sequence.";
char*s1652_18036A="true";
char*s1584_247239028A="collecting";
char*s2262_1942608409A="gc_start();\n";
char*s2263_41125176A="gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);\n((gc";
char*s2379_1506490209A=")\nfprintf(SE_GCINFO,\"%d\\t%d\\t\\t";
char*s2172_1406782500A="/*ND*/(T0*)(";
char*s1580_425790270A=": missing split mode after -split flag.\n";
char*s1665_2103819988A="int se_strucT";
char*s1953_1816888147A=". Comparison not allowed (VWEQ).";
char*s1652_1694969179A="Such an expression cannot be on the left-hand side of an assignment operator. A dot can never be used for the left-hand side part of an assignment operator. Valid left-hand side can be Result, some local or the name of an attribute of Current. See also http://SmartEiffel/wiki/en/Syntax_diagrams#Writable.php for details.";
char*s1665_1836282258A="se_local_profile_t global_profile";
char*s2172_1188262106A="/*$*/((void*)W";
char*s1652_825716016A="Name of the current class expected.";
char*s1584_1549680A="REAL_32";
char*s2376_130382376A=";\nstruct B";
char*s2024_1848584263A="Double definition found for key ";
char*s1892_1642968637A="\' but different signatures. According to the join rule, the signatures have to be identical in the final class.";
char*s2378_1040644265A="*n;\nfsoc*c;\n";
char*s1665_1042003640A="int(*eq)(se_agent*,se_agent*);\n\175"";\n";
char*s1923_5787A=" := ";
char*s1585_18090A="when";
char*s2004_114137597A=" inherit: ";
char*s2180_946895A="#endif\n";
char*s1950_1721307786A="Void cannot be the right-hand side of a ";
char*s1584_1549697A="REAL_64";
char*s1665_1352413868A="int32_t c,uint16_t*s,int32_t sc,int16_t*lsv,int32_t*lsi)";
char*s2153_11952A="T0**";
char*s1584_1549703A="REAL_80";
char*s1659_98784712A="\' in type ";
char*s1826_1968202785A=" (See next message to locate the error.)";
char*s1584_18110A="twin";
char*s1665_1063704391A="fprintf(profile_file, \"\\n===============================================================================\\nDetailed profile:\\n\");\n";
char*s2157_1566831588A="ds.exception_origin=NULL;\n";
char*s1665_1339521386A="fprintf(profile_file, \"===============================================================================\\nSummary:\\n\");\n";
char*s1827_374877A="_check";
char*s2262_1635390646A="GC support (functions).\n";
char*s2378_2021999449A="gc_update_weak_ref_item";
char*s2191_1849347035A=") is not compatible with the deferred one comming from parent type ";
char*s1665_1460025642A="start_profile(&master_profile, &global_profile);\n";
char*s2378_484169497A=".store_left=0;\n\175""\n(r->header.magic_flag)=RSOH_UNMARKED;\n((void)memset((r+1),0,r->header.size-sizeof(rsoh)));\nreturn((T";
char*s2031_14429929A=" not correctly equiped for manifest generic creation (`manifest_creation\' missing in the creation clause).";
char*s1674_809686569A="\".\nCommand aborted.\n";
char*s2174_6575105A=";break;\n";
char*s1663_18144A="vpcc";
char*s1652_18150A="void";
char*s1668_290966604A=") there are two versions of the same initial feature with two different names. To  fix this, either use enough \"inherit\" links in place of \"insert\" links to have one \"inherit\" path or rename the feature to get the same name in ";
char*s2378_322115272A="*)(wr->o);\nif (obj_ptr != NULL)\173""\nint swept = (((void*)obj_ptr) <= ((void*)wr));\nif (swept != (obj_ptr->header.flag == FSOH_MARKED)) /* **** TODO: was FSOH_UNMARKED\?\?\?\? (incoherent with comment below) */\n/* (already swept) xor marked */\nwr->o = NULL;\n\175""\n";
char*s2180_2122389958A="se_print_run_time_stack();\n";
char*s1665_1624663341A=")(va_arg(pa,";
char*s1652_1320619413A="Added missing \":\" semicolon before this type mark.";
char*s1652_442256615A="\" aborted.\n";
char*s2172_112304676A="..........";
char*s2007_2015374870A="Conflict between argument/feature name (VRFA).";
char*s2157_472574902A="(se_agent*u1, se_agent*u2)";
char*s1827_1325140408A=": cannot use -sedb with -boost flag.\n";
char*s2378_171955A="*)n);\n";
char*s1586_267875778A="no_warning";
char*s2026_18186A="type";
char*s2378_1985327250A="se_gc_check_id(o,";
char*s2378_1196941282A="n->object=M";
char*s1584_1176378494A="type_can_be_assigned_to_item";
char*s2179_559906822A=" built-in: ";
char*s2091_1096544670A="/lang/eiffel/.serc";
char*s1674_203714719A="Obsolete \"";
char*s1584_55924644A="std_error";
char*s2376_2097247A="na_env ";
char*s1672_2120987577A="..... unique buffer .....";
char*s1950_5912A=" \?= ";
char*s1833_1153312264A=" not found in this class.";
char*s1665_163413385A="se_profile_t agent_profile";
char*s2378_1800342110A="++;\n\175""\nelse if(";
char*s2157_1992825354A="\173""\"invariant ";
char*s2179_854330615A="\175""\nse_deep_equal_trats()\n";
char*s2545_1067567332A="The plugin ";
char*s1584_1673348567A="open_argument_index";
char*s1659_5873980A="Unknown infix operator \"";
char*s2187_399591A="double";
char*s1647_1539816514A=" is not a generic class. (See file \"";
char*s1674_44975894A="Writing \"";
char*s1585_56927287A="c_linker_path";
char*s2179_1709245815A=";\nerror0(\"Invalid deep_twin.\",NULL)";
char*s2179_4680700A="!memcmp(";
char*s1652_518055462A="Local variable name expected after comma inside local variable list.";
char*s2031_84293096A="Wrong number of arguments for manifest generic creation.";
char*s1584_1831158645A="INTERNALS_HANDLER";
char*s1652_732257893A="\')\' expected in expression.";
char*s2174_352968782A=");\nif(NULL!=(";
char*s1665_49152444A="ds.caller";
char*s1924_18257A="yes ";
char*s1957_902517583A="........................";
char*s2374_496139469A="Internal problem for \"mark_native_arrays\".";
char*s1837_927785894A="Fatal Error";
char*s1885_673829558A="Incorrect_inspect_value";
char*s1913_1664909434A="Cannot use \'..\' with manifest strings.";
char*s2006_529299514A="A boolean constant cannot be an assigner.";
char*s1652_1387339410A=" is not writable. Cannot use ";
char*s1652_445504446A="\" expected.";
char*s1659_1242126608A="Starting type safety check";
char*s1586_10714862A="no_strip";
char*s1661_1494914262A=" Ignore=93,194,304";
char*s2006_827998241A=" has no result type";
char*s1978_983618541A=" Constraint Generic Violation.";
char*s2262_341361877A="int bdw_in_assign";
char*s2263_1869700848A="*)eiffel_root_object)->header.flag=FSOH_UNMARKED;\n";
char*s1659_1568923104A=" must have a feature named `";
char*s1663_448859A="wcl386";
char*s1584_1553736287A="REAL_EXTENDED";
char*s1585_1980461A="convert";
char*s2378_744114A="&&(((gc";
char*s1652_1575461624A="A feature name cannot be used to indicate exportation status in a client list. Only plain class names are allowed here (class names must use only uppercase letters).";
char*s1652_1181926797A="Added \"end\" for inspect instruction.";
char*s2180_531809155A=">>8);\n#else\n";
char*s1665_8359055A="set_dump_stack_top(";
char*s1652_1978106088A="Erreur while reading a number.";
char*s1584_9712276A="as_16_ne";
char*s2263_172080A="*)o);\n";
char*s2182_705408837A="*id=_r->id;R=&_r;break;\ndefault:break;\n\175""\n\175""\n\175""\n";
char*s1585_1168210079A="cpp_linker_path";
char*s2375_1664195965A="void*bdw_na_assign_innerT";
char*s2179_42916A="(uint";
char*s1580_24284008A=": missing compiler name after -cc flag.\n";
char*s2263_249330648A="gc_info_nb";
char*s1833_1145998825A="\" (forbidden or not yet implemented).";
char*s2179_842552A="*)R)=*C";
char*s1665_431043495A="*sizeof(se_profile_t));\n";
char*s1665_490486762A="local_profile.profile=&atexit_profile;\n";
char*s1652_727903062A="Bad create expression (\'\173""\' expected).";
char*s1661_165012750A="\"[General] os\" key is missing.";
char*s1661_2075119688A="#1#2#3#4#5#6#7#8#9#\?.o";
char*s1974_306215109A="An assertion must be a BOOLEAN expression.";
char*s1665_1377208779A=";\nstart_profile(parent_profile, &local_profile);\n";
char*s2179_153655A="&(C->_";
char*s1659_212031001A="The main procedure must not have arguments.";
char*s1652_12184A="NONE";
char*s1658_1152235958A=" transitions.\n";
char*s1665_1160736641A="Manifest String";
char*s1665_12188A="T7*g";
char*s1665_113036818A="local_profile.profile=agent_switch_profile+";
char*s1665_12201A="T7*t";
char*s1652_34383990A="Error while reading a number.";
char*s1653_35386613A="...............................................";
char*s2001_498169402A=". An expanded type must have one unique creation procedure with no argument: the creation procedure used for automatic initialization. Please, consider to add explicitely the `default_create\' procedure from ANY or some other existing procedure with no arguments. For expanded class with no creation clause, the `default_create\' procedure is the one used for automatic initialization.";
char*s1652_1593742473A="Closing \">>\" of manifest generic creation expected.";
char*s1668_740900172A="Assigned feature not found in type";
char*s1652_2018315248A="Parsing Cecil File: \"";
char*s1665_1009317511A="Compiling/Sorting ";
char*s1652_124311631A="Void cannot be the left-hand side of the binary \"^\" operator.";
char*s2074_1359629264A="The old manifest ARRAY notation can only be used when the common type mark for all items of the manifest ARRAY exists, is not ambiguous and is easy to compute! By the way, it is not easy or possible to compute the most general type for the following set of types: \173""";
char*s1978_1920465143A="Actual generic derivation ";
char*s2237_8777401A="Universe";
char*s1665_1838958244A="/*agent*/T0*a";
char*s1652_1962710217A="\")\" expected to end debug string list.";
char*s2378_1901427808A="T0* obj_ptr = item->o;\nif (obj_ptr != NULL)\173""\nint obj_size=se_strucT[obj_ptr->id];\nint swept";
char*s2378_365929075A=".count_minus_one;\nn=";
char*s2380_958639438A=".store->header.magic_flag=RSOH_FREE;\n";
char*s2378_680177517A=")))return;\nif(((char*)p)>((char*)(b+(c->count_minus_one))))return;\nif(((char*)p)<((char*)b))return;\nif(((((char*)p)-((char*)b))%sizeof(*p))==0)\173""\nif(p->header.flag==FSOH_UNMARKED)\173""\nT";
char*s2263_1328320695A="mark_stack_and_registers();\ngc_sweep();\ncollector_counter++;\n";
char*s1661_5578901A="-include";
char*s1885_176865800A="Developer_exception";
char*s2172_7227375A="INT64_C(";
char*s1652_431394186A="Character \'%\"\' inserted.";
char*s2157_9589368A="agent_eq";
char*s2375_1048179568A="GC_disable();\nif(wr->o)GC_unregister_disappearing_link((void**)&(wr->o));\nwr->o=r;\nif(r)GC_GENERAL_REGISTER_DISAPPEARING_LINK((void**)&(wr->o),(void*)r);\nGC_enable();\n";
char*s1586_388005040A="case_insensitive";
char*s1661_1319327951A="loadpath.se";
char*s2191_374042271A="The \"feature\" clause declares a narrower client list than";
char*s1659_3579844A=" (type \"";
char*s1585_1747646688A="c_strip_path";
char*s2123_51582255A="int R=0;\n";
char*s2261_264935842A="))->o)=(T0*)(";
char*s1674_141444A="\" as \"";
char*s1653_432335312A="Same identifier appears twice (local/formal).";
char*s2378_1265395998A=".store))+size));\n\175""\nelse \173""\nr->header.size=size+";
char*s2172_40430500A="UINT64_C(";
char*s1827_1598804806A="At this point in the ACE file, you are supposed to say \"yes\", \"no\", or \"all\".";
char*s1655_356743A="Bad program.\n(No program name found.)";
char*s1665_209121A="(live)";
char*s1652_1615234134A="Since february 2006, for SmartEiffel release 2.3, the old legacy NONE type mark is obsolete. Keep in mind that an empty class name list like \173""\175"" do indicate no exportation at all, hence making NONE unuseful and probably misleading for newcomers. So, just remove this NONE class name right now. Please update your code now.";
char*s2157_338723264A="This routine is actually deferred is still in the live code set. (You will have a crash at run-time if the dynamic type of Current is ";
char*s2006_1573210512A="The type of this constant feature should be CHARACTER.";
char*s1665_1790869799A="C++ external definitions.\n";
char*s2157_3912034A="(&(a1->c";
char*s2213_1257368965A="ensure then";

#ifdef __cplusplus
}
#endif
