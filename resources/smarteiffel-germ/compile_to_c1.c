#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by 
Liberty Eiffel The GNU Eiffel Compiler, Eiffel tools and libraries
    release 2013.11 (Charles Adler, Jr.)

Copyright (C), 2011-2013 - C.ADRIAN, P.REDAELLI, R.MACK
    http://www.liberty-eiffel.org

Original SmartEiffel code:
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER, F.MERIZEN
    http://smarteiffel.loria.fr
C Compiler options used: -pipe -O2 -fno-gcse
*/

#ifdef __cplusplus
}
#endif
#include "compile_to_c.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


void se_check_malloc(void*result) {
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
}

/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  se_check_malloc(result);
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed: %lu x %lu).\n", nmemb, size);
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
    /* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#ifdef WIN32
#define SIMULATED_MODE
/* The simulated mode for WIN32.
*/
typedef struct _SIMULATED_DIR {
  HANDLE handle;
  WIN32_FIND_DATA data;
  int entry_used;
  char * pattern;
} SIMULATED_DIR;

static SIMULATED_DIR* simulated_opendir(char* path) {
  int len = strlen((char*)path);
  char* pattern = se_malloc(len + 5);
  SIMULATED_DIR* result = se_malloc(sizeof(SIMULATED_DIR));

  pattern = strcpy(pattern,(char*)path);
  if (pattern[len - 1] != '\\') pattern[len++] = '\\';
  pattern[len++] = '*';
  pattern[len++] = '.';
  pattern[len++] = '*';
  pattern[len++] = 0;
  result->handle = FindFirstFile(pattern,&(result->data));
  if (result->handle == INVALID_HANDLE_VALUE) {
    free(pattern);
    free(result);
    return NULL;
  } else {
    result->pattern = pattern;
  }
  result->entry_used = 0;
  return result;
}

static void* simulated_readdir(SIMULATED_DIR* dirstream) {
  if (dirstream->entry_used) {
    if (FindNextFile(dirstream->handle,&(dirstream->data))) {
      dirstream->entry_used = 1;
      return dirstream;
    }
    else {
      return NULL;
    }
  }
  else {
    dirstream->entry_used = 1;
    return dirstream;
  }
}

#define simulated_get_entry_name(x) ((x)->data.cFileName)

static int simulated_closedir(SIMULATED_DIR* dirstream) {
  FindClose(dirstream->handle);
  free(dirstream->pattern);
  free(dirstream);
  return 0;
}


/* GCC(MingW32) doesn't need these prototypes; whereas, LCC needs them. */
char * getcwd(char* buffer, int maxlen);
int chdir(const char* buffer);
int mkdir(const char* directory_path);
int rmdir(const char* directory_path);


#define simulated_getcwd(x, y) getcwd(x, y)
#define simulated_chdir(x) chdir(x)
#define simulated_rmdir(x) rmdir(x)

int simulated_mkdir(const char* directory_path, int perm) {

  mkdir(directory_path);
  return 0;
}

#endif  /* WIN32 */

#ifdef AMIGA
#define SIMULATED_MODE
/* The simulated mode for AmigaOS 2.04+
   Author: Thomas Aglassinger <agi@rieska.oulu.fi>

   Normally this shouldn't be necessary as all compilers include a
   simulation of the Un*x directory API. However, they differ in
   certain details, often resulting into compiler errors. Thus a
   implementation using native AmigaDOS calls seems preferable.

   Note that many of the happenings below have to deal with the
   various idiosyncracies of the "dos.library", which are not all
   documented clearly in the Autodocs. The biggest surprises should
   be reflected in comments. But consider reading chapter 17 of
   Ralph Babel's "Amiga Guru Book" before changing anything.
*/
#include <exec/types.h>
#include <dos/dos.h>
#include <dos/dostags.h>

#include <proto/exec.h>
#include <proto/dos.h>

typedef struct _SIMULATED_DIR {
  struct FileInfoBlock *info;
  BPTR lock;
} SIMULATED_DIR;


/* Release all resources allocated during `simulated_opendir'; also
   works correctly if structure was only partially initialized.
*/
static void free_simulated_dir(SIMULATED_DIR * dir) {
  if (dir != NULL) {
    if (dir->lock != NULL) {
      UnLock(dir->lock);
    }
    if (dir->info != NULL) {
      FreeDosObject(DOS_FIB, dir->info);
    }
    free(dir);
  }
}

static SIMULATED_DIR * simulated_opendir(char *path) {
  BOOL ok = FALSE;
  SIMULATED_DIR *result = se_malloc(sizeof(SIMULATED_DIR));

  if (result != NULL) {
    result->lock = NULL;
    result->info = (struct FileInfoBlock *) AllocDosObject(DOS_FIB, NULL);
    if (result->info != NULL) {
      result->lock = Lock(path, ACCESS_READ);
      if (result->lock != NULL) {
	ok = (Examine(result->lock, result->info) != DOSFALSE);
	if (ok) {
	  /* Ensure we are scanning a directory, not a file */
	  ok = (result->info->fib_DirEntryType >= 0)
	    && (result->info->fib_DirEntryType != ST_SOFTLINK);
	}
      }
    }
  }
  if (!ok) {
    free_simulated_dir(result);
    result = NULL;
  }
  return result;
}

static void * simulated_readdir(SIMULATED_DIR * dirstream) {
  BOOL ok;
  SIMULATED_DIR *result = NULL;

  ok = (ExNext(dirstream->lock, dirstream->info) != DOSFALSE);

  if (ok) {
    result = dirstream;
  }
  return (void *) result;
}

#define simulated_get_entry_name(entry) ((entry)->info->fib_FileName)

static int simulated_closedir(SIMULATED_DIR * dirstream) {
  free_simulated_dir(dirstream);
  return 0;
}


static EIF_POINTER simulated_getcwd(char *buffer, size_t maximum_length) {
     EIF_POINTER result = NULL;
     BPTR lock = Lock("", ACCESS_READ);
     if (lock != NULL) {
       if (NameFromLock(lock, buffer, maximum_length) != DOSFALSE) {
         result = (EIF_POINTER) buffer;
       }
       UnLock(lock);
     }
     return result;
   }

static int simulated_chdir(char *name) {
  int result = -1;
  BPTR lock = Lock(name, ACCESS_READ);
  if (lock != NULL) {
    /* Change the current working directory (CWD) of the task
     */
    BPTR old_lock = CurrentDir(lock);

    /* Attempt to update internal buffer of the process.
       If we are not running in a process, but a plain task, this
       call does not cause any harm.
    */
    /* FIXME: What's the result of SetCurrentDirName() in a plain
       task? If it is FALSE, the below code won't work.
    */
    if (SetCurrentDirName(name)) {
      /* If this was successful, unlock `old_lock' because we
	 are not going to restore it later; this routine is one
	 of the few cases where such behavior is appropriate.
      */
      UnLock(old_lock);
      result = 0;
    }
    else {
      /* If it fails, restore the previous CWD and make the
	 whole routine fail.
      */
      CurrentDir(old_lock);
    }
  }
  return result;
}

static void strip_trailing_slash(char *path, size_t *length,
				 BOOL * stripped) {
  /* Used in `simulated_mkdir' and `simulated_rmdir' to temporarily
     blank out a possible traling slash (/) in the directory path.
     `restore_trailing_slash' puts it back in place afterwards.
  */
  *length = strlen(path);
  if ((*length > 0) && (path[*length - 1] == '/')) {
    *stripped = TRUE;
    path[*length - 1] = '\0';
  } else {
    *stripped = FALSE;
  }
}

static void restore_trailing_slash(char *path, size_t *length,
				   BOOL * stripped) {
  if (*stripped) {
    path[*length - 1] = '/';
  }
}

static int simulated_mkdir(char *directory_path, int permission) {
  BPTR lock;
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;

  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  lock = CreateDir(directory_path);
  if (lock != NULL) {
    UnLock(lock);
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}

static int simulated_rmdir(char *directory_path) {
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;

  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  if (DeleteFile(directory_path)) {
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}
#endif /* AMIGA */

/*--------------------------------------------------------------------
  At his point, either this is a Linux/POSIX platform or some
  SIMULATED_MODE is defined. Unsupported platform should add their own
  SIMULATED_MODE before.
*/

EIF_POINTER directory_open(EIF_POINTER path) {
#ifndef SIMULATED_MODE
  return (opendir(((char*) path)));
#else
  return (simulated_opendir(((char*) path)));
#endif
}

EIF_POINTER directory_read_entry(EIF_POINTER dirstream) {
#ifndef SIMULATED_MODE
  return readdir((DIR*)dirstream);
#else
  return simulated_readdir((SIMULATED_DIR*)dirstream);
#endif
}

EIF_POINTER directory_get_entry_name(EIF_POINTER entry) {
#ifndef SIMULATED_MODE
  return (((struct dirent*)entry)->d_name);
#else
  return simulated_get_entry_name((SIMULATED_DIR*)entry);
#endif
}

EIF_BOOLEAN directory_close(EIF_POINTER dirstream) {
  int status;
#ifndef SIMULATED_MODE
  status = (closedir((DIR*)dirstream) == 0);
#else
  status = (simulated_closedir((SIMULATED_DIR*)dirstream) == 0);
#endif
  return ((EIF_BOOLEAN)(status ? 1 : 0));
}

EIF_POINTER directory_cwd(void) {
  static char* buf = NULL;
#ifdef WIN32
  /* MS Windows requires size to be an int; whereas in non-windows systems,
     it needs to be size_t
  */
  static int size = 0;
#else
  static size_t size = 0;
#endif
  int status;
  if (buf == NULL) {
    size = 256;
    buf = (char*)se_malloc(size);
  }


#ifndef SIMULATED_MODE
  status = (getcwd(buf,size) != NULL);
#else
  status = (simulated_getcwd(buf,size) != NULL);
#endif


  if (status) {
    return buf;
  }
  else {
    free(buf);
    size = size * 2;
    buf = (char*)se_malloc(size);
    return directory_cwd();
  }
}

EIF_BOOLEAN directory_chdir(EIF_POINTER destination) {
  int status;
#ifndef SIMULATED_MODE
  status = (chdir((char*)destination));
#else
  status = simulated_chdir((char*)destination);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN directory_mkdir(EIF_POINTER directory_path){
  int status;
#ifndef SIMULATED_MODE
  status = (mkdir((char*)directory_path,0777));
#else
  status = simulated_mkdir((char*)directory_path,0777);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN directory_rmdir(EIF_POINTER directory_path){
  int status;
#ifndef SIMULATED_MODE
  status = rmdir((char*)directory_path);
#else
  status = simulated_rmdir((char*)directory_path);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_win32
static char* envp(void) {
  static char* result = "\0";/* *** Maybe call GetFullPathName to set =C: and friends */
  return result;
}

EIF_BOOLEAN basic_exec_win32_execute(se_exec_data_t*data, char*args, EIF_BOOLEAN keep_env, char*add_env, HANDLE*in_h, HANDLE*out_h, HANDLE*err_h) {
  STARTUPINFO start_info;
  EIF_BOOLEAN result = 0;

  ZeroMemory( &start_info, sizeof(STARTUPINFO) );

  start_info.cb = sizeof(STARTUPINFO);
  if(in_h) {
    start_info.hStdInput = in_h[0];
    SetHandleInformation(in_h[1], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdInput) goto leave;
  if(out_h) {
    start_info.hStdOutput = out_h[1];
    SetHandleInformation(out_h[0], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdOutput) goto leave;
  if(err_h) {
    start_info.hStdError = err_h[1];
    SetHandleInformation(err_h[0], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdError = GetStdHandle(STD_ERROR_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdError) goto leave;
  start_info.dwFlags |= STARTF_USESTDHANDLES;

  if(CreateProcess(NULL, args,
                   NULL,                                /* process security attributes          */
                   NULL,                                /* primary thread security attributes   */
                   TRUE,                                /* handles are inherited                */
                   0,                                   /* creation flags                       */
                   keep_env?NULL:envp(),
                   NULL,                                /* use parent's current directory       */
                   &start_info,                         /* STARTUPINFO pointer                  */
                   &data->process_information)) {       /* receives PROCESS_INFORMATION         */
    CloseHandle(data->process_information.hThread);
    data->running = 1;
    result = 1;
  }
 leave:
  if(in_h) CloseHandle(in_h[0]);
  if(out_h) CloseHandle(out_h[1]);
  if(err_h) CloseHandle(err_h[1]);
  return result;
}

EIF_BOOLEAN basic_exec_init_pipe(HANDLE*pipe) {
  SECURITY_ATTRIBUTES security_attributes;

  // Set the bInheritHandle flag so pipe handles are inherited.

  security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
  security_attributes.bInheritHandle = TRUE;
  security_attributes.lpSecurityDescriptor = NULL;

  return CreatePipe(pipe, pipe+1, &security_attributes, 0);
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  EIF_BOOLEAN result = (EIF_BOOLEAN)0;
  if (data->running) {
    result = (WaitForSingleObject(data->process_information.hProcess, 0) == WAIT_OBJECT_0);
    if (result) {
      /* child is finished */
      DWORD status;
      GetExitCodeProcess(data->process_information.hProcess, &status);
      /* *** Could have failed */
      basic_exec_cleanup(data, status);
    }
  }
  else{
    result = (EIF_BOOLEAN)1;
  }
  return result;
}

void basic_exec_wait(se_exec_data_t*data) {
  if (data->running) {
    DWORD status;
    WaitForSingleObject(data->process_information.hProcess, INFINITE);
    GetExitCodeProcess(data->process_information.hProcess, &status);
    /* *** Any of these calls could have failed, right? */
    basic_exec_cleanup(data, status);
  }
}

EIF_INTEGER basic_exec_win32_get_character (HANDLE h) {
  char result;
  DWORD num_read;

  ReadFile(h, &result, 1, &num_read, NULL);
  if(!num_read) return -1;
  return result;
}

void basic_exec_win32_put_character(HANDLE h, EIF_CHARACTER c) {
  DWORD num_written;

  WriteFile(h, &c, 1, &num_written, NULL);
  /* *** Do something if num_written!=1 or WriteFile returned 0. */
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
  data->status = status;
  data->running = 0;
  CloseHandle(data->process_information.hProcess);
}

EIF_BOOLEAN basic_exec_win32_wait_any(HANDLE*handles, DWORD count, se_exec_data_t*data) {
  DWORD result = WaitForMultipleObjects(count, handles, FALSE, INFINITE);
  EIF_BOOLEAN success = (result < (WAIT_OBJECT_0 + count));
  if(success) {
    int index = result - WAIT_OBJECT_0;
    HANDLE handle = handles[index];
    GetExitCodeProcess(handle, &data->status);
    data->process_information.hProcess = handle;
  }
  return success;
}

EIF_BOOLEAN basic_exec_win32_any_finished(HANDLE*handles, DWORD count, se_exec_data_t*data ) {
  DWORD result = WaitForMultipleObjects(count, handles, FALSE, 0);
  EIF_BOOLEAN success = (result < (WAIT_OBJECT_0 + count));
  if(success) {
    int index = result - WAIT_OBJECT_0;
    HANDLE handle = handles[index];
    GetExitCodeProcess(handle, &data->status);
    data->process_information.hProcess = handle;
  }
  return success;
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   return -1;
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   return -1;
}
#else
EIF_INTEGER basic_exec_win32_get_character (void *h) {
  return 0;
}

void basic_exec_win32_put_character(void *h, EIF_CHARACTER c) {
}

EIF_BOOLEAN basic_exec_win32_wait_any(void*handles, int count, se_exec_data_t*data) {
  return 0;
}

EIF_BOOLEAN basic_exec_win32_any_finished(void*handles, int count, se_exec_data_t*data) {
  return 0;
}

EIF_BOOLEAN basic_exec_win32_execute(se_exec_data_t*data, char*args, EIF_BOOLEAN keep_env, char*add_env, void*in_h, void*out_h, void*err_h) {
  return 0;
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_posix
static char** envp(void) {
  static char* result[] = {"PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL};
  return result;
}

static int arr_size(char** arr){
  int size = 0;
  while(arr[size] != NULL) {
    size++;
  }
  return size;
}

static int find_variable(char** env, char* var){
  int location;
  int src_size;
  if(var == NULL || env == NULL)
    return -1;
  src_size = strchr(var, '=') - var + 1;
  for(location = 0; env[location] != NULL; location++){
    if(strncasecmp(env[location], var, src_size) == 0){
      return location;
    }
  }
  return -1;
}

static void check_write(int expected, int actual) {
   if (actual != expected) {
    handle(SE_HANDLE_RUNTIME_ERROR, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#elif !defined(SE_BOOST)
    error0("Routine failure: could not write.", NULL);
#else
    fprintf(SE_ERR,"Routine failure (write returned %d but expected %d).\n", actual, expected);
    exit(EXIT_FAILURE);
#endif
  }
}

EIF_BOOLEAN basic_exec_posix_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  int id = fork();
  if (id == 0) {
    /* child */

    if(in_fd) {
      dup2(in_fd[0], 0);
      close(in_fd[1]);
    }

    if(out_fd) {
      dup2(out_fd[1], 1);
      close(out_fd[0]);
    }

    if(err_fd) {
      dup2(err_fd[1], 2);
      close(err_fd[0]);
    }

    if (prog == NULL && args == NULL) {
      data->running = 1;
      data->child = 1;
#ifdef SE_SEDB
      sedb_duplicate();
#endif
      return 1;
    } else {
      if (add_env == NULL && keep_env) {
        execvp(prog, args); /* NO RETURN in child */
        se_print_run_time_stack();
        exit(1);
      }else{
        char** new_env;
        char** old_env;
        int old_size, add_size;
        int src, dest = 0;
        if(keep_env){
          old_env = environ;
        }else{
          old_env = envp();
        }
        old_size = arr_size(old_env);
        add_size = arr_size(add_env);
        new_env = malloc(sizeof(void*) * (old_size + add_size));

        /* we first copy the pointers from the old env */
        for(src = 0; src < old_size; src++){
          new_env[dest++] = old_env[src];
        }

        /* now the ones from add_env */
        for(src = 0; src < add_size; src++){
          int override = find_variable(old_env, add_env[src]);
          if (override >= 0){
            new_env[override] = add_env[src];
          }else{
            new_env[dest++] = add_env[src];
          }
        }

        execve(prog, args, new_env); /* NO RETURN in child */
        se_print_run_time_stack();
        exit(1);
      }
    }
  }
  else if (id > 0) {
    /* father */
    data->id = id;
    data->running = 1;
    data->child = 0;
    if(in_fd) close(in_fd[0]);
    if(out_fd) close(out_fd[1]);
    if(err_fd) close(err_fd[1]);
    return 1;
  } else {
    return 0; /* ... in father only */
  }
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  EIF_BOOLEAN result = (EIF_BOOLEAN)0;
  int status;
  if (data->running) {
    int id = waitpid(data->id, &status, WNOHANG);
    if (id == data->id) {
      /* child is finished */
      result = (EIF_BOOLEAN)(id == data->id);
      basic_exec_cleanup(data, status);
    }
  }
  else{
    result = (EIF_BOOLEAN)1;
  }
  return result;
}

void basic_exec_wait(se_exec_data_t*data) {
  int status;
  if (data->running) {
    int id = waitpid(data->id, &status, 0);
    if (id == data->id) {
      basic_exec_cleanup(data, status);
    }
  }
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
  data->status = WEXITSTATUS(status);
  data->running = 0;
}

EIF_INTEGER basic_exec_posix_get_character (EIF_INTEGER fd) {
  EIF_INTEGER result = -1;
  char buf[1];
  ssize_t r = read(fd, buf, 1);
  if (r > 0) {
    result = 0xff & ((EIF_INTEGER)(buf[0]));
  }
  return result;
}

void basic_exec_posix_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
  char buf[1];
  buf[0] = c;
  check_write(1, write(fd, buf, 1));
}

void basic_exec_posix_wait_any(se_exec_data_t*data) {
  data->id = wait(&data->status);
}

void basic_exec_posix_any_finished(se_exec_data_t*data) {
  data->id = waitpid(-1, &data->status, WNOHANG);
}

/*
 * See http://stackoverflow.com/questions/282176/waitpid-equivalent-with-timeout
 *
 * (with specific adaptation to Liberty Eiffel)
 */
static int waitpid_selfpipe[2];
static EIF_OBJECT waitpid_input;

static void waitpid_sigh(int n) {
   check_write(1, write(waitpid_selfpipe[1], "", 1));
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
   waitpid_input = obj;
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   static init = 0;
   static struct sigaction act;
   if (!init) {
      init = 1;
      if (pipe(waitpid_selfpipe) == -1) {
         waitpid_selfpipe[0] = -1;
      }
      else {
         fcntl(waitpid_selfpipe[0], F_SETFL, fcntl(waitpid_selfpipe[0], F_GETFL) | O_NONBLOCK);
         fcntl(waitpid_selfpipe[1], F_SETFL, fcntl(waitpid_selfpipe[1], F_GETFL) | O_NONBLOCK);
         memset(&act, 0, sizeof(act));
         act.sa_handler = waitpid_sigh;
         sigaction(SIGCHLD, &act, NULL);
      }
   }
   return waitpid_selfpipe[0];
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   static char dummy[4096];
   char *buffer = (char*)data;
   int pid, status;

   while (read(waitpid_selfpipe[0], dummy, sizeof(dummy)) > 0);

   while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
      oob_info(waitpid_input, pid, status);
   }

   buffer[0] = 0;
   return 1;
}
#else
EIF_INTEGER basic_exec_posix_get_character (EIF_INTEGER fd) {
  return 0;
}

void basic_exec_posix_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
}

void basic_exec_posix_wait_any(se_exec_data_t*data) {
}

void basic_exec_posix_any_finished(se_exec_data_t*data) {
}

EIF_BOOLEAN basic_exec_posix_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  return 0;
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_none
/* Dummy implementation that always reports an error back to the Eiffel side */

EIF_BOOLEAN basic_exec_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  return 0;
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  return (EIF_BOOLEAN)0;
}

void basic_exec_wait(se_exec_data_t*data) {
}

EIF_INTEGER basic_exec_get_character (EIF_INTEGER fd) {
  return (EIF_INTEGER)0;
}

void basic_exec_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   return -1;
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   return -1;
}
#else
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
EIF_BOOLEAN mbi_inc (int32_t *p) {
    if ((++(*p)) == 0) {
      return 1;
    }
    else {
      return 0;
    }
}

EIF_BOOLEAN mbi_add (int32_t a, int32_t b, int32_t *p) {
  (*p) = a + b;
  if (((uint32_t)(*p)) < ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_add_with_inc (int32_t a, int32_t b, int32_t *p) {
  (*p) = a + b + 1;
  if (((uint32_t)(*p)) <= ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_dec (int32_t *p) {
    if (((*p)--) == 0) {
      return 1;
    }
    else {
      return 0;
    }
}

EIF_BOOLEAN mbi_subtract (int32_t a, int32_t b, int32_t *p) {
  (*p) = a - b;
  if (((uint32_t)(*p)) > ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_subtract_with_dec (int32_t a, int32_t b, int32_t *p) {
  (*p) = a - b - 1;
  if (((uint32_t)(*p)) >= ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_INTEGER mbi_multiply (int32_t a, int32_t b, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_multiply_with_add (int32_t a, int32_t b, int32_t c, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b)) + ((uint32_t)(c));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_multiply_with_2_add (int32_t a, int32_t b, int32_t c, int32_t d, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b)) + ((uint32_t)(c)) + ((uint32_t)(d));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_divide (int32_t a, int32_t b, int32_t d, int32_t *r) {
  uint64_t x;
  x = (((uint64_t)((uint32_t)(a))) << 32) + ((uint32_t)(b));
  (*r) = (uint32_t)(x % ((uint32_t)(d)));
  return ((uint32_t)(x / ((uint32_t)(d))));
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    size_t dummy = fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/

EIF_INTEGER fstat_st_size(EIF_POINTER path) {

	struct stat buf;
	int test;

	test = stat(path, &buf);
	return (test == 0 ? buf.st_size : -1);

}

EIF_INTEGER_64 fstat_st_mtime(EIF_POINTER path) {

	struct stat buf;
	int test;

	test = stat(path, &buf);
	return (test == 0 ? buf.st_mtime : -1);

}

EIF_BOOLEAN fstat_st_is_file(EIF_POINTER path) {
#if defined S_ISREG
  struct stat buf;

  return stat((const char *)path, &buf)?0:!!S_ISREG(buf.st_mode);
#elif defined WIN32
  EIF_BOOLEAN result;
  HANDLE h=CreateFile((LPCTSTR)path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		      NULL, OPEN_EXISTING, 0, NULL);

  if(INVALID_HANDLE_VALUE == h) {
    return 0;
  }
  result = (GetFileType(h) == FILE_TYPE_DISK)
    && !(GetFileAttributes((LPCTSTR) path) & FILE_ATTRIBUTE_DIRECTORY);
  CloseHandle(h);
  return result;
#else
  printf("fstat_st_is_file (in SmartEiffel/sys/io/c/fstat.c)\nnot yet implemented for this architecture.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

EIF_BOOLEAN fstat_st_is_dir(EIF_POINTER path) {
#if defined S_ISDIR
  struct stat buf;

  return stat((const char *)path, &buf)?0:!!S_ISDIR(buf.st_mode);
#elif defined WIN32
  DWORD attr =GetFileAttributes((LPCTSTR) path);
  return (attr != INVALID_FILE_ATTRIBUTES)  && (attr & FILE_ATTRIBUTE_DIRECTORY);
#else
  printf("fstat_st_is_dir (in SmartEiffel/sys/io/c/fstat.c)\nnot yet implemented for this architecture.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
void sprintf_real_64(EIF_CHARACTER* b, EIF_CHARACTER m, int32_t f, real64_t r) {
  char fmt[32];
  fmt[0]='%';
  fmt[1]='.';
  sprintf(fmt+2, "%d%c", f, m);
  sprintf((char*)b, fmt, r);
}

void sprintf_real_extended(EIF_CHARACTER* b, EIF_CHARACTER m, int32_t f, real_extended_t r) {
  char fmt[32];
  fmt[0]='%';
  fmt[1]='.';
  sprintf(fmt+2, "%dL%c", f, m);
  sprintf((char*)b, fmt, r);
}

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
EIF_INTEGER basic_microsecond_microsecond = 0;
EIF_INTEGER_64 basic_microsecond_time = 0;

void _basic_microsecond_update(void) {
#ifndef WIN32
  struct timeval t;

  gettimeofday (&t, NULL);
  basic_microsecond_time = t.tv_sec;
  basic_microsecond_microsecond = t.tv_usec;
#else
  static DWORD ref_uptime = -1; /* max value as ref_uptime is unsigned */
  static time_t ref_time;
  DWORD uptime;

  /*  uptime = timeGetTime();*/
  uptime = GetTickCount();

  if (uptime < ref_uptime) {
    /* !!! this test manages first call AND 50th day ;-)  */
    ref_uptime = uptime;
    time(&ref_time);
  }

  basic_microsecond_time = ref_time + (uptime - ref_uptime)/1000;
  basic_microsecond_microsecond = ((uptime - ref_uptime) % 1000) * 1000;
#endif
}

int se_cmpT534(T534* o1,T534* o2){
int R=0;
R = R || ((o1->_current_entry) != (o2->_current_entry));
R = R || ((o1->_directory_stream) != (o2->_directory_stream));
return R;
}/*--*/

int se_cmpT345(T345* o1,T345* o2){
int R=0;
R = R || ((o1->_mangling) != (o2->_mangling));
return R;
}/*--*/

int se_cmpT693(T693* o1,T693* o2){
int R=0;
return R;
}/*--*/

int se_cmpT776(T776* o1,T776* o2){
int R=0;
R = R || ((o1->_hashed_string_memory) != (o2->_hashed_string_memory));
R = R || ((o1->_column) != (o2->_column));
R = R || ((o1->_line) != (o2->_line));
return R;
}/*--*/
T1058 M1058=0;
T1062 M1062=0;
T1069 M1069={1069,NULL};
T1070 M1070={1070,NULL};
T1075 M1075=0;

int se_cmpT713(T713* o1,T713* o2){
int R=0;
R = R || ((o1->_time_memory) != (o2->_time_memory));
return R;
}/*--*/

int se_cmpT479(T479* o1,T479* o2){
int R=0;
R = R || ((o1->_microsecond) != (o2->_microsecond));
R = R || se_cmpT713(&(o1->_time), &(o2->_time));
return R;
}/*--*/
T1109 M1109={1109,NULL};
T1160 M1160={1160,NULL};
T1163 M1163={1163,NULL};
T1166 M1166={1166,NULL};

int se_cmpT342(T342* o1,T342* o2){
int R=0;
R = R || ((o1->_hash_code) != (o2->_hash_code));
R = R || ((o1->_feature_name) != (o2->_feature_name));
R = R || ((o1->_class_name) != (o2->_class_name));
return R;
}/*--*/
T1183 M1183={1183,NULL};
T1186 M1186={1186,NULL};
T1191 M1191={1191,NULL};
T1201 M1201={1201,NULL};
T1205 M1205={1205,NULL};

int se_cmpT318(T318* o1,T318* o2){
int R=0;
R = R || ((o1->_item_memory) != (o2->_item_memory));
R = R || ((o1->_capacity) != (o2->_capacity));
return R;
}/*--*/

int se_cmpT530(T530* o1,T530* o2){
int R=0;
R = R || ((o1->_direct_error) != (o2->_direct_error));
R = R || ((o1->_direct_output) != (o2->_direct_output));
R = R || ((o1->_direct_input) != (o2->_direct_input));
R = R || ((o1->_group) != (o2->_group));
R = R || ((o1->_keep_environment) != (o2->_keep_environment));
return R;
}/*--*/
T1227 M1227={1227,NULL};
T1230 M1230={1230,NULL};
T1235 M1235={1235,NULL};
T1236 M1236={1236,NULL};
T1268 M1268={1268,NULL};
T1270 M1270={1270,NULL};
T1279 M1279={1279,NULL};
T1282 M1282={1282,NULL};
T1285 M1285={1285,NULL};
T1290 M1290={1290,NULL};
T1296 M1296={1296,NULL};
T1299 M1299={1299,NULL};
T1308 M1308={1308,NULL};
T1312 M1312={1312,NULL};
T1315 M1315={1315,NULL};
T1316 M1316={1316,NULL};
T1319 M1319={1319,NULL};
T1324 M1324={1324,NULL};
T1328 M1328={1328,NULL};
T1331 M1331={1331,NULL};
T1334 M1334={1334,NULL};
T1339 M1339={1339,NULL};
T1342 M1342={1342,NULL};
T1347 M1347={1347,NULL};
T1348 M1348={1348,NULL};
T1351 M1351={1351,NULL};
T1356 M1356={1356,NULL};
T1370 M1370={1370,NULL};
T1373 M1373={1373,NULL};
T1379 M1379={1379,NULL};
T1383 M1383={1383,NULL};
T1385 M1385={1385,NULL};
T1390 M1390={1390,NULL};
T1393 M1393={1393,NULL};
T1396 M1396={1396,NULL};
T1407 M1407={1407,NULL};
T1414 M1414={1414,NULL};
T1417 M1417=0;
T1421 M1421={1421,NULL};
T1424 M1424={1424,NULL};
T1430 M1430={1430,NULL};
T1440 M1440={1440,NULL};
T1443 M1443={1443,NULL};
T1448 M1448={1448,NULL};
T1453 M1453={1453,NULL};
T1457 M1457=0;

int se_cmpT753(T753* o1,T753* o2){
int R=0;
R = R || ((o1->_first_error_character) != (o2->_first_error_character));
R = R || ((o1->_first_error_index) != (o2->_first_error_index));
R = R || ((o1->_first_error) != (o2->_first_error));
return R;
}/*--*/
T1486 M1486=0;
T1491 M1491={1491,NULL};
T1494 M1494={1494,NULL};
T1497 M1497={1497,NULL};
T1498 M1498={1498,NULL};
T1501 M1501={1501,NULL};
T1511 M1511={1511,NULL};
T1516 M1516=0;
T1530 M1530=0;
T1538 M1538=0;
T1555 M1555={1555,NULL};
T1587 M1587=0;
T1591 M1591={1591,NULL};
T29 M29={(void*)0,0,0};
T290 M290=0;
T111 M111={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,{(void*)0,(void*)0},(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T124 M124={(void*)0,(void*)0,(void*)0,0,0};
T998 M998=(void*)0;
T102 M102={(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,(void*)0,(void*)0,0,0,0,0,{(void*)0,0,0},0,0,0,(void*)0,(void*)0,'\0',(void*)0,0,0};
T277 M277={0,(void*)0,(void*)0,0,0,0,0,0,0,0,0,0,0,0,0,(void*)0,(void*)0,(void*)0,{(void*)0,0,0},0,0,0,(void*)0,'\0',(void*)0,0,0};
T115 M115={(void*)0,(void*)0,0,(void*)0,0,(void*)0,0,0,0,0,0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0};
T109 M109={0,(void*)0,0,(void*)0,0,0,0,0,0,0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0};
T285 M285={0,0};
T275 M275=(void*)0;
T291 M291=0;
T7 M7={7,0,0,0,0,(void*)0,0};
T1027 M1027={1027,0,0,(void*)0,0};
T287 M287={(void*)0,0,0,0,0,0};
T85 M85={(void*)0,0};
T1028 M1028={(void*)0};
T289 M289=0;
T543 M543=0;
T534 M534={(void*)0,(void*)0};
T77 M77={77};
T1029 M1029={1029,(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T546 M546={546,(void*)0,(void*)0};
T550 M550={550,(void*)0,(void*)0};
T551 M551={551};
T552 M552={552};
T553 M553={553};
T554 M554={554};
T1030 M1030={(void*)0};
T1031 M1031={0};
T100 M100={0,0,0,0,(void*)0,(void*)0,'\0',0,(void*)0,(void*)0};
T545 M545={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T533 M533=0;
T457 M457={457,(void*)0,0,0,(void*)0,0,(void*)0,(void*)0};
T652 M652={652,(void*)0};
T80 M80={80,(void*)0};
T68 M68={68,0,(void*)0,0,(void*)0};
T458 M458={458,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1032 M1032={0,0,(void*)0,0};
T104 M104={0,(void*)0};
T121 M121={(void*)0,0,(void*)0,(void*)0};
T694 M694={694,(void*)0,(void*)0,0};
T698 M698={698,0,(void*)0,(void*)0,0,(void*)0,(void*)0,0};
T696 M696={696,0,(void*)0,(void*)0,0};
T555 M555={(void*)0,0,0,(void*)0,(void*)0,{(void*)0,(void*)0}};
T690 M690={690,(void*)0,{(void*)0,(void*)0},0,(void*)0};
T345 M345={0};
T430 M430={430,(void*)0,{0},0};
T1033 M1033={1033,0,0,0,(void*)0,0};
T327 M327={(void*)0,(void*)0,0,0,(void*)0,0};
T693 M693={0};
T1034 M1034={0,0,(void*)0,0};
T440 M440={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,'\0',0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T776 M776={(void*)0,0,0};
T577 M577={577,(void*)0};
T610 M610={610,(void*)0};
T611 M611={611,(void*)0};
T612 M612={612,(void*)0};
T613 M613={613,(void*)0};
T625 M625={625};
T626 M626={626};
T627 M627={627,(void*)0,(void*)0};
T629 M629={629,(void*)0};
T630 M630={630,(void*)0};
T634 M634={634,0,(void*)0,(void*)0,(void*)0};
T635 M635={635,(void*)0,(void*)0,(void*)0,(void*)0};
T636 M636={636,(void*)0,(void*)0,(void*)0,(void*)0};
T637 M637={637,(void*)0,(void*)0,(void*)0};
T638 M638={638,0};
T639 M639={639,0};
T640 M640={640};
T642 M642={642};
T641 M641={641};
T643 M643={643};
T644 M644={644,0};
T645 M645={645,(void*)0,(void*)0,0};
T1035 M1035={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1036 M1036={0,0,(void*)0,0};
T376 M376={376,(void*)0,(void*)0,(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T96 M96={96,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0};
T94 M94={0,(void*)0,0,0,(void*)0,(void*)0,{0}};
T280 M280={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T88 M88={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T542 M542={(void*)0,{0,{0}},0,0,(void*)0,0,0};
T1038 M1038={0,0,0,(void*)0,0};
T335 M335={0,(void*)0,0,(void*)0};
T108 M108=(void*)0;
T106 M106={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0};
T114 M114=(void*)0;
T123 M123=(void*)0;
T122 M122={0};
T125 M125=(void*)0;
T90 M90={(void*)0,{0},{0},0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T445 M445={445,(void*)0,0,(void*)0};
T1040 M1040={0,0,0,(void*)0,0};
T1041 M1041={(void*)0,0,0,0,(void*)0,0};
T1042 M1042={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1043 M1043={0,0,(void*)0,0};
T300 M300={300,(void*)0,(void*)0,0,0,0,0,0,0,(void*)0};
T1044 M1044={(void*)0,0,0,0,(void*)0,0};
T118 M118={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0};
T284 M284={(void*)0,{0},0};
T434 M434={434,(void*)0,0,(void*)0};
T1047 M1047={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T576 M576=0;
T1048 M1048={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1049 M1049={(void*)0,0,0,0,(void*)0,0};
T1050 M1050={0};
T714 M714={714,0};
T715 M715={715,(void*)0,(void*)0,(void*)0,0};
T716 M716={716,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T312 M312={312,(void*)0,(void*)0,(void*)0,(void*)0};
T540 M540={(void*)0,(void*)0};
T1053 M1053={0,0,(void*)0,0};
T1054 M1054={(void*)0,0,0,0,(void*)0,0};
T1055 M1055={0,0,(void*)0,0};
T707 M707={707,(void*)0};
T1056 M1056={0,0,0,0,(void*)0,0};
T706 M706={0,(void*)0,(void*)0};
T1057 M1057={0,0,(void*)0,0};
T334 M334={(void*)0,(void*)0,(void*)0};
T1061 M1061={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T793 M793=0;
T790 M790={790,(void*)0};
T792 M792={792,0,(void*)0,(void*)0};
T1063 M1063={0,0,(void*)0,0};
T1064 M1064={(void*)0};
T58 M58={0,(void*)0,{(void*)0,0}};
T791 M791={791,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1065 M1065={(void*)0,(void*)0,(void*)0};
T1071 M1071={(void*)0,(void*)0,(void*)0};
T1072 M1072={(void*)0,0,0,0,(void*)0,0};
T79 M79=0;
T1073 M1073={0,0,(void*)0,0};
T1077 M1077={0,0,(void*)0,0};
T105 M105={(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,(void*)0,{(void*)0,0,0},0,0,0,(void*)0,(void*)0,'\0',(void*)0,0,0};
T1080 M1080={0,0,(void*)0,0};
T769 M769={769,(void*)0,(void*)0,(void*)0,(void*)0,{(void*)0,(void*)0},0,(void*)0};
T808 M808={808,(void*)0,(void*)0,(void*)0,{(void*)0,(void*)0},0,(void*)0};
T1082 M1082={(void*)0,0,0,0,(void*)0,0};
T1084 M1084={(void*)0,0,0,0,(void*)0,0};
T1086 M1086={(void*)0,0,0,0,(void*)0,0};
T1088 M1088={(void*)0,0,0,0,(void*)0,0};
T771 M771={(void*)0,(void*)0};
T479 M479={0,{0}};
T1091 M1091={0,0,0,0,(void*)0,0};
T361 M361={361,(void*)0,(void*)0};
T1092 M1092={0,0,0,0,(void*)0,0};
T400 M400={400,(void*)0,(void*)0};
T1093 M1093={0,0,(void*)0,0};
T455 M455={(void*)0,(void*)0,0,0,{0},(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T426 M426={(void*)0,(void*)0,(void*)0};
T388 M388={388,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,{0}};
T432 M432={0,(void*)0,{0}};
T433 M433={0,(void*)0,(void*)0};
T493 M493={493,0,(void*)0,(void*)0,0,(void*)0,0,(void*)0};
T502 M502={502,{0},0,(void*)0};
T504 M504={504,(void*)0,(void*)0,(void*)0,(void*)0,{0},0,(void*)0};
T119 M119={0,0};
T505 M505={505,0,(void*)0,(void*)0,(void*)0,{0},0,(void*)0};
T451 M451={451,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T416 M416={416,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T468 M468={468,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T389 M389={389,(void*)0,0,(void*)0};
T443 M443={443,(void*)0,0,(void*)0};
T415 M415={415,0,(void*)0,(void*)0,0,(void*)0};
T441 M441={441,0,(void*)0,(void*)0,0,(void*)0};
T411 M411={411,(void*)0,(void*)0,(void*)0,0,(void*)0};
T444 M444={444,(void*)0,0,(void*)0};
T442 M442={442,0,(void*)0,(void*)0,0,(void*)0};
T448 M448={448,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T446 M446={446,(void*)0,(void*)0,0,(void*)0};
T449 M449={449,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T452 M452={452,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T276 M276={0,0,(void*)0,(void*)0};
T474 M474={474,(void*)0};
T476 M476={476,(void*)0,0,(void*)0,(void*)0,(void*)0};
T477 M477={477,(void*)0,(void*)0,(void*)0};
T478 M478={478,0,(void*)0,0,(void*)0,(void*)0,(void*)0,0,0,0,(void*)0};
T431 M431={(void*)0,(void*)0,{0},(void*)0,(void*)0};
T1094 M1094={0,0,(void*)0,0};
T283 M283={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0};
T485 M485={(void*)0,(void*)0};
T1095 M1095={0,0,(void*)0,0};
T526 M526={526,(void*)0,{0}};
T495 M495={495,(void*)0,0,(void*)0,(void*)0,(void*)0};
T409 M409={409,(void*)0,(void*)0,(void*)0};
T481 M481={481,(void*)0,0,(void*)0,{0}};
T379 M379={379,(void*)0,(void*)0,0,0,{0}};
T482 M482={482,(void*)0,(void*)0,(void*)0,{0}};
T483 M483={483,{0},(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,{0}};
T346 M346={(void*)0,(void*)0};
T355 M355={355,(void*)0,0,(void*)0,(void*)0,(void*)0};
T358 M358={358,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T360 M360={360,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T349 M349={349,(void*)0,(void*)0,(void*)0,(void*)0,0};
T353 M353={353,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T354 M354={354,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T497 M497={497,(void*)0,0,(void*)0,(void*)0,(void*)0};
T498 M498={498,(void*)0,0,(void*)0,(void*)0,(void*)0};
T499 M499={499,(void*)0,0,(void*)0,(void*)0,(void*)0};
T487 M487={487,(void*)0,(void*)0,{0}};
T393 M393={393,{0}};
T462 M462={462,{0}};
T469 M469={469,(void*)0,'\0',{0}};
T488 M488={488,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T523 M523={523,(void*)0,(void*)0,{0}};
T524 M524={524,0,(void*)0,(void*)0,(void*)0,{0}};
T1096 M1096={0,0,(void*)0,0};
T1097 M1097={1097,0,0,0,(void*)0,0};
T459 M459={459,(void*)0,0,(void*)0,(void*)0,(void*)0,{0}};
T460 M460={460,(void*)0};
T1098 M1098={1098,0,0,0,(void*)0,0};
T399 M399={399,(void*)0};
T1099 M1099={0,0,0,(void*)0,0};
T672 M672={672,(void*)0,(void*)0,0,0};
T1100 M1100={0,0,(void*)0,0};
T428 M428={428,(void*)0,(void*)0,(void*)0,(void*)0};
T1101 M1101={1101,0,0,0,(void*)0,0};
T396 M396={396,0,0,(void*)0,0,(void*)0,(void*)0,(void*)0,{0}};
T454 M454={(void*)0,(void*)0};
T525 M525={525,(void*)0,(void*)0,0};
T1102 M1102={0,0,(void*)0,0};
T484 M484={484,(void*)0,(void*)0,{0},0};
T420 M420={420,(void*)0,(void*)0,{0},0};
T406 M406={406,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T1103 M1103={0,0,(void*)0,0};
T364 M364={364,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T377 M377={377,(void*)0,{0}};
T369 M369={369,(void*)0,(void*)0,(void*)0,(void*)0,{0},(void*)0,(void*)0,{0},0};
T486 M486={486,(void*)0,(void*)0,(void*)0,(void*)0,{0},(void*)0,(void*)0,{0},0};
T436 M436={436,(void*)0,(void*)0,{0},0};
T472 M472={472,(void*)0,(void*)0,(void*)0,(void*)0};
T473 M473={473,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T371 M371={371,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T412 M412={412,0,(void*)0,(void*)0,(void*)0,{0},0};
T470 M470={470,(void*)0,{0},(void*)0,0,0};
T501 M501={501,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T491 M491={491,(void*)0,{0}};
T374 M374={374,(void*)0,(void*)0,0};
T402 M402={402,0,(void*)0,(void*)0,0};
T471 M471={471,(void*)0,(void*)0,0};
T465 M465={465,{0},0};
T403 M403={403,(void*)0,0};
T668 M668={668,0,(void*)0,(void*)0,{0},0};
T490 M490={490,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T463 M463={463,(void*)0,(void*)0};
T404 M404={404,{0}};
T500 M500={500,(void*)0,{0},(void*)0};
T522 M522={522,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T521 M521={521,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T517 M517={517,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T518 M518={518,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T519 M519={519,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T520 M520={520,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T516 M516={516,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T382 M382={382,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T405 M405={405,(void*)0,(void*)0,{0},0};
T512 M512={512,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T513 M513={513,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T514 M514={514,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T515 M515={515,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T410 M410={410,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T511 M511={511,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T508 M508={508,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T509 M509={509,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T510 M510={510,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T507 M507={507,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T464 M464={464,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T506 M506={506,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T492 M492={(void*)0,(void*)0};
T286 M286={(void*)0,(void*)0,{0}};
T467 M467={(void*)0,(void*)0,(void*)0,{0}};
T466 M466={(void*)0,(void*)0};
T1106 M1106={0,0,0,(void*)0,0};
T429 M429={(void*)0,(void*)0,(void*)0,{0}};
T439 M439={(void*)0,(void*)0,(void*)0,(void*)0};
T770 M770={(void*)0,(void*)0,(void*)0};
T461 M461={{0},(void*)0};
T365 M365={365,(void*)0,(void*)0,0,0,0,{0}};
T418 M418={418,(void*)0,(void*)0,(void*)0,(void*)0};
T401 M401={401,(void*)0,(void*)0,(void*)0,0,0,0,{0}};
T1107 M1107={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T1108 M1108={0,0,(void*)0,0};
T1110 M1110={(void*)0,(void*)0,(void*)0};
T1113 M1113={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1114 M1114={0,0,0,(void*)0,0};
T1116 M1116={0,0,(void*)0,0};
T689 M689={689,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T435 M435={435,(void*)0,(void*)0,{0},0};
T1117 M1117={0,0,(void*)0,0};
T1122 M1122={0,0,(void*)0,0};
T1123 M1123={(void*)0,0,0,0,(void*)0,0};
T456 M456={(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1124 M1124={(void*)0,0,0,0,(void*)0,0};
T438 M438={(void*)0};
T453 M453={(void*)0};
T1125 M1125={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1126 M1126={(void*)0,0,0,0,(void*)0,0};
T1129 M1129={0,0,(void*)0,0};
T1130 M1130={(void*)0,0,(void*)0,0,0,(void*)0,(void*)0,0,0};
T1133 M1133={(void*)0,0,0,0,(void*)0,0};
T1134 M1134={0,0,(void*)0,0};
T1135 M1135={0,0,(void*)0,0};
T1136 M1136={0,0,(void*)0,0};
T1138 M1138={0,0,(void*)0,0};
T1139 M1139={0,0,(void*)0,0};
T1140 M1140={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T531 M531={(void*)0,0,(void*)0};
T1142 M1142={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T1146 M1146={(void*)0,0,0,0,(void*)0,0};
T1147 M1147={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1148 M1148={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1149 M1149={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T1150 M1150={0,0,(void*)0,0};
T535 M535={535,(void*)0,(void*)0,(void*)0};
T1151 M1151={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1152 M1152={0,0,(void*)0,0};
T570 M570={(void*)0,(void*)0};
T1154 M1154={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T1155 M1155={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1156 M1156={0,0,(void*)0,0};
T408 M408={408,(void*)0,0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1158 M1158={(void*)0,(void*)0,(void*)0};
T1161 M1161={(void*)0,(void*)0,(void*)0};
T1164 M1164={0,0,(void*)0,0};
T1167 M1167={(void*)0,(void*)0,(void*)0};
T1169 M1169={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1170 M1170={0,0,(void*)0,0};
T647 M647={0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1171 M1171={(void*)0,0,0,0,(void*)0,0};
T1172 M1172={0,0,0,0,(void*)0,0};
T1173 M1173={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T342 M342={0,(void*)0,(void*)0};
T1174 M1174={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1179 M1179={(void*)0,0,0,0,(void*)0,0};
T1180 M1180={0,0,0,(void*)0,0};
T1181 M1181={0,0,0,(void*)0,0};
T1182 M1182={0,0,(void*)0,0};
T1184 M1184={(void*)0,(void*)0,(void*)0};
T1187 M1187={(void*)0,(void*)0,0};
T1190 M1190={(void*)0,(void*)0};
T1194 M1194={(void*)0,0,0,0,(void*)0,0};
T827 M827={827,(void*)0,(void*)0,(void*)0};
T828 M828=(void*)0;
T829 M829={829,(void*)0,(void*)0,(void*)0};
T830 M830={830};
T832 M832={832,(void*)0,(void*)0,(void*)0};
T833 M833={833};
T834 M834={834};
T835 M835={835,0};
T1195 M1195={0,0,(void*)0,0};
T1196 M1196={(void*)0,0,(void*)0,(void*)0,0,(void*)0,0,0};
T1200 M1200={(void*)0,0,(void*)0};
T1204 M1204={0,0,(void*)0,0};
T572 M572={(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1206 M1206={(void*)0,(void*)0,(void*)0};
T1208 M1208={(void*)0};
T1210 M1210={0,0,0,0,(void*)0,0};
T1211 M1211={0,0,(void*)0,0};
T318 M318={(void*)0,0};
T733 M733=0;
T1213 M1213={(void*)0,0,0,0,(void*)0,0};
T1216 M1216={0,0,0,0,(void*)0,0};
T1220 M1220={(void*)0,(void*)0,0,0,0,(void*)0,0};
T1221 M1221={1221,(void*)0,(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T530 M530={0,0,0,(void*)0,0};
T1223 M1223={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T795 M795={795,(void*)0};
T1225 M1225={0,0,(void*)0,0};
T1226 M1226={(void*)0,0,0,0,(void*)0,0};
T1228 M1228={(void*)0,(void*)0,(void*)0};
T1231 M1231={(void*)0,(void*)0,(void*)0};
T1234 M1234={(void*)0,(void*)0};
T1237 M1237={(void*)0,(void*)0,0};
T1239 M1239={(void*)0,0,0,0,(void*)0,0};
T713 M713={0};
T687 M687={687,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T684 M684={684,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T573 M573={573,(void*)0,(void*)0,0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T688 M688={688,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T681 M681={681,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T674 M674={674,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T677 M677={677,0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T679 M679={679,0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T686 M686={686,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T680 M680={680,(void*)0,0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T676 M676={676,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T678 M678={678,0,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T685 M685={685,(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T425 M425={(void*)0};
T1243 M1243={0,0,0,(void*)0,0};
T1244 M1244={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1245 M1245={(void*)0,0,0,0,(void*)0,0};
T700 M700={(void*)0};
T1252 M1252={0,0,(void*)0,0};
T1256 M1256={0,0,(void*)0,0};
T749 M749={749,(void*)0,(void*)0,(void*)0,(void*)0};
T1258 M1258={0,0,(void*)0,0};
T387 M387={387,(void*)0,(void*)0};
T661 M661={661,(void*)0};
T663 M663={663,(void*)0,(void*)0,(void*)0};
T1259 M1259={0,0,(void*)0,0};
T1260 M1260={0,0,(void*)0,0};
T664 M664={664,0,(void*)0,0,(void*)0,{0}};
T1261 M1261={0,0,(void*)0,0};
T1262 M1262={0,0,(void*)0,0};
T1263 M1263={(void*)0,0,0,0,(void*)0,0};
T1267 M1267={(void*)0,(void*)0};
T1271 M1271={(void*)0,(void*)0,(void*)0};
T1278 M1278={(void*)0,(void*)0,0};
T1281 M1281={(void*)0,(void*)0,(void*)0};
T1283 M1283={0,0,(void*)0,0};
T1284 M1284={0,0,(void*)0,0};
T1286 M1286={(void*)0,(void*)0,(void*)0};
T1289 M1289={(void*)0,(void*)0,0};
T1294 M1294={(void*)0,(void*)0,(void*)0,(void*)0};
T1297 M1297={(void*)0,0,0,0,(void*)0,0};
T1300 M1300={(void*)0,(void*)0,(void*)0};
T1306 M1306={(void*)0,(void*)0,(void*)0};
T1311 M1311={(void*)0,(void*)0};
T1314 M1314={(void*)0,(void*)0};
T1317 M1317={(void*)0,(void*)0,(void*)0};
T1320 M1320={(void*)0,(void*)0,(void*)0};
T1323 M1323={(void*)0,(void*)0};
T1326 M1326={(void*)0,(void*)0,(void*)0};
T1330 M1330={(void*)0,(void*)0};
T1332 M1332={(void*)0,(void*)0,(void*)0};
T421 M421={421,(void*)0,0};
T750 M750={0,{0},(void*)0,(void*)0};
T1338 M1338={(void*)0,(void*)0,(void*)0};
T1343 M1343={(void*)0,(void*)0,(void*)0};
T1346 M1346={(void*)0,{0,(void*)0,(void*)0}};
T1349 M1349={(void*)0,{0,(void*)0,(void*)0},(void*)0};
T1352 M1352={(void*)0,(void*)0,(void*)0};
T1357 M1357={(void*)0,(void*)0,(void*)0};
T1359 M1359={0,0,(void*)0,0};
T414 M414={414,(void*)0,(void*)0,0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1361 M1361={0,0,(void*)0,0};
T1362 M1362={0,(void*)0,(void*)0,(void*)0,0};
T1363 M1363={1363,0,0,(void*)0,0};
T1364 M1364={(void*)0,0,0,0,(void*)0,0};
T363 M363={363,0,{0},(void*)0,(void*)0};
T1367 M1367={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T1371 M1371={(void*)0,(void*)0,(void*)0};
T1376 M1376={(void*)0,(void*)0,(void*)0};
T1377 M1377={1377,0,0,(void*)0};
T787 M787={787,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0};
T788 M788={788,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0};
T789 M789={789,(void*)0,0,0,0};
T784 M784={784,(void*)0,(void*)0};
T785 M785={785,(void*)0,0,(void*)0};
T786 M786={786};
T1381 M1381={(void*)0,(void*)0,(void*)0};
T1386 M1386={(void*)0,(void*)0,(void*)0};
T1389 M1389={(void*)0,(void*)0,(void*)0};
T1391 M1391={0,0,(void*)0,0};
T1394 M1394={(void*)0,(void*)0,(void*)0};
T1397 M1397={(void*)0,(void*)0,(void*)0};
T1399 M1399={0,0,(void*)0,0};
T1405 M1405={(void*)0,0,0,0,(void*)0,0};
T1408 M1408={(void*)0,(void*)0,(void*)0};
T1413 M1413={(void*)0,(void*)0,(void*)0};
T851 M851={(void*)0,(void*)0,(void*)0,0,0,0,0};
T1420 M1420={(void*)0,(void*)0,(void*)0};
T1423 M1423={(void*)0,(void*)0};
T1425 M1425={0,0,0,0,(void*)0,0};
T1426 M1426={(void*)0,0,0,0,(void*)0,0};
T1427 M1427={(void*)0,0,0,0,(void*)0,0};
T1431 M1431={(void*)0,(void*)0,(void*)0};
T344 M344={0};
T1433 M1433={0,(void*)0,0,(void*)0,0,0,(void*)0,0,0};
T1435 M1435={(void*)0,(void*)0,0,(void*)0,(void*)0,0,0};
T1436 M1436={0,'\0'};
T1437 M1437={0,0,(void*)0,0};
T1438 M1438={(void*)0,0,(void*)0};
T1441 M1441={(void*)0,0,(void*)0};
T1444 M1444={0,0,(void*)0,0};
T1445 M1445={0,0,0,(void*)0,(void*)0,0};
T1449 M1449={(void*)0,(void*)0};
T1450 M1450={(void*)0,0,0,0,(void*)0,0};
T1454 M1454={(void*)0,(void*)0,(void*)0};
T60 M60={0,(void*)0,(void*)0};
T797 M797={797,0,(void*)0,'\0',(void*)0};
T753 M753={0,0,(void*)0};
T670 M670={670,'\0',{0},0};
T1461 M1461={(void*)0,0,0,0,(void*)0,0};
T1462 M1462={(void*)0,(void*)0};
T1463 M1463={(void*)0,0,0,0,(void*)0,0};
T1464 M1464={(void*)0,0,0,0,(void*)0,0,(void*)0,0};
T1466 M1466={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T1469 M1469={(void*)0,0,(void*)0,0,0,0,(void*)0,0};
T655 M655={655,(void*)0,(void*)0};
T659 M659={659,(void*)0,(void*)0,(void*)0};
T658 M658={658,(void*)0,(void*)0};
T569 M569={569,(void*)0,(void*)0,{0}};
T660 M660={660,(void*)0};
T657 M657={657,(void*)0,0,(void*)0,{0},(void*)0};
T669 M669={669,(void*)0,0};
T653 M653={653,(void*)0,(void*)0,0,0,{0}};
T654 M654={654,(void*)0,{0}};
T671 M671={671,0,(void*)0,{0},0,0};
T336 M336=0;
T1470 M1470={0,0,(void*)0,0};
T1471 M1471={(void*)0,0,(void*)0,{0},0,(void*)0,0,0};
T532 M532={532,(void*)0,(void*)0,(void*)0};
T1472 M1472={0,0,(void*)0,0};
T665 M665={665,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T567 M567={567,(void*)0,(void*)0,{0},0};
T673 M673={673,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0};
T1473 M1473={(void*)0};
T1474 M1474={0,0,(void*)0,0};
T1475 M1475={0,0,(void*)0,0};
T314 M314=0;
T1476 M1476={(void*)0,0,0,0,(void*)0,0};
T1477 M1477={0,0,(void*)0,0};
T1483 M1483={0,0,(void*)0,0};
T537 M537={(void*)0};
T126 M126={126,0,0};
T751 M751={751,0,(void*)0,(void*)0};
T756 M756={756,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T120 M120={0};
T1485 M1485={0,0,0,(void*)0,0};
T422 M422={422,(void*)0,0,(void*)0,(void*)0,(void*)0};
T419 M419={419,0,(void*)0,(void*)0,(void*)0,{0},0};
T373 M373={373,'\0',(void*)0,{0}};
T805 M805={805,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T650 M650={650,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T803 M803={803,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T757 M757={757,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T656 M656={656,{0},(void*)0,(void*)0,(void*)0};
T541 M541={541,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T804 M804={804,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T649 M649={649,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,(void*)0,(void*)0,(void*)0};
T1487 M1487={0,0,(void*)0,0};
T853 M853={853,(void*)0,0,0,(void*)0};
T855 M855={855,(void*)0,0,'\0','\0',0,0,0,0,(void*)0};
T856 M856={856,(void*)0,(void*)0,0,(void*)0};
T857 M857={857,(void*)0,(void*)0,'\0','\0',0,0,0,0,(void*)0};
T1488 M1488={1488,0,0,(void*)0,0};
T1490 M1490={(void*)0,(void*)0,(void*)0};
T1492 M1492={(void*)0,(void*)0,(void*)0};
T1496 M1496={(void*)0,(void*)0};
T1499 M1499={(void*)0,(void*)0,(void*)0};
T1502 M1502={(void*)0,(void*)0,(void*)0};
T1504 M1504={0,0,(void*)0,0};
T1505 M1505={0,{0},(void*)0,(void*)0,0};
T1506 M1506={1506,0,0,(void*)0,0};
T662 M662={662,(void*)0,{0}};
T724 M724={724,0};
T1510 M1510={(void*)0,(void*)0};
T999 M999={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0,0,{(void*)0,(void*)0},(void*)0,(void*)0,0};
T566 M566={(void*)0,(void*)0,0,0};
T646 M646={0};
T1519 M1519={0,0,(void*)0,0};
T1522 M1522={0,0,0,(void*)0,0};
T560 M560={560,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T561 M561={561,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T562 M562={562,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T563 M563={563,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T564 M564={564,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T565 M565={565,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1537 M1537={1537,0,0,(void*)0};
T810 M810={810,0,0};
T1539 M1539={0,0,0,(void*)0,0};
T1545 M1545={0,0,(void*)0,0};
T826 M826={826,0};
T1547 M1547={(void*)0,0,0,0,(void*)0,0};
T1548 M1548={0,0,(void*)0,0};
T729 M729={0,0,0,0,(void*)0};
T1549 M1549={0,0,(void*)0,0};
T1553 M1553={(void*)0,(void*)0,(void*)0};
T726 M726={726,(void*)0,0,0};
T1584 M1584={0,0,(void*)0,0};
T802 M802={802,(void*)0};
T1585 M1585={(void*)0,0,0,0,(void*)0,0};
T800 M800={800,0};
T1588 M1588={0,0,(void*)0,0};
T1590 M1590={(void*)0,0,(void*)0};
/*Aliased storage area or unicode storage.*/
char*s352_1195446850A=". (See the next error report for details.)";
char*s111_0A="";
char*s115_1418906530A="void se_msi";
char*s33_424424A="low_16";
char*s635_25969530A=",a1ptr->_";
char*s119_9A="\011""";
char*s109_10A="\n";
char*s33_424430A="low_32";
char*s374_1114345928A="Void cannot be assigned to an expanded entity.";
char*s647_1983193131A="To fix this ambiguous Precursor call you have to remove direct repeated inheritance. You may thus consider to add a new class which inherit ";
char*s30_199827552A=": level is already set to ";
char*s115_1564992795A="int se_general_trace_switch";
char*s635_59375621A="Class NATIVE_ARRAY has been tampered with. Unknown function: ";
char*s115_1772404517A="&local_profile,";
char*s102_1078639380A="Expression expected after \'implies\'.";
char*s429_772854717A="Feature `manifest_put\' must be a procedure.";
char*s102_1138390195A="Prefix operator name expected.";
char*s115_523400916A="Precomputed once function";
char*s102_393689A="bottom";
char*s471_218994080A="Replacing assign to \173""";
char*s115_12331A="NULL";
char*s613_5794275A="=(u->CL_";
char*s716_1880914324A="gc_agent*gcu=(gc_agent*)u;\nif (gcu->header.flag==FSOH_UNMARKED)\173""\ngcu->header.flag=FSOH_MARKED;\n";
char*s102_34A="\"";
char*s716_1607908341A="Adding SmartEiffel Garbage Collector.\n";
char*s33_38A="&";
char*s115_40A="(";
char*s115_41A=")";
char*s628_7233618A="INT8_MIN";
char*s33_42A="*";
char*s33_43A="+";
char*s115_44A=",";
char*s115_36951A="(T0*)";
char*s33_45A="-";
char*s458_46A=".";
char*s33_47A="/";
char*s626_48A="0";
char*s124_1071750288A="SmallEiffel";
char*s29_1889925553A="compile_to_c";
char*s418_532898088A=" See also the next message for more information.";
char*s613_1664036235A="set_dump_stack_top(caller);/*unlink*/\nreturn C;\n";
char*s476_58A=":";
char*s613_1023028228A=";\nu->afp=afp_";
char*s636_59A=";";
char*s119_60A="\n\n";
char*s33_60A="<";
char*s33_61A="=";
char*s635_2017590A="floor((";
char*s829_1752899740A="GC_REGISTER_FINALIZER_NO_ORDER(R, bdw_finalizeT";
char*s33_62A=">";
char*s30_63A="\?";
char*s791_1883030297A=" (discarded)\n";
char*s33_64A="@";
char*s105_1684808173A="Invalid empty file";
char*s638_1216329562A="if (!strcmp(attr,\"";
char*s102_67A="C";
char*s102_1268871407A="Bad inline agent definition (\"do...end\" routine body expected).";
char*s635_219498506A="Unknown \"$";
char*s30_1202957293A=": missing file path name after -output_error_warning_on flag.\n";
char*s34_212160365A="require_check";
char*s630_80037A="else ";
char*s33_12376A="REAL";
char*s118_325166540A="Can\'t join these two concrete features. What\'s called a concrete feature here is a feature which is not deferred. You may consider to undefine one feature or to add a redefine.";
char*s115_77A="M";
char*s430_77A="\011"" ";
char*s808_79A="\011""\"";
char*s115_1206795525A="c_plus_plus";
char*s115_441192857A="initialize_eiffel_runtime(argc,argv);\n";
char*s613_82A="R";
char*s542_251231528A="generating";
char*s115_1645835456A=");\nimax=argc";
char*s638_84A="T";
char*s115_2189840A="se_ums(";
char*s113_301485A="Cygwin";
char*s115_392938270A="init_profile(agent_profile+";
char*s613_585895143A="(se_dump_stack*caller,";
char*s628_91A="[";
char*s115_93A="]";
char*s33_94A="^";
char*s33_251231540A="generation";
char*s102_916596A=" items.";
char*s808_2008215484A=" (not in a loadpath)";
char*s111_99A="c";
char*s832_101A="e";
char*s277_376816512A="external_header_path";
char*s111_273430505A="return 0;\n";
char*s30_104A="h";
char*s630_105A="i";
char*s111_109A="m";
char*s440_178490A=" class";
char*s33_112335826A="signal_number";
char*s115_114A="r";
char*s96_772983982A="Problem with undefine of \"";
char*s566_1399364920A="/*auto-unlock tmp";
char*s30_118A="v";
char*s483_123A="\173""";
char*s33_124A="\174""";
char*s33_126A="\176""";
char*s115_273430530A="return 1;\n";
char*s115_391886489A="])(FILE*,void*)";
char*s543_876265439A="/lang/eiffel/.liberty-eiffel";
char*s714_6284A="(((T";
char*s370_1485085274A="..... unique buffer 1 .....";
char*s402_1089483711A=" must not be expanded. (";
char*s635_579867211A="(T6)(C==a1)";
char*s102_629850238A="An expression has a result value. This is not an instruction.";
char*s115_1629400044A="#define SE_BOOST 1\n";
char*s33_80109A="fifth";
char*s630_252339A="=NULL;";
char*s118_612971904A="\n\nSecond \"insert\" path (from parent to child):\n   ";
char*s440_202915491A="Same class name appears twice.";
char*s400_446205995A="Same local name appears twice in this \"local\" variable list.";
char*s630_6305A=")&&(";
char*s102_280897875A=" for the left-hand side of an assignment.";
char*s408_1324593410A="Overflow of infix \"*\" with INTEGER_32 operands. (";
char*s34_1473988901A="c_linker_options";
char*s572_168A="\011""\173""";
char*s428_145102259A="(The type of this expression is actually ";
char*s102_339436953A="Compiler limitation: separate classes are not supported. SCOOP attempt implementation currently abandoned (December 2006).";
char*s111_539873441A="\" (default mode) selected.\n";
char*s458_1876110531A="Value out of INTEGER_32 range.";
char*s102_470853074A="The base type is no longer used. Class PROCEDURE now has only one formal argument. Just remove this unused type mark.";
char*s571_6330A="();\n";
char*s111_180A="\"\n";
char*s33_961210799A="allocated_bytes";
char*s115_116813823A="default:\nerror0(\"Internal error in agent launcher (";
char*s115_30942A=") */ ";
char*s115_37095A="(T6)(";
char*s829_61699A="NULL,";
char*s34_436911A="rescue";
char*s630_1341914655A="/*count*/=((";
char*s103_1604340919A="Bad clients list.";
char*s277_1341859296A="Keyword \"system\" expected. Invalid ACE file.";
char*s102_194A=" \"";
char*s647_42706587A="The type ";
char*s109_195A="%\n";
char*s115_475921520A="memcpy(sorted_agent_switch_profile, agent_switch_profile, ";
char*s612_619030689A="fprintf(file,\"\\n\\t]\");\n";
char*s287_200A=" (";
char*s630_117385886A="/*[inspect";
char*s716_786221024A="GC support: generating switch functions.\n";
char*s115_6355A=" R;\n";
char*s715_1409981632A=")REVEAL_POINTER(";
char*s115_204A="\"\"";
char*s628_205A="!(";
char*s829_85966583A="(o);\nGC_enable();\n";
char*s108_580488532A=" nodes and ";
char*s832_212314278A="->first_object)));\n";
char*s102_639285944A="Missing \')\' to end `c_inline_c\' call.";
char*s420_1085830094A="ifthen (empty)";
char*s109_215A=")\n";
char*s388_905138318A="Invalid unicode string at index ";
char*s277_216A="\".";
char*s336_2070057757A="Loop_invariant";
char*s33_217A="#*";
char*s476_218A=" :";
char*s33_218A="#+";
char*s635_160146A="))))))";
char*s115_993675817A="if(fd.assertion_flag)\173""\nfd.assertion_flag=0;\n";
char*s33_220A="#-";
char*s102_873294598A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous manifest STRING as target).";
char*s33_54688766A="se_atexit";
char*s635_4638080A="(T6)((!(";
char*s628_226A="!=";
char*s102_1922692108A="Replaced misspelled \"True\".";
char*s115_227A=" C";
char*s277_1302880443A="Error in the \"";
char*s336_1306325004A="Void_call_target";
char*s115_585944489A="Define C main function.\n";
char*s627_230A="&(";
char*s426_230A=",\n";
char*s630_236A="\')";
char*s611_237A=" M";
char*s115_240A="((";
char*s111_240A=".\n";
char*s716_241A="()";
char*s102_241A="\'.";
char*s543_242A="* ";
char*s628_36137368A="INT64_MIN";
char*s829_6395A=" R=(";
char*s577_244A=" T";
char*s115_245A=")(";
char*s714_246A="))";
char*s613_247A=" W";
char*s33_1682815431A="manifest_make";
char*s115_249A="),";
char*s115_251A="*)";
char*s96_251A=").";
char*s287_252A=", ";
char*s613_254A=",\"";
char*s635_255A="+(";
char*s578_255A=" _";
char*s109_542094038A="Expanded Target Procedure Call";
char*s608_257A=" a";
char*s115_257A="*/";
char*s627_258A=",&";
char*s613_259A=" c";
char*s630_259A=",\'";
char*s714_6411A="(-1)";
char*s109_262A=". ";
char*s34_10703002A="no_check";
char*s115_1312728230A="print_profile(profile_file, &runinit_profile);\n";
char*s630_264A=");";
char*s635_265A="-(";
char*s635_1665734122A="strlen(se_argv[";
char*s628_184795A="(T0*)(";
char*s613_436987A="resexp";
char*s449_1428348580A="This type mark is not a TUPLE type mark.";
char*s287_43325A=": and";
char*s119_270A="--";
char*s408_190952A=" with ";
char*s428_271A=".)";
char*s115_272A="&R";
char*s635_6425A="))/(";
char*s628_1097836905A="/*$*/(void*)&";
char*s103_116346440A="Unknown special character.";
char*s115_1017947719A="manifest_initialize(";
char*s554_276A="..";
char*s115_277A=" u";
char*s115_277C="*C";
char*s115_277B="/*";
char*s808_277A="./";
char*s379_278A=".0";
char*s109_1255776138A="Overflow while computing \"";
char*s109_1131876546A="Starting collect";
char*s115_282A="0*";
char*s33_282A="//";
char*s115_284B="0,";
char*s115_284A="(T";
char*s832_1854022405A=")))return;\nif(((char*)p)>((char*)(b+(c->count_minus_one))))return;\nif(((char*)p)<((char*)b))return;\nif(((((char*)p)-((char*)b))%sizeof(*p))==0)\173""\nif(p->header.flag==FSOH_UNMARKED)\173""\n";
char*s531_287A="->";
char*s531_80251A="empty";
char*s641_293A="10";
char*s641_294A="11";
char*s483_594795843A=", each bunch must have exactly ";
char*s641_295A="12";
char*s635_296A=")[";
char*s33_296A="/=";
char*s111_297A=".C";
char*s630_244699380A="default:;\n";
char*s111_298A="-I";
char*s440_299A=".E";
char*s287_300A=":\n";
char*s111_301A="-L";
char*s999_302A=".H";
char*s115_6455A="));\n";
char*s483_305A=";\n";
char*s115_1754886761A="se_agent*);\n";
char*s115_317A=",a";
char*s33_406284A="fourth";
char*s33_42134669A="Precursor";
char*s429_325449730A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_put\').";
char*s115_1238750212A="get_profiler_started(&master_profile);\n";
char*s102_1088075316A="Cannot use a formal generic argument as a valid parent.";
char*s283_90592250A="Cannot undefine ";
char*s124_322A=": ";
char*s716_35343969A="FSOC_SIZE";
char*s787_324A="-c";
char*s635_325A="._";
char*s111_326A="-e";
char*s613_327A="*u";
char*s635_197159A=";\n*((T";
char*s111_327A=".a";
char*s361_327A="; ";
char*s32_329A=".c";
char*s578_1710309A="Tid id;";
char*s32_331A=".e";
char*s115_10739979A="mspalloc";
char*s613_815493762A="\n/*agent launcher*/";
char*s111_333A="-l";
char*s111_334A="/c";
char*s32_334A=".h";
char*s118_107193812A="It is useless to mark as \"redefine\" this deferred feature.";
char*s35_336A="-o";
char*s572_142931125A=" has no creation list. You must use the default creation method (named `default_create\' in class ANY, or just omit the method name).";
char*s111_340A="-s";
char*s111_341A=".o";
char*s543_342A="> ";
char*s628_345A="=(";
char*s33_1501191A="Current";
char*s477_348A="::";
char*s34_437070A="prefix";
char*s751_351A=":=";
char*s115_1243560324A="se_frame_descriptor fd=\173""\"<global-once-";
char*s120_1568216255A="internal_exception_handler(Void_call_target)";
char*s109_36611104A="You seem to have too classes named ";
char*s33_1578334651A="open_arguments";
char*s666_301503927A="Incompatible actual argument for agent call. Cannot pass `Void\' into formal argument of type ";
char*s526_360A="<<";
char*s379_360A="0x";
char*s33_361A="<=";
char*s413_1136256141A="Cannot use such a strange create expression for type ";
char*s476_2140868216A="Value expected";
char*s715_8033571A="]!=NULL)";
char*s638_754574290A=";\nif (_r==NULL) \173""R=&_r; *id=0;\175"" else \173""\nswitch(_r->id) \173""\n";
char*s630_366A="==";
char*s612_775396A="(&((*o)";
char*s103_1700247488A="Unexpected character in hexadecimal ascii code.";
char*s33_371A=">=";
char*s526_372A=">>";
char*s402_376A="\?=";
char*s832_377A="=H";
char*s832_166455A="(*o);\n";
char*s115_379A="C,";
char*s33_548214405A="REAL_GENERAL";
char*s469_898426A=".......";
char*s111_1561265653A="No default configuration file for Liberty Eiffel was found.\nPlease just re-run the Liberty Eiffel installation program.\nOn Unix-like system, just \"cd\" to the Liberty Eiffel directory and\nthen, type \"make\".\nOn Windows-like system, re-run the \"install.exe\" of Liberty Eiffel.\nNote: if you prefer, you can still rely on the \"";
char*s115_175857472A="manifest_make(";
char*s115_382A="=M";
char*s571_6534A="*((T";
char*s612_197373672A="fprintf(file,\"";
char*s111_62728285A="The configuration file seems invalid. Correct the above errors first.";
char*s33_10377126A="is_empty";
char*s628_1639500234A="NULL/*_POINTER*/";
char*s115_396A="C=";
char*s123_397A="BC";
char*s716_6550A=") \173""\n";
char*s458_1962655329A=" has an argument list";
char*s113_402A="CC";
char*s613_2054563574A="se_frame_descriptor fd=\173""\"create expression wrapper\",0,0,\"\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s405_1442631340A=". (See explaination below.)";
char*s34_9909665A="creation";
char*s115_6559A="*/\nT";
char*s832_1748680500A="=n->header.next;\n\175""\nelse if(";
char*s102_1011636926A="Void cannot be used after unary \"-\" operator.";
char*s635_1340573954A="memcpy(&R,C,sizeof(R))";
char*s613_1484470448A="rc.top_of_ds=&ds;\n";
char*s716_411A="CL";
char*s613_1212159A="==a2->c";
char*s102_1733505988A="Unexpected \"reference\" keyword.";
char*s115_1601653158A="se_local_profile_t local_profile, *parent_profile;\n";
char*s635_419A="=r";
char*s361_892535123A="Same argument name appears twice in this formal argument list.";
char*s115_1957408550A="invariant of ";
char*s115_781060556A="Internal stacks size used: ";
char*s115_726728775A="=2;\175""\nelse\173""\n";
char*s429_1604599495A="Feature `manifest_semicolon_check\' must be a constant (INTEGER or BOOLEAN).";
char*s413_343527626A=" Actually, just replace this create expression with ";
char*s103_74239A="]foo\"";
char*s716_6580A="*);\n";
char*s386_1808265259A="This is not an CHARACTER expression.";
char*s608_86545A="open_";
char*s440_205111678A="\" in cluster \"";
char*s103_696478167A="Bad (empty\?) ascii code.";
char*s458_1604408825A="Must not use such a non-static type mark for a constant-attribute definition.";
char*s280_38905513A="This is not a constant feature.";
char*s647_1447552176A=" the conforming parent(s) for ";
char*s33_1603529235A="to_natural_8";
char*s832_526175446A="*)(&(c->first_object)));\nif((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store";
char*s33_80416A="first";
char*s115_1793244543A="fclose(profile_file);\175""\n";
char*s636_1395477828A="/*se_fault*/\173""int*i=0;*i=0;\175""\n";
char*s829_733445699A="void bdw_finalizeT";
char*s33_878996813A="TYPED_INTERNALS";
char*s109_408537579A=". The number of dots\ngives the number of \"when\" clauses:\n";
char*s115_10666295A="\175""/*--*/\n";
char*s115_339308075A="/*The generic se_agent0 definition:*/\nstruct _se_agent0\173""\nTid id;\nTid creation_mold_id;\nvoid(*afp)(";
char*s408_1297676933A=" would give ";
char*s832_6614A="((gc";
char*s336_1489034545A="Routine_failure";
char*s999_1935504882A="Strange dependency: location <";
char*s115_471A="R=";
char*s641_471A="T3";
char*s666_1084920002A="Bad number of actual arguments for agent call. (The agent you are trying to call has ";
char*s641_474A="T6";
char*s430_1240817101A="Bad comment to end a class.";
char*s641_476A="T8";
char*s111_1192507148A="Unknown os \"";
char*s33_1639475718A="UNICODE_STRING";
char*s636_529853775A=");\n\175""\nelse\173""\n";
char*s663_1937147216A="Cannot assign newly created ";
char*s109_1459577427A="Void target Function Call";
char*s440_397816412A="   include ";
char*s111_1721407046A="Math=IEEE Parameters=Both Code=Far";
char*s477_1577658176A="... unique local buffer ...";
char*s613_283801480A="void*afp;\n";
char*s647_1655357614A="Keyword \"require\" replaced with \"require else\" because there is an inherited require assertion.";
char*s797_498A="X:";
char*s34_2073386A="inspect";
char*s102_2117894368A="Void is not a valid BOOLEAN expression (just after keyword \"until\" of a loop).";
char*s571_6655A=")->_";
char*s30_613587359A="Flag or argument \"";
char*s628_506A="])";
char*s571_215791A="(void)";
char*s630_1181502A="==0 \174""\174"" ";
char*s829_1544707291A="void*bdw_na_assignT";
char*s102_1524784203A="Exponent part of a real value expected.";
char*s999_1942892277A="Including header ";
char*s115_365905049A="init_profile(&root_profile, \"<root>\");\n";
char*s715_1970645590A="#define BDW_GC 1\n#define GC_I_HIDE_POINTERS 1\n#include <gc/gc.h>\n#define malloc(s) GC_MALLOC(s)\n#define calloc(n,s) GC_MALLOC_IGNORE_OFF_PAGE((s)*(n))\n#define realloc(p,s) GC_REALLOC((p),(s))\n#define free(p) p=NULL\n";
char*s472_334725631A="Error in variant part of loop definition.";
char*s791_1000694404A="].\nOriginal definition ";
char*s715_722650754A="se_malloc(sizeof(void*))";
char*s343_25373399A="Incompatible signatures. (One has a result type and not the other.)";
char*s115_526A="]=";
char*s715_1477636806A="#ifndef GC_DEBUG\n#define GC_DEBUG \"";
char*s630_1084495643A="\175""\175""/*manifest INSPECT]*/\n";
char*s408_889865702A=" which is out of INTEGER_8 range.)";
char*s33_534A="a1";
char*s635_535A="a2";
char*s111_6687A=" To ";
char*s498_2057854492A=" is 9223372036854775808 which is out of INTEGER_64 range.";
char*s115_932172292A="]=root_profile;\n";
char*s102_955638361A="Bad use of predefined type ARRAY.";
char*s102_9897510A="built_in";
char*s34_10315778A="indexing";
char*s33_552A="\\\\";
char*s476_1490203324A="Unexpected keys found\n";
char*s102_2030568676A=" is not writable (reached through closure). Cannot use ";
char*s115_1901889757A="/*\nANSI C code generated by ";
char*s122_557A="_R";
char*s832_25822456A=";\ngc_free";
char*s698_559A="_T";
char*s102_1471861047A="Syntax error inside \"local\" variable list definition. Encountered keyword \"";
char*s630_550508910A="assertion_depth=1;\nfree_exception_frames();\n";
char*s34_1532343833A="cpp_compiler_path";
char*s791_68224A="The \'";
char*s374_1744510279A=" Cannot assign ";
char*s287_22396357A=" columns ";
char*s628_570A="\\n";
char*s125_570A="__";
char*s630_1832703325A="/*UNUSED_EXPRESSION:*/(void)(";
char*s34_54418471A="reference";
char*s102_1228072329A="Such a constant cannot be used in \"when\" part of an inspect statement.";
char*s115_1988895671A="start_profile(parent_profile, &local_profile);\n";
char*s115_273430980A="return C;\n";
char*s578_166654A="* o1,T";
char*s277_1476966395A="More than one class in the system is named ";
char*s115_1290234339A="int se_argc";
char*s102_1961160815A="The \"separate\" keyword is still a reserved keyword in case of a new implementation attempt...";
char*s405_1037594318A=" (Error occurs while checking the code in ";
char*s102_751585121A="Error while reading hexadecimal number.";
char*s34_2233396A="runtime";
char*s714_273418685A="se_calloc(";
char*s30_1724187394A=": missing output name after -o flag.\n";
char*s34_48390502A="all_check";
char*s106_589A="bc";
char*s641_591A="_t";
char*s111_2077353217A="\" (alternate mode) selected.\n";
char*s277_2132072515A="\" ACE file.\n";
char*s35_594A="cc";
char*s832_596A="o)";
char*s33_9713026A="as_32_ne";
char*s33_36193081A="INTEGER_8";
char*s518_2080244194A="Division by zero.";
char*s34_600A="as";
char*s103_1317175740A="Too long hexadecimal sequence for a single unicode value.";
char*s109_1463938603A="Polymorphic Proceduire Call";
char*s113_603A="cl";
char*s832_6755A="++;\n";
char*s832_604A="o1";
char*s102_1207921682A="Manifest real value not compatible with this type.";
char*s109_801894175A="Unknown prefix operator \"";
char*s433_1773450779A="A formal generic argument must not use the name of some existing class.";
char*s102_437331A="result";
char*s413_1260488135A=" and you are done.";
char*s102_611A="do";
char*s33_548331507A="NATIVE_ARRAY_INTERNALS";
char*s111_614A="gc";
char*s716_185146A="(T0*o)";
char*s115_1419097826A="),c,(int16_t*)s,sc,lsv,lsi);return (T0*)";
char*s109_427937988A="Total Number of Merged \"when\" clauses (cumulated): ";
char*s111_179868158A="Unknown system name in file\n\"";
char*s635_475042348A="internal_exception_number";
char*s440_620A="es";
char*s613_68284A="a1->c";
char*s630_6775A="))\173""\n";
char*s613_5395051A="(void**)";
char*s115_625A="\173""\n";
char*s115_5395053A="(void*)0";
char*s34_627A="if";
char*s630_693716559A="error1(\"Invalid ::= assignment (inserted type).\",";
char*s124_354654986A="Environment variable $\173""";
char*s33_51915068A="is_normal";
char*s118_1661847054A="\" come from the same original feature via multiple \"inherit\" paths.\nBelow, you get the feature evolution step by step. Note that in the end (type ";
char*s103_85511833A="Right hand side expression of ::= assignment expected here.";
char*s628_1367878466A="se_manifest";
char*s115_811016135A=">\",0,0,\"\",1\175"";\n";
char*s115_635A="\175""\n";
char*s33_636A="io";
char*s99_1861287086A="not_computed";
char*s478_449661A="struct";
char*s34_640A="is";
char*s630_2251910A="switch(";
char*s625_5395074A="(void)0;";
char*s109_1174466439A="during inlining of dynamic dispatch";
char*s115_651A="p[";
char*s34_1690381566A="invariant_check";
char*s715_12955A="]);\n";
char*s716_19622345A="(&(u->CA_";
char*s33_1744399653A="type_attribute_generating_type";
char*s635_6810A="))\174""(";
char*s106_660A="ms";
char*s277_661A="no";
char*s108_97543221A="Recompute RUN_TIME_SETs..";
char*s625_4570857A="/*:RF1*/";
char*s630_1175100011A=" /* has_empty */ if (";
char*s33_669A="or";
char*s635_670A="\176""(";
char*s34_670A="os";
char*s572_671A="\175"".";
char*s30_525197655A="\" specified for the -is_output_error_warning_on flag.\n";
char*s613_43730A="*se_i";
char*s407_925886099A=" (this is not BOOLEAN).";
char*s635_351281A="a1ptr=";
char*s113_674A="sc";
char*s102_1135641353A=" is not writable.";
char*s832_6830A=" e;\n";
char*s647_378711602A="Keyword \"ensure then\" replaced with \"ensure\" (There is no inherited ensure assertion here).";
char*s111_1087245292A="#: config file corrupted!";
char*s90_685A="ti";
char*s111_686A="rt";
char*s111_689A="vc";
char*s115_1713607783A="if (expression != NULL) error2(expression,/*unknown-position*/0);\n";
char*s716_1824264277A="void once_function_mark(void)";
char*s571_905827712A="manifest_string_mark";
char*s830_699A="\173""T";
char*s610_619166512A=";\n#define M";
char*s613_228498053A="se_dump_stack ds=\173""NULL,NULL,0,NULL,NULL,NULL\175"";\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s283_875060418A="You cannot inherit \"";
char*s635_1375807179A="Unknown WEAK_REFERENCE built-in: ";
char*s33_1115958189A="open_argument_indices";
char*s33_1206543966A="object_attribute";
char*s625_4570907A="/*:RF3*/";
char*s29_1325879523A=": missing loadpath file path after -loadpath flag.\n";
char*s102_316863332A="No parent after \"inherit\" keyword (an empty list is not allowed here).";
char*s647_1197649626A="Precursor call is allowed only when the enclosing routine is redefined.";
char*s542_1899804731A="adapting features";
char*s613_10937200A="return (";
char*s115_6877A=");/*";
char*s113_13028A="UNIX";
char*s33_80694A="floor";
char*s578_1290234494A="int se_cmpT";
char*s490_1767084619A="Please consider writing an explicit open argument list for your agent creation.";
char*s105_1385667261A=".\nIts retained value will be the last read.\n";
char*s33_849712179A="print_run_time_stack";
char*s625_4570932A="/*:RF4*/";
char*s286_740A="\173""\175""";
char*s543_1114764925A="\\LIBERTY.CFG";
char*s630_744A="\174""\174""";
char*s829_854811368A="o->bdw_generation=g;\175""\n";
char*s113_1772235A="Windows";
char*s613_750A="\175""\175""";
char*s630_1261705A="=NULL;\n";
char*s693_1601130656A="Duplicate directory";
char*s109_1460051321A="Unsafe covariant redefinition of argument number ";
char*s277_527202963A="The \"debug\" assertion level is deprecated. Please use \"all\" and debug statements.";
char*s115_1195084695A="ds.fd=&root;\nds.current=((void*)(&";
char*s408_613384625A="Overflow of infix \"+\" with INTEGER_32 operands. (Adding ";
char*s566_2007779419A="/*reusing tmp";
char*s111_643573734A="If Liberty Eiffel is correctly installed, you should find\nmore information in the file \"";
char*s483_589832448A="Must not use the \";\" (semicolon) separator for manifest ";
char*s716_40031469A="RSOC_SIZE";
char*s832_10937240A="return((";
char*s625_4570957A="/*:RF5*/";
char*s636_68406039A="\n#if BYTE_ORDER == BIG_ENDIAN\n";
char*s542_1280946519A="collecting features";
char*s832_5161461A="(fsoc*c)";
char*s630_644847010A=";\nbreak;\n\175""\n";
char*s33_567319806A="to_integer_16";
char*s630_1124563501A="))\173""switch(((T0*)";
char*s116_6926A=",...";
char*s113_51699930A="lcc-win32";
char*s402_7867907A="Invalid ";
char*s33_1597390874A="Character_bits";
char*s33_567319812A="to_integer_32";
char*s115_7720290A="Function";
char*s625_4570982A="/*:RF6*/";
char*s120_899910547A="se_print_run_time_stack(),exit(1)";
char*s832_2092663259A="goto begin;\n";
char*s635_6946A=",0))";
char*s115_1994813154A="];\nse_profile_t sorted_all_profile[";
char*s33_567319829A="to_integer_64";
char*s429_282823780A="Invalid creation procedure. A \"once\" procedure is not allowed as a creation procedure.";
char*s635_1824713404A="deep_memcmp(";
char*s33_9676326A="capacity";
char*s612_926003101A="if(*o==NULL)\173""\n   fprintf(file, \"void\");\n   return;\175""\n";
char*s613_80771A="u->R=";
char*s277_1091711046A="\" (and there may be more). Search started from ";
char*s635_6965A=")<<(";
char*s625_4571007A="/*:RF7*/";
char*s577_1710532409A="/*BUG:NA@runtime!*/";
char*s33_1671553525A="WEAK_REFERENCE";
char*s115_1981256377A="Assignment test (\"\?:=\") function";
char*s111_10937305A="return;\n";
char*s613_173055A="*)u2;\n";
char*s478_55156846A="signature";
char*s542_958892525A="Total time spent ";
char*s102_52979396A="loop body";
char*s505_1083118122A="Type mark \"like <argument>\" must not reference another \"like <argument>\" type mark. (One level of indirection is always possible and always better ;-)";
char*s630_400650A="else\173""\n";
char*s630_86950A="rawci";
char*s34_400652A="elseif";
char*s635_427390771A=")==FP_SUBNORMAL";
char*s277_1707020207A="The \"use\" clause is not yet implemented.";
char*s625_4571032A="/*:RF8*/";
char*s613_345908476A="ds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\nset_dump_stack_top(&ds);/*link*/\n";
char*s635_6995A=")==(";
char*s96_142319A="\" in \"";
char*s34_11251026A="undefine";
char*s429_170383550A="Manifest generic creation not yet implemented for expanded types (";
char*s638_7006A=" _r=";
char*s111_373286592A="\".\nCurrently handled system names:\n";
char*s102_1275558331A="A routine must be ended with \"end\".";
char*s625_4571057A="/*:RF9*/";
char*s102_888875725A="Missing \";\" added.";
char*s832_1648235130A="->header.state_type=FSO_USED_CHUNK;\nn=";
char*s33_1498845794A="NATIVE_ARRAY[CHARACTER]";
char*s476_1331532446A="module_name";
char*s405_1769582063A=" Expression ";
char*s635_7025A=")>>(";
char*s829_719514099A="bdw_na_assignT";
char*s832_1288623074A=")(r+1));\n\175""\nreturn((T";
char*s493_672729595A="Invalid generic constraint cycle.";
char*s834_730579755A="=(void*)0;\n";
char*s277_1130154866A="Bad Environment variable.\n(Closing \"\175""\" not found.)";
char*s408_923532A=" minus ";
char*s999_7037A=" at ";
char*s109_1814748872A="\" from ACE file. (Parsing \"";
char*s343_345225764A="Different arguments types.";
char*s630_1291760099A=";\nbreak;\n\175""\nbreak;\n";
char*s33_80854A="flush";
char*s33_13194A="TYPE";
char*s280_1820580025A="Probably infinite or too long generic derivation of this type mark (see next warnings to find the cause of the problem... and good luck).";
char*s635_1689502217A="Bad prototype for C struture get external.";
char*s625_185428A="/*RF1:";
char*s628_686612424A="(/*OUTCL:LOCAL*/*";
char*s34_10193105A="expanded";
char*s32_831708366A="Feature `copy\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s124_1972884945A="The old \"SmallEiffel\" variable is not valid anymore. Please use Liberty Eiffel.\n";
char*s33_10377643A="is_equal";
char*s625_185438A="/*RF3:";
char*s111_703496930A="\"[General] sys\" key is missing.";
char*s834_1295032451A=".store_chunk=NULL;\n";
char*s109_604558099A="Loaded Classe";
char*s625_185443A="/*RF4:";
char*s666_501491947A=" is expanded. (The whole type of the agent your are trying to launch is ";
char*s625_185448A="/*RF5:";
char*s109_1786429697A=" cannot be a root class since it is a generic class.";
char*s408_1552156565A=" which is out of range 0..15 because target type is INTEGER_16.";
char*s625_185453A="/*RF6:";
char*s34_1975394A="cluster";
char*s33_1594034A="ROUTINE";
char*s102_75996531A="Discarded empty convert clause";
char*s33_2246041A="storage";
char*s625_185458A="/*RF7:";
char*s832_1012357115A="(unsigned int size)";
char*s109_24235871A="2011-2013";
char*s115_1065055A="*s=M7;\n";
char*s109_1497652563A="\': anonymous feature not found";
char*s715_323156020A="int bdw_delayed_finalize";
char*s625_185463A="/*RF8:";
char*s276_51017327A="Bad external signature (missing \")\" delimiter.";
char*s115_934A="\"\n\"";
char*s376_1809213019A="ref-status: ";
char*s458_1284372793A="A function cannot be an assigner.";
char*s470_1204053035A="c_inline_c(";
char*s34_1839765037A="Cyclic anchored definition.";
char*s625_185468A="/*RF9:";
char*s111_830570470A="-cc specified more than once; last is used.\n";
char*s578_481249030A=") != (o2->_";
char*s749_495673125A=") is not smaller than upper bound (";
char*s118_1752297822A="A frozen feature must not be undefined. What is frozen _is_ frozen.";
char*s115_1642367158A=", sizeof(se_profile_t), profile_comparator);\n";
char*s115_273431355A="return R;\n";
char*s277_708319A="\" and \"";
char*s124_7106A=" day";
char*s715_15009395A="\"\n#endif\n";
char*s832_915251302A=";\nif((o!=NULL)";
char*s432_171706123A=" which is the generic constraint.";
char*s111_50863580A="exit(0);\n";
char*s470_1204053060A="c_inline_h(";
char*s543_1747846A="\\SE.CFG";
char*s630_7118A="-1)\?";
char*s33_1607595572A="to_character";
char*s647_557767498A=" in order to use it as a unique parent qualifier.";
char*s34_1992063831A="ensure_check";
char*s504_1962243783A="Bad anchor. Unknown feature name.";
char*s716_207160501A="#ifndef FIXED_STACK_BOTTOM\nint valid_stack_bottom = stack_bottom != NULL;\n#endif\n";
char*s638_124454155A=";\n*exp=1;\n";
char*s483_1496963692A="Wrong usage of \";\" (semicolon) separator in manifest notation. Each bunch-size must be a multiple of ";
char*s630_54714119A="sedb(&ds,";
char*s635_87090A="pow((";
char*s115_1586448448A="uint16_t lsv";
char*s832_77282146A=".space_used+=size;\n";
char*s635_185515A="(T6)((";
char*s449_540477054A=", this type mark is not a TUPLE. (This is actually ";
char*s85_1761241425A="Adding Cecil file: ";
char*s119_992A="   ";
char*s115_1500500537A=" live TYPEs:\n";
char*s102_1587734026A="Void cannot be the left-hand side of the binary \"\\\\\" operator.";
char*s829_903312259A="return wr->o;\n";
char*s832_160930A="))-1)\175""";
char*s102_1703575813A="Bad character constant. Closing \"\'\" expected.";
char*s638_160937A="(*C)->";
char*s277_89867121A="\" section.";
char*s408_205616643A="Overflow of infix \"-\" with INTEGER_32 operands. (";
char*s115_514187710A="#ifdef __cplusplus\nextern \"C\" \173""\n#endif\n";
char*s453_1615634978A="Unable to find the default creation procedure for expanded type ";
char*s102_2080029331A="Slash \"/\" character expected after decimal value in CHARACTER constant.";
char*s102_266191698A="The keyword \'creation\' is now replaced by \'create\'. Please update your code.";
char*s111_851047233A="\nThe type of your operating system was automatically  computed. Please verify.\n";
char*s115_1346694814A="if (sedb_status != SEDB_EXIT_MODE) ";
char*s109_1365578385A="Starting simplify";
char*s102_1090616383A="Unable to find a class definition in \"";
char*s115_308580A="NULL;\n";
char*s677_247541875A="copy index";
char*s458_1436450217A="A string constant cannot be an assigner.";
char*s109_713806135A=" (For this call, the target ";
char*s352_646901709A="Call on a Void target.";
char*s102_1581435442A="Bad external clause (manifest string expected).";
char*s468_743946038A=" is expanded. The generic argument of WEAK_REFERENCE must not be expanded. (It does not makes sense to do so.)";
char*s832_1413869902A="gc_update_weak_ref_item_polymorph((Tgc*)&(o1->object));\n";
char*s691_1043A=" (+";
char*s458_69279758A="A unique constant cannot be an assigner.";
char*s111_17494489A="compile_to_c: \"";
char*s692_1047A=" + ";
char*s287_7207A=" in ";
char*s34_10876026A="redefine";
char*s115_437780A="se_msi";
char*s832_1473891377A="\173""\173""FSOC_SIZE,FSO_STORE_CHUNK,\n(void(*)(mch*,void*))";
char*s102_1380562254A="Boolean expression expected (until).";
char*s647_1092806174A=" The final export list is ";
char*s416_1719402393A=".............................................";
char*s108_23085765A=".(done).\n";
char*s716_1102979933A="gc_is_off=0;\n";
char*s832_1927410765A="=old_gc_free;\nc->next=fsocfl;\nfsocfl=c;\nc->header.state_type=FSO_FREE_CHUNK;\n\175""\n\175""\n";
char*s832_1574324912A="dead=0;\175""\nelse\173""\n";
char*s35_87180A="relax";
char*s96_439490016A="\" does not belong to a creation clause of ";
char*s109_385188989A="Before collect cycle";
char*s102_1934613587A="Simple identifier expected just after a dot. Nothing else but a simple feature name is meaningful just after a dot.";
char*s115_965818786A="No support found in directory sys/runtime for \"";
char*s481_68732A="This ";
char*s277_208962844A="*** Looking for ";
char*s102_2091587115A="Void is not a valid target (i.e. just after a dot).";
char*s115_4620481A="(T0*)(g[";
char*s486_7232A=" is ";
char*s630_7235A=");\175""\n";
char*s458_1305581590A="An attribute cannot be an assigner.";
char*s408_156630152A=" which is out of INTEGER_64 range.)";
char*s30_1090A="\".\n";
char*s716_1102979958A="gc_is_off=1;\n";
char*s543_1027113524A="USERPROFILE";
char*s630_1348915394A="DynamicDispatch";
char*s115_1901755A="ac_req(";
char*s628_580292587A="/*SFN*/(C->";
char*s464_99702656A=" Feature `";
char*s109_1839715989A="The feature called has no formal argument while the actual argument list has ";
char*s577_302501127A="typedef union _se_agent se_agent;\ntypedef struct _se_agent0 se_agent0;\n";
char*s458_1630520481A="The type of this constant feature should be REAL.";
char*s115_197932A=";\n*C=M";
char*s808_1101A="\").";
char*s467_1554555636A="Cannot change exportation status of ";
char*s102_879341913A="No more \"reference\" keyword allowed. The obsolete \"reference FOO\" notation is no longer accepted. Just use the REFERENCE class instead.";
char*s408_1277330071A="Violated assertion (target value is ";
char*s115_893005A="\"\\n\"),\n";
char*s832_2136427942A="............ unique local buffer ...................";
char*s483_1034900711A="Cannot pass Void into formal argument which is of type ";
char*s440_1112A="\". ";
char*s102_1617443474A="No sign allowed before an hexadecimal constant value.";
char*s115_588411932A="void se_atexit(void)";
char*s458_1051699101A="A constant cannot be an assigner.";
char*s526_1330923746A="\175"". See the next error message.";
char*s96_1121A="\".)";
char*s370_327012886A=" but there is _no_ when clause selected. (Also note that there is no else part for this inspect statment, hence this error message.)";
char*s102_1717397235A="Corresponding closing \')\' expected here.";
char*s102_1003875089A="No more \"expanded\" keyword allowed here. The obsolete \"expanded FOO\" notation is no longer accepted.";
char*s35_2141685A="no_main";
char*s628_1446625A="INT8_C(";
char*s352_1759986771A="This feature is only exported to ";
char*s115_4620546A="(T0*)(t[";
char*s115_1055242101A="/*[INIT CLOSURE LOCALS*/\n";
char*s832_7296A=" na=";
char*s540_927498134A="run-time-set-count: ";
char*s716_10322525A="\175""\nelse\173""\n";
char*s418_1099750743A="Feature found is not writable (i.e. not an attribute).";
char*s285_1133285999A="Cannot find the default class ";
char*s829_1524126691A=" bdw_mallocT";
char*s33_1157A="#//";
char*s335_1981041429A="CODE_ACCUMULATOR code_stack";
char*s115_273443870A="se_atexit(";
char*s608_7317A=" of ";
char*s115_1350760769A="assertion_depth++;\n\175""\n";
char*s109_1535001676A="Details regarding Monomorphic calls:\n";
char*s716_419443A="na_env";
char*s472_1867518592A="Expression of the loop variant must be of INTEGER type. (The actual ";
char*s111_1964046235A="\"[General] short\" key is missing.";
char*s408_905382A=" gives ";
char*s115_1142598643A="local_profile.profile=inv_profile+";
char*s829_1858599648A="void*bdw_weakref_new(int n)";
char*s277_305465997A="Quoted identifiers are deprecated. Please remove quotes here.";
char*s33_1944903A="ceiling";
char*s683_235492225A="Attributes cannot have a rescue compound.";
char*s33_55040341A="put_16_be";
char*s543_28418819A="/etc/serc";
char*s34_10648581A="obsolete";
char*s387_1552710436A="Internal error inside WHEN_ITEM_1 (compiler error).";
char*s102_1819737650A="Must use exactly 4 hexadecimal digits for INTEGER_16.";
char*s109_1206593669A="Monomorphic Procedure/Function Call";
char*s17_1210A=".\n\n";
char*s35_2246326A="verbose";
char*s111_1215A="\'.\n";
char*s277_767646015A="\" while the second is in the cluster \"";
char*s280_1641573945A="The following path was misdetected as an inheritance cycle";
char*s115_1319581398A="se_dump_stack ds=\173""NULL,NULL,0,NULL,NULL,NULL,0\175"";\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s33_9529116A="add_last";
char*s628_11300605A="unsigned";
char*s635_52075585A=" cannot be converted to a memory address.)";
char*s124_1430004157A=" used in file \"";
char*s635_1671074150A="((uint32_t)(";
char*s408_1324951230A="Overflow of infix \"+\" with INTEGER_64 operands. (Adding ";
char*s32_1897129554A="Feature `is_equal\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s287_188916891A=" . The validation context is used to compute all anchored type marks.)";
char*s102_155929078A="Incorrect TUPLE (type expected).";
char*s109_646243744A="Symplify interrupted (infinite inlining ... or infinite recursion detected.).";
char*s33_276937706A="slice_copy";
char*s829_1180476551A=",NULL,NULL,NULL);\n";
char*s33_1235A="#<<";
char*s102_911265735A="Missing the \"is\" keyword\?";
char*s628_1240A="(((";
char*s832_407207A="fsoc H";
char*s429_1700082283A="Invalid creation procedure. A function is not allowed as a creation procedure.";
char*s635_520388145A="((int64_t)(";
char*s33_55040391A="put_16_le";
char*s635_704592146A="Invalid usage of feature `to_pointer\' of class ANY. (The target which is of type ";
char*s33_1247A="#>>";
char*s635_837784A=");\n*((T";
char*s613_7400A="*CL_";
char*s467_1377394679A=" does not have feature ";
char*s102_445001496A="This is not a feature name, but a class name.";
char*s386_1088174660A="(The corresponding feature definition is in the next error message.)";
char*s716_52555395A="->header.flag)==FSOH_UNMARKED)\173""\n";
char*s30_513843490A=") is used.\n";
char*s33_55040401A="put_16_ne";
char*s115_499425548A="NULL/*Unused Target*/";
char*s287_4479182A=" column ";
char*s613_1485929081A="int (*eq)(se_agent*,se_agent*);\n";
char*s715_1208340604A="bdw_mallocT";
char*s33_2067995A="implies";
char*s635_870841390A="<<16)\174""((uint32_t)";
char*s115_1919660703A="];\nse_profile_t sorted_agent_switch_profile[";
char*s109_1265A=").\n";
char*s115_1271B=")))";
char*s115_1271A=" R=";
char*s96_74133124A="\" is not a creation procedure of this class).";
char*s833_1274A=")),";
char*s115_148900A="!=0)\173""\n";
char*s566_38182A="/*tmp";
char*s613_182255408A="Deferred \173""";
char*s636_1431664982A=">>24)&0xFF));\n#else\n";
char*s636_1280A=")+(";
char*s714_1281A="(0)";
char*s115_1284A="((T";
char*s628_1285A="),(";
char*s715_1286A="(1)";
char*s636_1291A="))=";
char*s111_932412928A="                ";
char*s663_1083579905A=" while building type ";
char*s115_81256A="evobt";
char*s115_1295A="*/\n";
char*s115_1295B="*)(";
char*s630_25900A=" && (";
char*s628_1298A=", &";
char*s440_1642232185A="Cannot find include \"";
char*s458_1952642401A="The type of this constant feature should be BOOLEAN.";
char*s630_685204250A=": switch(*(";
char*s626_7454A="\'\\0\'";
char*s625_1312A=")->";
char*s334_855586967A="Cannot use agents type marks or TUPLE type marks inside cecil files (Liberty Eiffel limitation, sorry). To work around, just use an extra Eiffel routine/object to perform agent or TUPLE manipulation in pure Eiffel.";
char*s34_1988096A="feature";
char*s613_7475A=" se_";
char*s33_747962924A="type_item_is_expanded";
char*s115_32080A=")));\n";
char*s542_902076231A="Type-system safety check not performed in this mode\n(use the -safety_check flag).\n";
char*s346_10414970A="item_xxx";
char*s371_1686701A="Result.";
char*s34_945182441A="Environment";
char*s115_1330A=");\n";
char*s832_26635163A=")new_na(&";
char*s33_1245671098A="set_object_attribute";
char*s111_1335A=",-\n";
char*s411_13637A="The ";
char*s829_1542419950A="if(bdw_na_assign_innerT";
char*s102_2097430832A="Underscore notation _ not supported inside fractional part.";
char*s103_140920753A="You must use an even number of hexadecimal digits to denote a sequence of CHARACTERs.";
char*s613_37202594A="Feature \"";
char*s483_412142950A="Only static type can be used for this form of creation.";
char*s429_1304837581A="First argument of `manifest_put\' must be an INTEGER.";
char*s34_87466A="retry";
char*s115_411134193A="........ local buffer ........";
char*s283_413151726A=" because type ";
char*s280_1136866084A="\n      inserted as ";
char*s638_1068122514A="void* se_introspecT";
char*s716_2077255577A="fprintf(SE_GCINFO,\"C-stack=%d \",gc_stack_size());\nfprintf(SE_GCINFO,\"main-table=%d/%d \",gcmt_used,gcmt_max);\nfprintf(SE_GCINFO,\"fsoc:%d(\",fsoc_count);\nfprintf(SE_GCINFO,\"free=%d \",fsocfl_count());\nfprintf(SE_GCINFO,\"ceil=%d) \",fsoc_count_ceil);\nfprintf(SE_GCINFO,\"rsoc:%d(\",rsoc_count);\nfprintf(SE_GCINFO,\"ceil=%d)\\n\",rsoc_count_ceil);\nfprintf(SE_GCINFO,\"GC called %d time(s)\\n\",collector_counter);\nfprintf(SE_GCINFO,\"--------------------\\n\");\n";
char*s635_116864219A="local buffer...";
char*s429_1081673178A="First argument of `manifest_make\' must be an INTEGER.";
char*s485_869266852A="Cannot rename feature `c_inline_c\' because this name is used as a keyword to handle the corresponding \"built_in\" feature of ANY.";
char*s343_590983311A="While checking this call in ";
char*s119_1382A="-- ";
char*s374_762122588A=" Error detected while checking this code in the ";
char*s277_139303084A="c_compiler_options";
char*s613_2028521226A="se_dump_stack ds;\n";
char*s285_362867332A="). Cannot go on: please try removing your .id file or calling \"se clean\". If that fails, please send an e-mail at liberty-eiffel@gnu.org";
char*s103_996106634A="Invalid unicode notation (see also http://www.unicode.org as well as feature \173""UNICODE_STRING\175"".valid_unicode).";
char*s102_1910692676A="Routine body expected.";
char*s102_1466196812A="Error while reading real number.";
char*s829_1043020315A=";\nreturn R;\n";
char*s115_1618833880A="fd.assertion_flag=1;\n\175""\n";
char*s647_1846931416A=" is not a valid ancestor for this method.";
char*s277_86060043A="Just finished parsing of \"";
char*s999_1807195960A=" does not provide any .h or .c file, nor a cecil.se file!";
char*s566_7557A=" tmp";
char*s409_1127350535A="Void must not be the right-hand side of an assignment test (always True).";
char*s286_87520A="\173""ANY\175""";
char*s571_1407A=")=M";
char*s716_1994331A="gc_free";
char*s715_1582973561A="bdw_weakref_setlink((bdw_Twr*)(";
char*s408_1705796732A="Overflow of infix \"*\" with INTEGER_8 operands. (";
char*s830_1414A=" gc";
char*s103_181806522A="Unexpected new line in manifest string.";
char*s115_1417A="/* ";
char*s630_32175A=")) \173""\n";
char*s638_32176A="(*C).";
char*s647_39109479A=" is different from the one explicitly listed here.";
char*s102_342864313A="An anchored type cannot be used to indicate exportation status in a client list.";
char*s413_1732344459A=" and the default creation procedure (see `default_create\' in class ANY) is not allowed. You must use one of the available creation procedure here.";
char*s102_2110077371A="Must use exactly 8 hexadecimal digits for INTEGER_32.";
char*s613_1426A="*C)";
char*s33_87541A="print";
char*s33_1427A="#\\\\";
char*s124_210310269A="Removing \"";
char*s122_489233515A="agent_launcher";
char*s370_1459510708A=" is of type ";
char*s829_1114679499A=" bdw_malloc_innerT";
char*s716_1028650A="(u->CL_";
char*s413_1382321814A="Cannot assign newly created object of type ";
char*s636_29107967A="*((int32_t*)(";
char*s115_1540494783A="]=((void(*)(FILE*,void*))se_prinT";
char*s111_1438A=".00";
char*s630_1241777620A="if (NULL==(";
char*s115_2087300232A="void*(*se_introspecT[";
char*s635_1124779458A="if(R)R=((C->_";
char*s30_941571923A="output_error_warning_on";
char*s692_1452A=" \174"" ";
char*s357_1440516445A="Invalid type for the target of this function call.";
char*s125_150325744A="can_assign_to";
char*s504_90494969A=" is a procedure. Anchored type is not valid.";
char*s715_308117350A="GC_enable();\n";
char*s277_1689176777A="external_c_plus_plus_files";
char*s115_1924772383A="/*Aliased storage area or unicode storage.*/\n";
char*s716_1246790712A="gc_mark(u->";
char*s476_486705491A="Unexpected trailing character";
char*s716_530955790A="GC support: generating functions.\n";
char*s830_81437A="fsoc*";
char*s115_1476A=")R)";
char*s636_813409A="))=*((T";
char*s442_1478A="0.0";
char*s115_188283590A="T0*se_ums(";
char*s630_1307328870A="/*until*/if(";
char*s343_934695142A="Different result types.";
char*s115_1273572186A="se_local_profile_t local_profile, master_profile;\n";
char*s30_579450289A=": the new name of the \"-trace\" flag is now \"-sedb\".\n";
char*s102_54634669A="precursor";
char*s612_340114884A="7(file,(EIF_STRING*)";
char*s115_1493A="/*l";
char*s33_1375414302A="type_generating_type";
char*s102_1744209811A="Bad use of predefined type NATIVE_ARRAY.";
char*s716_1770234694A="(!gc_is_off)";
char*s115_13801A="]=p[";
char*s115_586511651A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_agent_profile+i);\n\175""\n";
char*s700_511703191A="Cannot rename ";
char*s832_479982486A="!=NULL)\173""\nn=";
char*s115_1404852998A="sedb_breakpoint(&ds,";
char*s402_35382059A="\?=  assignment (an assignment attempt).";
char*s102_49203356A="attribute";
char*s115_2142659303A="se_profile_t inv_profile";
char*s408_2480364A="Overflow for opposite of Minimum_integer_16.";
char*s402_354065377A=" (\"::=\" is not necessary).";
char*s118_582925635A="Can\'t join these two attribute definitions. Because an attribute cannot be undefined (using an undefine clause), you may consider to modify parents themselves. May be.";
char*s102_2047201942A="Substitute with \",\".";
char*s102_1909979286A="Feature name expected here.";
char*s124_1680762272A="\" not found.\n";
char*s102_1642195503A="The !! notation is really old and ugly, it should not be used anymore. Please update your code and use the `create\' keyword.";
char*s33_880412606A="generating_type";
char*s34_2234341A="variant";
char*s277_1709309070A="Unable to load class \"";
char*s111_1102814319A="System is \"";
char*s635_1530A="->_";
char*s829_7682A="*R=M";
char*s102_833080669A="End of text expected.";
char*s635_1679636650A="((real32_t)(";
char*s478_413651A="inline";
char*s832_129037214A="(fsoc*c,gc";
char*s33_279656751A="std_output";
char*s408_2480394A="Overflow for opposite of Minimum_integer_32.";
char*s102_962885232A="Expression ";
char*s33_859431564A="type_attribute_generator";
char*s115_490869799A="_external_cpp";
char*s102_791727511A="Bad generic list. Expected \',\' or \']\', but found \'";
char*s115_1164920984A="se_profile_t profile";
char*s102_2099054905A="Correct the previous error";
char*s666_643795973A="Incompatible actual argument for agent call. Cannot pass ";
char*s716_1111954737A="void gc_mark_";
char*s34_1957581A="default";
char*s277_1553744164A="external_object_files";
char*s115_1565A="&ds";
char*s635_511943145A="),(double)(";
char*s102_2037548A="Bad create instruction (type expected).";
char*s613_491029751A="/*agent is_equal*/int ";
char*s832_1111960899A="void gc_sweep";
char*s115_1471782099A="switch (expression->id) \173""\n";
char*s102_955584028A="Expression expected after the \"elseif\" keyword.";
char*s34_407540A="frozen";
char*s33_438300A="second";
char*s350_242535516A="Invalid type for the target of this procedure call.";
char*s714_161521A="))->o)";
char*s630_283285900A="while(1)\173""\n";
char*s115_1661632742A="]=atexit_profile;\n";
char*s716_2006740748A="\173""int i=o->id;\n";
char*s33_761722990A="mark_native_arrays";
char*s483_1319735562A="Cannot use anchored type for this form of creation.";
char*s102_1208507031A="Obsolete manifest string expected.";
char*s613_1185483839A="ds.locals=NULL;\n";
char*s124_3556890A="\" file.\n";
char*s103_1038536453A="Extra blank or tab character removed in multi-line manifest string.";
char*s612_1191155066A="(FILE* file,T";
char*s111_2011772281A="Unknown C mode: ";
char*s33_185934049A="NATURAL_16";
char*s715_1992734941A="GC_enable();\neiffel_root_object=NULL;\nGC_gcollect();\nhandle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s111_1626A="/Fe";
char*s408_2480479A="Overflow for opposite of Minimum_integer_64.";
char*s33_185934055A="NATURAL_32";
char*s30_7779A=".ACE";
char*s102_2055333675A="Slash \"/\" or decimal digit expected (inside CHARACTER constant).";
char*s115_1607940692A="se_profile_t agent_switch_profile";
char*s115_860532685A="handle(SE_HANDLE_NORMAL_EXIT, NULL);\n";
char*s111_2139128753A="The environment variable \"";
char*s716_1783951564A="if(gc_info_nb_agent)\n   fprintf(SE_GCINFO,\n   \"%d\\tagent(s) created. (store_left=%d).\\n\",\n   gc_info_nb_agent,store_left_agent);\n";
char*s115_1639A=";\nr";
char*s34_1532344910A="cpp_compiler_type";
char*s33_619776399A="Integer_bits";
char*s34_479921113A="c_compiler_type";
char*s476_522818189A="default_value";
char*s808_1644A=": \"";
char*s33_185934072A="NATURAL_64";
char*s636_32400A="));\n\175""";
char*s613_1923813010A="\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.current=";
char*s612_1646A="*o)";
char*s467_2141380032A="Any given feature name should appear at most once in one export clause for each parent clause. Feature ";
char*s102_1254996328A="Cannot use hexadecimal notation for this type.";
char*s832_687744958A="o=(void*)o->_";
char*s115_1650A=";\n\175""";
char*s630_1650A=")\173""\n";
char*s832_1651A="*p)";
char*s429_265238926A="Feature `manifest_put\' must have at least two argument and the first one must be an INTEGER argument.";
char*s111_7809A=".BAT";
char*s630_180037A=" else ";
char*s608_386149138A="pending_c_function_counter_tag";
char*s102_401981819A="..........................................................";
char*s115_1164208A="#ifdef _BASE_H\n#define _HAD_BASE_H\n#endif\n";
char*s572_1046299075A=" (from -cecil \"";
char*s716_1676A="*u)";
char*s33_1326673961A="object_size";
char*s715_112977096A="(GC_gc_no)";
char*s635_32435A=")))\174""(";
char*s832_44739A="=((gc";
char*s35_1994621A="gc_info";
char*s102_1289042164A="Void cannot be the left-hand side of the binary \"//\" operator.";
char*s635_32456A=")+.5)";
char*s115_1946737844A="Order of evaluation for pre-computed once functions:\n";
char*s115_14005A="[];\n";
char*s115_192841706A="NULL, NULL";
char*s376_1348774A="AT_EXIT";
char*s408_1337425939A=" which is out of range 0 ..63 because target type is INTEGER_64.";
char*s118_1875884480A="The local definition in ";
char*s543_142089811A="/etc/issue";
char*s433_1110386385A="You have to use another name for this formal generic argument. The common usage is to add an extra trailing underscore character (see for example COLLECTION, ARRAY or DICTIONARY).";
char*s115_7869A="&ds,";
char*s715_636642526A="(!GC_dont_gc)";
char*s287_2082988666A=" (The validation context is ";
char*s111_7878A=".CMD";
char*s630_1727A=":/*";
char*s418_183516812A="Attribute ";
char*s635_1586596820A="<<8)\174""((uint16_t)";
char*s636_29126717A="*((int16_t*)(";
char*s34_14036A="True";
char*s33_55926626A="std_input";
char*s115_48520827A="cecilcrea";
char*s630_1060489498A="requireresult=";
char*s610_161665A=" NULL\n";
char*s429_1857191624A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_semicolon_check\').";
char*s120_1797674551A="internal_exception_handler(Incorrect_inspect_value);\n";
char*s111_1744A=".cc";
char*s630_1115076A="=((T0*)";
char*s630_180128A=" else\173""";
char*s102_941240074A="Keyword \"end\" expected at the end of check clause.";
char*s277_608446371A="You have to fix the problem in your ACE file. Valid assertion level tags are: \"no\", \"require\", \"ensure\", \"invariant\", \"loop\", \"check\", \"all\", and \"debug\".";
char*s482_1753A="0e0";
char*s483_112048371A=" creation.";
char*s115_1852104762A=" C;\nint i=0;\nva_list pa;\nva_start(pa,argc);\nC=";
char*s118_22612837A=" in type ";
char*s115_1765A="=((";
char*s413_176104896A=" ... << ... >> \175"" manifest creation notation.";
char*s379_1712194128A="\' is out of INTEGER_8 range.";
char*s103_256559978A="Useless keyword deleted.";
char*s413_1458557644A="Creation clause exists for type ";
char*s96_1052333303A=" (compare usage and definition below).";
char*s102_1296817101A="). Instruction or keyword \"";
char*s111_1775A=".id";
char*s29_1128710280A="Liberty Eiffel does not (yet) support precompiled headers for\nthis C compiler. Please drop an e-mail liberty-eiffel@gnu.org%N";
char*s102_376006259A="Missing manifest STRING for `c_inline_c\'.";
char*s115_1364588829A=" se_manifest";
char*s378_7506001A="Current.";
char*s115_36778611A="local_profile.profile=profile+";
char*s102_970900228A="\" while waiting for some local variable name. Cannot use \"";
char*s610_565063403A="/* C Header Pass 2: */\n";
char*s458_2108232434A="The type of this constant feature should be STRING.";
char*s115_4049151A="((T0*)C)";
char*s832_1523807481A="*o1,*o2;\no1=((gc";
char*s498_920757291A="The value of ";
char*s402_1801A="::=";
char*s715_539192311A="void*bdw_markna;int bdw_generation;";
char*s102_1917483795A="Error while reading manifest number.";
char*s647_1658151484A=" misses some clients of the conforming parent(s) for ";
char*s115_1630601156A="during C code generation (backend)";
char*s109_89019087A="\" in type ";
char*s34_2185421A="require";
char*s34_251171752A="flat_check";
char*s102_1778077539A="Void cannot be the left-hand side of the binary \"-\" operator.";
char*s33_312005144A="type_can_be_assigned_to_attribute";
char*s102_1665385073A="The base type is no longer used. Class FUNCTION now has only two formal generic arguments. Just remove this unused type mark.";
char*s356_1771711260A="Symplify interrupted (infinite inlining\?) in CALL_0.\n";
char*s29_1464431905A="Usage: compile_to_c [options] <RootClass> <RootProcedure> ...\n   or: compile_to_c [options] <ACEfileName>.ace\n\nFor information about and examples of ACE files, have a look\nin the SmartEiffel/tutorial/ace directory.\n\nMost of the following options are not available when using\nan ACE file.\n\nOption summary:\n\nInformation:\n  -help               Display this help information\n  -version            Display Liberty Eiffel version information\n  -verbose            Display detailed information about what the compiler is\n                       doing\n\nWarning and Error levels:\n  -style_warning      Do print warnings about style violations\n  -no_warning         Don\'t print any warnings\n  -relax              Performs less checks by considering less dead code, hence\n                       using less memory and less compilation time. Useful to\n                       prototype or to deliver safe code. (Useful too for very\n                       small computers.)\n\nOptimization and debugging levels (specify at most one; default is"
" -all_check):\n  -boost              Enable all optimizations,\n                       but disable all run-time checks\n  -no_check           Enable Void target and system-level checking\n  -require_check      Enable precondition checking (implies -no_check)\n  -ensure_check       Enable postcondition checking (implies -require_check)\n  -invariant_check    Enable class invariant checking (implies -ensure_check)\n  -loop_check         Enable loop variant and invariant checking\n                       (implies -invariant_check)\n  -all_check          Enable \'check\' blocks (implies -loop_check)\n  -debug              Enable \'debug\' blocks\n  -flat_check         Each assertion will be executed in no_check mode\n                      Use with any mode from require_check to all_check\n\nClass lookup:\n  -loadpath <file>    Specify an extra loadpath file to read\n\nC compilation and run-time system:\n  -cc <command>       Specify the C compiler to use\n  -c_mode <C mode>    Specify a C mode to use. This option is incompatible\n        "
"               with -cc\n  -cecil <file>       Take CECIL information from <file>\n                       (may be used more than once)\n  -o <file>           Put the executable program into <file>\n  -no_main            Don\'t include a main() in the generated executable\n  -no_gc              Disable garbage collection\n  -bdw_gc             Use Boehm-Demers-Weiser conservative GC\n  -gc_info            Enable status messages from the garbage collector\n  -no_strip           Don\'t run \'strip\' on the generated executable\n  -no_split           Generate only one C file\n  -split <split mode> Selects the split mode\n                       Either \'no\', \'legacy\', or \'by_type\'\n  -sedb               Enable sedb, the Liberty Eiffel debugger\n  -profile            Generates profile on Eiffel calls at program exit\n  -manifest_string_trace\n                      Enable the trace support to track non-once\n                      manifest string creation\n  -no_rescue          Don\'t compile rescue sections\n\nMiscellaneous:\n  -high_memory_c"
"ompiler\n                      Allow the compile_to_c to use more memory; if you\n                      have enough physical memory, compilation should\n                      be faster (note: generated C code is not affected)\n";
char*s543_1826A=".se";
char*s125_75639A="_from";
char*s483_1832A="<< ";
char*s635_1651828280A="/* same_dynamic_type */\n";
char*s343_1813679543A="In the redefinition context (i.e in ";
char*s635_1214258443A="0;\nerror0(\"Invalid is_deep_equal.\",NULL)";
char*s635_167916A="((uint";
char*s635_1840A="<<(";
char*s635_108351709A="),sizeof(T";
char*s33_94407393A="collection_off";
char*s33_14150A="Void";
char*s832_32605A="*)(&(";
char*s102_50040236A="else part";
char*s115_1154403080A="print_profile(profile_file, &atexit_profile);\n";
char*s476_1468725331A="Required key \"";
char*s115_426087775A="#ifndef _HAD_BASE_H\nextern void*eiffel_root_object;\n\ntypedef T3*T9;\n#endif\n/* Available Eiffel routines via -cecil:\n*/\n";
char*s115_57150800A="atexit(se_atexit);\n";
char*s102_1021024803A="Manifest string expected for \"obsolete\" clause.";
char*s832_47598300A="o);\n\175""\n\175""\n\175""";
char*s280_1188332009A="This call should be some constant feature call (i.e. a statically computable value). (See the definition found in the next error message.)";
char*s102_603076667A="Writable entity expected here.";
char*s636_534333098A="<<8)&0xFF0000)\174""(((uint32_t)";
char*s832_692075493A="*)o)->header.flag==FSOH_UNMARKED))";
char*s115_107312226A="*sizeof(se_profile_t));\nqsort(sorted_agent_switch_profile, ";
char*s458_90390825A="Cannot use type ";
char*s115_267478119A="if(se_rci(caller,C))";
char*s35_2191641A="profile";
char*s612_565069653A="/* C Header Pass 4: */\n";
char*s636_2001063662A="\173""/*slice_copy*/\nint a3tmp=";
char*s35_822199910A="style_warning";
char*s102_2047202317A="Substitute with \";\".";
char*s635_32650A="))>>(";
char*s611_2057228449A="\173""Tid id;T0*o;\175"";\n";
char*s115_438660461A="Cannot produce C code.";
char*s102_502181838A="Missing \"\175""\" to terminate manifest generic creation.";
char*s102_307717976A="Error while reading a number. Missing \"\175""\" \?";
char*s109_327902A="TUPLE ";
char*s635_1900A=">>(";
char*s635_10089540A="floorf((";
char*s102_1938643327A="This call has a result value (and you must use it).";
char*s115_1580612071A="se_profile_t runinit_profile";
char*s578_1747685533A="typedef void*T";
char*s33_735034101A="storage_lower";
char*s102_376006384A="Missing manifest STRING for `c_inline_h\'.";
char*s458_573004463A="A character constant cannot be an assigner.";
char*s33_50778415A="exception";
char*s613_505232755A="/*agent creation*/T0*";
char*s628_36126743A="INT32_MIN";
char*s115_7918258A="SE_MAXID";
char*s830_413927315A="(x) (((se_agent0*)(x))->gc_mark_agent_mold((se_agent*)(x)))\n\n";
char*s716_1994852A="gc_mark";
char*s33_1530432238A="valid_generating_type_for_internals";
char*s635_887295984A="\n#if BYTE_ORDER == LITTLE_ENDIAN\n(";
char*s102_2061122069A="Error while reading a real. Missing separator after the value \?";
char*s102_945201499A="\'. May be, you just miss to add the \"is\" keyword\?";
char*s102_1933A="C++";
char*s572_992810240A="The type for a creation procedure cannot be INTERNALS.\n";
char*s33_88048A="put_0";
char*s115_950675891A="local_profile.profile=&runinit_profile;\n";
char*s33_88049A="put_1";
char*s571_942808765A="void manifest_string_mark";
char*s102_246527867A="Incorrect hexadecimal notation. Wrong number of hexadecimal digits (";
char*s111_69601A="a.exe";
char*s33_55041091A="put_32_be";
char*s102_4492176A="........";
char*s613_2111741A="locals[";
char*s832_27909038A="if(NULL==gc_find_chunk(o))\nreturn; /* external NA */\n";
char*s33_36200588A="INTERNALS";
char*s572_724183788A="The type for a creation procedure cannot be deferred.\n";
char*s111_683870135A="cc/warning=disable=(embedcomment,longextern) ";
char*s33_261093457A="make_blank";
char*s483_909851733A="Irregular number of items in bunches. The previous bunch is smaller.";
char*s33_1286698901A="element_sizeof";
char*s102_1505459217A="Keyword \"end\" added to terminate inherit/insert parent.";
char*s102_1421116705A="Slash \"/\" character expected after hexadecimal value in CHARACTER constant.";
char*s635_9794360A="deeptwin";
char*s111_1115301A="-x none";
char*s124_124992A="      ";
char*s613_2072064738A="struct rescue_context rc;\n";
char*s33_1680885744A="default_rescue";
char*s111_5525574A="-x \"c++\"";
char*s715_1933391A="bdw_ms[";
char*s715_1949186219A="/*mark_item*/";
char*s115_11086084A="sizeof(T";
char*s613_4996600A="*a1=(se_";
char*s102_676728857A="Error in manifest constant or \"\?:=\" type test \?";
char*s34_451011A="unique";
char*s33_55041141A="put_32_le";
char*s118_1127406485A="An attribute cannot be undefined.";
char*s109_2029530601A="Polymorphic Proceduire/Function Call";
char*s115_1492394528A=";while (i-->0) \173""\nsumup_profile(profile_file, sorted_all_profile+i);\n\175""\n";
char*s33_55041151A="put_32_ne";
char*s635_19199275A="!=NULL)\173""\n";
char*s124_1711985232A="Cannot write file \"";
char*s612_2039095413A="0(file,(T0**)";
char*s628_807791A="))->id)";
char*s102_1284361566A="Character \'%\"\' inserted after \"infix\".";
char*s109_1378502623A="Before simplify cycle";
char*s405_729510616A=" with expression ";
char*s630_28032126A="=((void*)";
char*s483_1646704683A="Unexpected \";\" (semicolon) separator in manifest generic expression. Less items found in this bunch than in the previous one.";
char*s115_1965252672A="]=((void*(*)(void*,char*,int*,int*))se_introspecT";
char*s628_161951A="((T0*)";
char*s280_1281353746A="\n      inherited as ";
char*s115_772432310A="local_profile.profile=agent_profile+";
char*s280_169314461A="No feature found for this call.";
char*s336_971287994A="Precondition";
char*s33_586229245A="type_is_expanded";
char*s635_484454800A="\" argument in external C inline definition.";
char*s638_1150927957A="*C,char*attr,int*id,int*exp)";
char*s33_1395184171A="same_dynamic_type";
char*s635_10089690A="floorl((";
char*s115_1307483215A="(&ds,&local_profile,C);\n";
char*s109_891552598A=" cannot be a root class since it is a deferred class.";
char*s115_1724182721A="local_profile.profile=&prof;\n";
char*s635_476433922A="deep_twin_from(";
char*s109_1145029170A="Internal compiler error (set_agent_creation_error_trap).";
char*s370_1970431863A="inspectDynamicDispatchExpression";
char*s103_446380143A="Unexpected comma (deleted).";
char*s115_826425832A="se_dump_stack*caller";
char*s628_21020045A="((void*)(";
char*s635_9954400A="if(!R)\173""\n";
char*s35_2028737205A="flymake_mode";
char*s111_186217457A="... unique once buffer ...";
char*s635_162010A="));\n\175""\n";
char*s115_1656195746A=" main(int argc,char*argv[])";
char*s109_1483967746A="Polymorphic Distribution of \"inspect\" Statements. Measurement\ndone ";
char*s402_1747372019A=" The left-hand side expression must conform to the right-hand side. The expression ";
char*s628_162019A="((T3)\'";
char*s635_162020A="((T3)(";
char*s613_2095A="CA_";
char*s638_5279655A="*id=-1;\n";
char*s409_1993565801A=" can be normally assigned into the left-hand side which is of type ";
char*s115_506210947A="se_general_trace_switch=1;\n";
char*s33_1300046706A="last_result";
char*s33_2104A="ANY";
char*s636_32860A="));\175""\n";
char*s636_2110A=";\175""\n";
char*s115_32869A="(&ds,";
char*s102_2001191A="current";
char*s613_1032053803A="se_dump_stack ds;\nds.fd=&fd;\nds.current=NULL;\nds.p=(caller->p);\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s829_788978585A="if(o->bdw_markna==NULL)\173""\nT0**markna;\nGC_disable();\nbdw_in_assign=1;\nmarkna=se_malloc(sizeof(T0*));\nGC_REGISTER_FINALIZER_NO_ORDER(markna,(GC_finalization_proc)bdw_na_markT";
char*s483_1427483140A="Missing argument before << ... >> item list.";
char*s829_546112503A="void bdw_run_finalizers(void)";
char*s335_977955761A="SEDB object";
char*s34_408086A="export";
char*s115_531983658A="local_profile=global_profile;\n";
char*s542_1806821466A="specializing and checking";
char*s34_251916328A="cpp_strip_path";
char*s102_1176245553A="Anchor expected. An anchor could be `Current\', a feature name or an argument name.";
char*s96_1781104140A="Deferred class should not have creation clause (VGCP.1).";
char*s113_57487A="Amiga";
char*s115_451157A="unlink";
char*s635_8291A="(int";
char*s612_205124A="(file,";
char*s482_2009909053A="...........................................................";
char*s635_162070A="((T5)(";
char*s34_69805A="Tools";
char*s625_2150A="CL_";
char*s638_1113554587A="void*R=NULL;\n";
char*s115_10944785A="se_msi1(";
char*s115_389672A="char*p";
char*s115_389675A="char*s";
char*s571_147115629A="=/*alloc*/((T0*)(";
char*s832_1927425A="begin:\n";
char*s833_14464A="\\n\",";
char*s376_202031759A="STD_OUTPUT";
char*s102_2051403723A="Added \"end\" to finish this \"if\" statement.";
char*s630_162095A="((T6)(";
char*s714_2138778683A="se_malloc(sizeof(T";
char*s280_32926A=", ...";
char*s124_461074983A="The old \"SmallEiffelDirectory\" variable is not valid anymore. Please use SmartEiffelDirectory or,\nbetter still, don\'t use it at all.\n";
char*s408_900982204A="Overflow of infix \"+\" with INTEGER_16 operands. (Adding ";
char*s113_2178A="DOS";
char*s34_401994A="flavor";
char*s829_1744880961A=")se_calloc(*n, sizeof(T";
char*s33_2035472654A="type_attribute_count";
char*s829_42739336A="(&n);\nif(GC_should_invoke_finalizers())bdw_run_finalizers();\nreturn R;\n";
char*s103_2131871127A="Same identifier appears twice (local/closure).";
char*s999_482960256A=">. The plugin seems to depend on itself! Ignored.";
char*s111_69851A="a.out";
char*s542_1243691337A="getting started";
char*s115_1826935309A="memcpy(sorted_inv_profile, inv_profile, ";
char*s34_2032026A="exclude";
char*s635_1726920051A="se_deep_equal_start();\n";
char*s34_264667428A="assertion_flat_check";
char*s115_351488799A="/*unknown position*/";
char*s102_4750778A=" warning";
char*s115_383570A="agents";
char*s829_1005223232A="void bdw_na_markT";
char*s635_1240185282A="Bad prototype for C struture set external.";
char*s34_820292A="****** ";
char*s118_1585514726A=", features \"";
char*s115_1637927398A="se_local_profile_t*parent_profile";
char*s277_698011541A="Cluster tree:\n";
char*s396_529996976A="Conflict between local/feature name (VRLE).";
char*s118_1297180456A=" because there is a local definition in this class. Redefine has been automatically added. Please check.";
char*s33_1447702A="INTEGER";
char*s111_1255802680A="emxbind -qs";
char*s526_922867504A="This obsolete manifest ARRAY creation is no longer supported. See our \"SmartEiffel/tutorial/manifest_notation.e\" in order to use the new notation.";
char*s34_88336A="short";
char*s102_599810839A="There is no need for the \"expanded\" keyword in an \"insert\" clause.This keyword will be ignored.";
char*s612_1112927266A="void se_prinT";
char*s33_840111968A="collection_on";
char*s483_115013643A="Actually, for class ";
char*s635_234933541A="_t)-((uint";
char*s32_1181006553A="Feature `default_rescue\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s102_1023251859A="Replaced misspelled \"False\".";
char*s750_2114672999A="Using range inside inspect of type STRING is not possible.";
char*s408_442652821A=" which is out of range -31..31 because target type is INTEGER_31.";
char*s109_601041072A="class-path: \"";
char*s429_797085749A=". An expanded type must have one unique creation procedure with no argument: the creation procedure used for automatic initialization.";
char*s33_1297432701A="is_infinity";
char*s832_5839580A=".store;\n";
char*s33_2067759348A="from_pointer";
char*s613_832670A="(*afp)(";
char*s638_8436A="*id=";
char*s440_408035024A=" is hiding the definition in ";
char*s647_1679625106A="The final client list for ";
char*s334_864187036A="Loading cecil entries:\n";
char*s716_1155996628A="/*mark_item*/\175""";
char*s33_1209184326A="object_invariant";
char*s102_700613496A=" is not a valid feature name to start a new feature definition. Parser lost. Sorry. Check before and after that point.";
char*s635_45355A="=*C;\n";
char*s638_1245850444A="\173""\nstatic T0*_r=NULL;\n_r=";
char*s118_1041926341A="The feature ";
char*s613_2301A="R&=";
char*s102_1689577436A="Expression expected after \"elseif\" keyword.";
char*s33_1604515261A="to_internals";
char*s635_1096165867A="is_deep_equal(";
char*s102_860582570A="\" cannot be a valid feature name or a valid local name (only lower case letters are allowed here). Furthermore \"";
char*s543_2003309199A="/etc/xdg/liberty-eiffel";
char*s635_245384155A="clear_all(";
char*s115_1816632501A="se_local_profile_t local_profile;\n";
char*s118_1811139659A=" type.\n\nFirst \"insert\" path (from parent to child):\n   ";
char*s33_728963476A="type_item_generating_type";
char*s33_9647090A="and then";
char*s716_8475A="(se_";
char*s832_945011211A="=(((void*)obj_ptr)<=((void*)item));\nobj_ptr = (T0*)(((char*)obj_ptr) + obj_size);\nif (swept != (((fso_header*)obj_ptr)->flag==FSOH_UNMARKED)) /* **** TODO: was FSOH_UNMARKED\?\?\?\? (incoherent with comment below) */\n/* (already swept) xor marked */\nitem->o=NULL;\n\175""\n";
char*s102_28789007A="Actually, a creation list must not be empty. You must have at least the `default_create\' procedure inherited from ANY. The `default_create\' indicates that one can also create an object with no creation procedure. The `default_create\' has been added here automatically.";
char*s102_1874765620A="A missing client clause is interpreted as \173""ANY\175"". It is better to be explicit.";
char*s113_395994A="distcc";
char*s635_8485A="(vc(";
char*s110_546635553A="SMART_EIFFEL_SHORT_VERSION";
char*s635_1553763390A=")==(a1ptr->_";
char*s115_20552830A="(&ds,C);\n";
char*s646_1664721281A="........... unique buffer ...............";
char*s102_1752914319A="Instruction expected here. False alone is not an instruction.";
char*s102_2020913390A="Added missing \"then\" keyword.";
char*s34_414461A="insert";
char*s613_1426099398A=".............................";
char*s102_156243902A="Void cannot be the target of prefix operator \"";
char*s627_1476205446A="fcstrangeisnotunlock";
char*s630_1936367907A="/*inspect]*/\n";
char*s277_1955866577A="external_lib_path";
char*s33_10938831A="se_fault";
char*s646_1025503229A=" using range tmp0 .. tmp";
char*s115_273715710A="#ifdef SIGINT\n                                                    signal(SIGINT,se_signal_handler);\n#endif\n#ifdef SIGTERM\n                                                    signal(SIGTERM,se_signal_handler);\n#endif\n";
char*s454_914877497A="Same feature name appears twice.";
char*s832_1653483427A="typedef struct Sgc \173""Tid id;T0*o;\175"" Tgc;\n";
char*s635_244793715A="deep_twin(";
char*s372_1360462097A="reference: ";
char*s787_1121854A="/bin/sh";
char*s343_2084982239A=" context, it appears to be a call to an obsolete feature:\n";
char*s33_175767198A="EXCEPTIONS";
char*s647_1238684603A="The client list computed from the \"export\" clauses";
char*s111_45436A=".make";
char*s832_737599544A="=o1;\n\175""\n\175""\n\175""\nelse\173""\nint dead=1;\ngc";
char*s115_419316052A="/*Force definition of non-live NATIVE_ARRAY[CHARACTER] for manifest strings*/\ntypedef T3* T9;\n";
char*s115_2382A="T0*";
char*s115_732574181A=";\nwhile (i < argc ) \173""\n";
char*s96_1452647150A="Forbidden creation call (i.e. exportation rules violated). Creation is only allowed from ";
char*s372_41841490A="FIXED_STRING";
char*s111_217674A=".h.gch";
char*s115_149822297A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_agent_switch_profile+i);\n\175""\n";
char*s608_1359151955A="internal_c_local_tag";
char*s608_8545A=":*/\n";
char*s643_2394A="T11";
char*s613_126319331A="rescue_context_top = rc.next;handle(SE_HANDLE_EXCEPTION_CLEAR,NULL);\n";
char*s115_1965511388A="/*INIT CLOSURE LOCALS]*/\n";
char*s115_2395A="R=(";
char*s643_2395A="T12";
char*s102_1478844272A="Removed that non-significant digit in integral part or real constant.";
char*s102_1223700793A="Inside a function, a Precursor call must be a function call (not a procedure call).";
char*s102_529554293A="Removed unexpected blank space(s) just before this dot (assume you really want to call a function using the previous manifest expression as the target).";
char*s287_63912A="Line ";
char*s102_2117988535A="Void is not a valid BOOLEAN expression (just after keyword \"elseif\").";
char*s109_2114217978A="Monomorphic Function Call";
char*s716_1327517381A="#ifndef FIXED_STACK_BOTTOM\nif(!valid_stack_bottom) stack_bottom = NULL;\n#endif\n";
char*s630_2065182209A="if(!requireresult)\173""\n";
char*s115_1530032908A="fprintf(profile_file, \"\\n-------------------------------------------------------------------------------\\n\");\ni=";
char*s405_1222747401A=". (This would always yield to a ";
char*s109_768828206A="Looking for ";
char*s277_2070822678A="The \"adapt\" clause is not yet implemented.";
char*s34_76226A="adapt";
char*s102_439136A="select";
char*s115_2417A="T7*";
char*s440_146113272A="The definition of ";
char*s96_2123229206A=" is obsolete:\n";
char*s277_763815152A="\nYou are in command line mode (i.e. no ACE file is used).\nThe load path can be changed using a file called\nloadpath.se in the current working directory.\nUsually, this loadpath.se file is a simple list of directories.\nIt is also possible to use system variables or include files. See\nthe documentation for the finder command for more information.\n";
char*s277_957054969A="-debug_check is deprecated. Please use -debug and another -*_check assertion level. This defaults to -all_check.";
char*s489_180503525A=".......................";
char*s113_2440A="OS2";
char*s277_556698697A=": error: No <Root-Class> in command line.\n";
char*s111_6159594A="C mode \"";
char*s829_82948679A=")bdw_malloc_innerT";
char*s611_199280A=",NULL\175""";
char*s715_645592960A="s=(T7*)bdw_mallocT7(1);\n";
char*s124_1974940930A="\" variable used";
char*s635_8779932A="Unknown ";
char*s635_168532A="*)R)=M";
char*s543_1646495986A="Configuration chain (the lower the more specific):";
char*s638_1956008156A="\175"" else \173"" *id=0; \175""\n";
char*s103_274238642A="Deleted extra comma.";
char*s33_2090604340A="full_collect";
char*s33_591414963A="standard_copy";
char*s116_1753572602A="Infinite inlining loop (bad recursion \?\?). ";
char*s102_614881029A="Syntax error while trying to parse a conversion clause. Expected either \'(\' or \':\'";
char*s577_11381817A="typedef ";
char*s630_48939825A="default:\n";
char*s103_332623945A="Bad creation/create (procedure name expected).";
char*s408_282345691A=" which is out of range -7..7 because target type is INTEGER_8.";
char*s571_1119207694A="&gc_local_profile";
char*s716_118716790A="fprintf(SE_GCINFO,\"==== Last GC before exit ====\\n\");\ngc_start();\n";
char*s630_48939847A="default: ";
char*s102_554066118A="\" is not valid identifier. For a better readability Liberty Eiffel _is_ case sensitive. Hence \"";
char*s102_1439398002A="A Precursor type mark annotation must not be anchored.";
char*s476_1917908900A="feature_name";
char*s102_1193216533A="A type mark is not a valid item for a manifest array. Keep in mind that Liberty Eiffel is case-sensitive and that ";
char*s630_279959115A="\173""\nse_dump_stack *caller=&ds;\n\173""\nse_dump_stack ds=\173""NULL,NULL,caller->p,caller,NULL,NULL\175"";\n";
char*s102_277837020A="Missing items in manifest creation \"<< ... >>\" list. The last bunch should have ";
char*s33_2504A="SET";
char*s105_1656731300A=" in the section [";
char*s716_49917876A="if(NULL!=";
char*s543_193194A="/.serc";
char*s113_207986277A="OpenVMS_CC";
char*s102_180894A=" error";
char*s829_2075405A="na=o->_";
char*s827_125876584A="GC_call_with_alloc_lock((GC_fn_type)bdw_na_assignT";
char*s290_1477688005A=": unsupported option \"";
char*s336_1777506207A="Check_instruction";
char*s34_402346A="ensure";
char*s635_33291A="((int";
char*s124_2537A="No ";
char*s102_761631659A="Cannot use an uppercase letter inside such an identifier. Yes, this rule is strict, but it is better for all of us to be able to distinguish at a glance a CLASS_NAME from another name. Furthermore, it would be really too bad for example to use `IsEmpty\' or `isEmpty\' at one place while all other places are using `is_empty\'. Finally, this strict constraint will help us to improve error messages of the compiler.";
char*s379_2126200255A="................................";
char*s120_584218374A="setup_signal_handler();\n";
char*s115_2545A="\n*/\n";
char*s613_1575353618A="static se_frame_descriptor fd=\173""\"Agent launcher\",0,0,\"\",1\175"";\n";
char*s829_886939850A="**markna,void*_)";
char*s578_33316A="* o2)";
char*s33_1223768616A="NATURAL_GENERAL";
char*s830_2082029949A="\173""0,NULL,NULL,NULL,(void(*)(T0*))";
char*s696_2565A="[1-";
char*s102_1909918820A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure to the previous `False\' constant as target).";
char*s647_1711825865A="Multiple Precursor found (must use Precursor \173""...\175"" ancestor selection).";
char*s33_744845610A="valid_generating_type_for_native_array_internals";
char*s716_1637706318A="GC support: adding root functions.\n";
char*s408_1670460393A="Overflow of infix \"-\" with INTEGER_16 operands. (";
char*s543_64080A="Linux";
char*s635_2571A="]))";
char*s115_10028705A="s,e,c);\n";
char*s635_1079001A="(void*)";
char*s613_1489891655A=" features).\n";
char*s405_1182157125A="The declaration type of ";
char*s635_37173080A="R,a1-1);\n";
char*s578_3920780A="(&(o1->_";
char*s113_76405A="bcc32";
char*s118_305596576A=") there are two versions of the same initial feature with two different names. To  fix this, either use an \"insert\" link in place of one of the \"inherit\" links or rename the feature to get the same name in ";
char*s115_1361175839A="init_profile(profile+";
char*s277_22915075A=" items):\n";
char*s115_218061703A="*/\nse_signal_handler(14/*System_level_type_error*/);\n";
char*s111_98806116A=" Data=Auto";
char*s34_82570A="infix";
char*s716_411283072A="/*Ordinary once functions:*/\n";
char*s102_1731250773A="Empty generic list (deleted).";
char*s32_1194182360A="Feature `default_create\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s102_1564737054A=" after the $ operator. ";
char*s30_8771A=".ace";
char*s103_894954671A="In extended form of manifest string. Bad character after \'%\'.";
char*s572_950159899A="Error while loading features of cecil path file \"";
char*s102_2992013A="Unknown external language specification.";
char*s110_51203551A="2013.11 (Charles Adler, Jr.)";
char*s115_2630A="];\n";
char*s34_114085235A="# End of parallelizable section";
char*s111_1247935972A="\" environment variable\nwith the absolute path of your own hand-made SmartEiffel\nconfiguration file.\n";
char*s115_1308400309A="#define SE_EXCEPTIONS 1\n";
char*s636_1773508175A="<<24\174""(((uint32_t)";
char*s111_8801A=".bat";
char*s635_524787520A="((uint8_t)(";
char*s111_530877013A=" StripDebug";
char*s458_789877170A="Unique feature must have INTEGER type.";
char*s102_1098712729A="Manifest value not compatible with this type.";
char*s635_1116064705A="(T6)!memcmp(C,&a1,sizeof(T";
char*s636_1053613605A=";\nmemcpy(&((";
char*s458_783418632A=". Bad constant-attribute definition.";
char*s571_2670A="]=(";
char*s115_33425A=")->id";
char*s374_292944046A=" Bad assignment.";
char*s832_1069766146A=".store_left;\n";
char*s33_88795A="third";
char*s808_480414235A="Unknown loadpath in ";
char*s109_1572647306A="The feature called has ";
char*s834_585110409A=".store->header.size=";
char*s115_1082664800A="start_print_profile(profile_file);\n";
char*s793_1309286095A="XDG_CONFIG_HOME";
char*s121_138929174A="\" seems to be empty.";
char*s635_1263916320A="fpclassify(";
char*s30_1010347497A="Flag -is_output_error_warning_on must be used only once.\nYour command was:\n";
char*s34_2063276A="include";
char*s33_201970776A="force_to_integer_64";
char*s34_396356A="create";
char*s635_1023363018A=")=*C;\nse_deep_twin_register(((T0*)C),";
char*s476_1089314041A="An external \"plug_in\" must be described with an alias clause. (Have a look in our standard library or in our tutorial for examples.)";
char*s33_201970793A="force_to_integer_32";
char*s280_2089269822A="The huge generic derivation related to the previous warning is: ";
char*s33_756809447A="Minimum_real";
char*s625_23647157A="/*empty*/";
char*s35_234165132A="manifest_string_trace";
char*s33_201970799A="force_to_integer_16";
char*s577_15019A="_t T";
char*s34_479922190A="c_compiler_path";
char*s635_15020A="_t)(";
char*s115_33475A="((se_";
char*s467_1172758533A="There should be at most one export clause with the \"all\" keyword in each parent clause. The client lists will be merged, but please fix the export clauses.";
char*s647_1912840703A="Keyword \"ensure\" replaced with \"ensure then\" because there is an inherited ensure assertion.";
char*s115_1934139A="caller,";
char*s343_1646268668A=" These two inherited features have the same name in type `";
char*s115_8880A=",lsi";
char*s111_8884A="-x c";
char*s635_8885A=")\174""\174""(";
char*s542_520647979A="The system is type safe.\n";
char*s405_112006296A=" context.)";
char*s111_8889A=".com";
char*s115_941548611A="memcpy(sorted_all_profile+";
char*s716_1637595774A="(eiffel_root_object);\nmanifest_string_mark1();\nonce_function_mark();\n";
char*s32_8897A=".cpp";
char*s102_45224899A="Keyword \"until\" expected (in a loop).";
char*s110_1359484467A="(C) #(1) - #(2)";
char*s115_162838175A="se_dump_stack*caller,";
char*s33_30191860A="type_attribute_is_expanded";
char*s115_2753A="]=\173""";
char*s277_1251030042A="End of text expected (invalid ACE file).";
char*s636_851596A=" a1tmp=";
char*s115_900404594A="/* CECIL creation */\n\173""\n";
char*s29_1525604536A="Only the flags -verbose, -version, -help and -relax are allowed in ACE\nfile mode.\n";
char*s33_1673345408A="open_argument_count";
char*s33_954385774A="Pointer_bits";
char*s287_10926944A="prefix \"";
char*s432_1666936074A=" must insert ";
char*s829_1004947005A="g=o->_generation;\n";
char*s115_1089314127A="#ifdef SIGQUIT\n                                                 signal(SIGQUIT,se_signal_handler);\n#endif\n#ifdef SIGILL\n                                                 signal(SIGILL,se_signal_handler);\n#endif\n#ifdef SIGABRT\n                                                 signal(SIGABRT,se_signal_handler);\n#endif\n#ifdef SIGFPE\n                                                 signal(SIGFPE,se_signal_handler);\n#endif\n#ifdef SIGSEGV\n                                                 signal(SIGSEGV,se_signal_handler);\n#endif\n#ifdef SIGBUS\n                                                 signal(SIGBUS,se_signal_handler);\n#endif\n#ifdef SIGSYS\n                                                 signal(SIGSYS,se_signal_handler);\n#endif\n#ifdef SIGTRAP\n                                                 signal(SIGTRAP,se_signal_handler);\n#endif\n#ifdef SIGXCPU\n                                                 signal(SIGXCPU,se_signal_handler);\n#endif\n#ifdef SIGXFSZ\n                                                 signal(SIGXFSZ,"
"se_signal_handler);\n#endif\n";
char*s102_1007106012A="Local name ";
char*s408_2004103151A="Overflow of infix \"+\" with INTEGER_8 operands. (Adding ";
char*s96_672350142A="\nassertion-level: ";
char*s715_1517878904A="GC_gcollect();\nif(GC_should_invoke_finalizers())bdw_run_finalizers();\n";
char*s472_946986142A=" type is not allowed as a variant type.)";
char*s832_236525A="==1)\173""\n";
char*s33_827429162A="type_item_generator";
char*s715_1215237414A="#ifndef GC_DEBUG\n#define GC_DEBUG 1\n#endif\n";
char*s832_2142119302A="* obj_ptr = (gc";
char*s716_444775459A="\173""int i=SE_MAXID-1;\nwhile(i>=0)\173""\nif(t[i]!=NULL)gc_mark7(t[i]);\ni--;\175""\n\175""\n";
char*s335_311661671A="No SEDB objects added.\n";
char*s276_758913190A="Correct part: \"";
char*s829_1020256883A=")bdw_weakref_new(*n);\n*R=M";
char*s33_253393261A="for_object";
char*s115_1040899642A="C Compiler options used: ";
char*s276_319940936A=".... local unique buffer ....";
char*s34_1509818A="General";
char*s111_8976A=".exe";
char*s103_1581369567A="Decimal CHARACTER code out of range.";
char*s102_2137524537A="Inside an \"inspect\" statement for type STRING, the slice notation \"..\" is not allowed.";
char*s716_1246644455A="gc_info();\n";
char*s115_1136523103A="union _se_agent\173""T0 s0;se_agent0 u0;\n";
char*s113_2833A="g++";
char*s429_1529695024A="Invalid manifest equipment (must be greater than 1).";
char*s343_556920526A=" is not a valid redefinition for ";
char*s440_1026844627A="\" (check your ACE file).";
char*s716_567426438A="u->gc_mark_agent_mold=gc_mark_";
char*s111_8991A="/fe=";
char*s635_2217200A="sizeof(";
char*s408_1143055473A=" which is out of range 0..31 because target type is INTEGER_31.";
char*s111_1331737400A="Local Loadpath";
char*s490_76659A="agenT";
char*s115_985140858A="])(void*,char*,int*,int*)";
char*s277_961330339A="Cannot open \"";
char*s636_177459204A="\n#if BYTE_ORDER == LITTLE_ENDIAN\n";
char*s418_936707889A=" not found in type ";
char*s118_612334905A="A frozen feature must not be redefined. What is frozen _is_ frozen.";
char*s111_1431838787A="\" environment\nvariable whatever the kind of your operating system is.\nIf you prefer that way, set the \"";
char*s832_52067A="=c;\n*";
char*s411_1721243342A=" type cannot be used here. Actually this is only a compiler implementation facility.";
char*s102_1207880883A=" Unable to parse definition of `";
char*s115_400297641A="se_local_profile_t*parent_profile,";
char*s635_4204001A="((void*)";
char*s376_2870A="_P_";
char*s115_1746979137A=",expression,/*unknown-position*/0);\n";
char*s115_1591358844A="if(assertion_depth)\173""\nassertion_depth--;\n";
char*s33_52347889A="mark_item";
char*s33_76691A="agent";
char*s109_1574136045A="Finished optimization (";
char*s334_36115402A="All type marks used in a cecil file have to be static (no anchors).";
char*s388_527180488A=" of this Unicode manifest string. ";
char*s115_2883A="i++";
char*s102_1910823336A="\" has been automatically replaced with \"";
char*s832_618166083A="++;\n\175""\n\175""\nn->header.flag=FSOH_UNMARKED;\n";
char*s33_1095772782A="collector_counter";
char*s111_218174A="-s -d1";
char*s635_907447617A=";\nif(o1==o2)\173""\175""\nelse if(NULL==o1)\173""R=0;\175""\nelse if(NULL==o2)\173""R=0;\175""\nelse \173""R=";
char*s115_786180653A="se_frame_descriptor irfd=\173""\"<runtime init>\",0,0,\"\",1\175"";\nse_dump_stack ds = \173""NULL,NULL,0,NULL,NULL,0\175"";\nds.fd=&irfd;\n";
char*s829_1871081731A=";\nif(na)for(i=0;i<c;i++)\173""\ne=na[i];if(e)na[i]=(T0*)HIDE_POINTER(e);\175""\n";
char*s473_1057882626A="Expression of until must be of BOOLEAN type. (The actual ";
char*s284_15195A="_ix_";
char*s33_869539012A="sedb_breakpoint";
char*s613_1728089446A="se_frame_descriptor se_ifd";
char*s635_1671063525A="((uint64_t)(";
char*s85_522142839A="Collecting Cecil features.\n";
char*s829_15205A="o);\n";
char*s115_54734511A="se_prinT[";
char*s647_1691484858A="The export clause is ignored, the redefinition \"feature\" client list will be used instead.";
char*s635_520377520A="((int32_t)(";
char*s33_1574640467A="trace_switch";
char*s111_9073A=".lib";
char*s635_39831A=",NULL";
char*s608_1971245A="closed_";
char*s336_580435889A="Postcondition";
char*s33_48958735A="deep_twin";
char*s102_727272566A="Entity `Current\' is not writable. Cannot use `Current\' for the left-hand side of an assignment.";
char*s105_1377150320A="\'. Maybe the program name is incorrect, or process execution is not yet supported on this platform.";
char*s33_170256464A="FAST_ARRAY";
char*s102_1953566687A="The type mark must be specified just after the \"Precursor\" keyword.";
char*s647_81368369A="The client list computed from the \"export\" clauses is narrower than the one from";
char*s290_624587783A="string_command_line";
char*s123_2947A="fBC";
char*s34_8054609A="Loadpath";
char*s111_9107A=".lnk";
char*s458_947318471A=" to define a constant.";
char*s716_1230018439A="gc_mark(u->CA_";
char*s111_9121A=".obj";
char*s376_181352A=" from ";
char*s716_497096041A="gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));\n#ifdef FIXED_STACK_BOTTOM\nif (!stack_bottom) stack_bottom=((void**)(void*)(&argc));\n#endif\n";
char*s999_387651299A=">, module_name <";
char*s635_2118444283A="R=(C->id==a1->id);\nif(R)\173""\n";
char*s115_9130A="=0;\n";
char*s796_1182938696A="a_file_name";
char*s111_2109537640A="...This is a local once buffer...";
char*s32_2057783129A="Feature `deep_twin\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s613_759184012A="rc.next = rescue_context_top;\nrescue_context_top = &rc;\n";
char*s115_374291339A="char* se_atT[";
char*s115_712350300A="init_profile(&atexit_profile, \"<atexit>\");\n";
char*s111_415107A="lcclnk";
char*s102_1775667520A="In an object-oriented language, the receiver of a call is always associated to some existing object (i.e. `Current\' is never Void). Hence, such a weird comparison is not allowed.";
char*s716_679909928A="gc_mark(*(u->CL_";
char*s635_2996A="_t)";
char*s832_998144220A=".store=((rsoh*)(((char*)(";
char*s115_1582839830A="qsort(sorted_all_profile, ";
char*s33_180965424A="INTEGER_16";
char*s376_732402575A=" (magic count = ";
char*s33_180965430A="INTEGER_32";
char*s715_1110320023A="void* bdw_ms[";
char*s376_44462444A="c-type: T";
char*s115_1540564023A="r7from_external_sized_copy(";
char*s115_1281004126A="eiffel_root_object=((T";
char*s115_1450568746A="/* Void call detected in back-end (function called: \173""";
char*s102_188494264A="else of inspect";
char*s115_1982839385A=");\n\175""\nva_end(pa);\nreturn ((T0*)C);\n";
char*s33_11001014A="set_item";
char*s33_180965447A="INTEGER_64";
char*s102_167445550A="Inside a procedure, a Precursor call must be a procedure call (not a function call).";
char*s33_10945665A="print_on";
char*s115_3040A="ci(";
char*s571_1757386798A="se_frame_descriptor gcd=\173""\"Garbage Collector at work.\\n\"\n\"dispose called (during sweep phase)\",0,0,\"\",1\175"";\nse_dump_stack ds = \173""NULL,NULL,0,NULL,NULL\175"";\nds.fd=&gcd;\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s103_1708886163A="Invalid free operator (the last character must be a member of this +-*/\\=<>@#\174""& character list.).";
char*s287_1661812564A="Internal Error";
char*s277_2028436769A="The \"case_insensitive\" option is no longer supported.";
char*s115_15351A="base";
char*s647_214672950A="The \"feature\" clause declares a client list that";
char*s33_2174354A="realloc";
char*s613_1111279623A="void**locals[";
char*s647_1961403182A=". This type should be marked as deferred.";
char*s638_2117730851A="**)C)+atoi(attr));\n";
char*s284_15370A="_px_";
char*s118_69115705A="FEATURE_STAMPs total number = ";
char*s111_9220A=".res";
char*s113_3069A="ccc";
char*s283_1492303331A=" is not generic.";
char*s111_9222A=".scf";
char*s102_723705127A="Dot expected here because a manifest-string alone is not an instruction.";
char*s118_1008693261A="Assigner feature is not a command in type ";
char*s277_3073A="all";
char*s33_3075A="and";
char*s102_1922694958A="Replaced misspelled \"Void\".";
char*s832_33836A="* wr)";
char*s277_817932306A=" without point of view!\n";
char*s118_840703310A="\n\nSecond \"inherit\" path (from parent to child):\n   ";
char*s34_3085A="bin";
char*s34_51843716A="invariant";
char*s115_1145546877A="...........................";
char*s402_1896547075A="assignment attempt (\"\?=\").";
char*s476_1014770470A=":\" not found";
char*s111_3094A="dcc";
char*s613_1125599189A="return((T0*)u);\n";
char*s30_546820847A=". Bad flag ";
char*s113_1663868A="OpenVMS";
char*s35_89216A="split";
char*s638_138425A="\")) \173""\n";
char*s832_15405A="o->_";
char*s474_384465A="basic_";
char*s103_1923039443A="Underscore in number must group exactly 3 digits.";
char*s716_1197879602A="gc_dispose_before_exit();\n";
char*s33_1856946950A="Minimum_character_code";
char*s33_39154229A="PROCEDURE";
char*s102_370754643A="Bad external alias clause.";
char*s102_188014584A="Replaced misspelled \"Current\".";
char*s109_1066764899A="Void target Procedure/Function Call";
char*s832_33875A=");\n\173""\n";
char*s102_1502870799A="Bad empty character constant.";
char*s115_1737592965A="*/: return 1;\n";
char*s102_144939139A=" cannot be used just after agent keyword (it does not denote a feature call).";
char*s102_1409701608A="No more class BIT since release 2.1. Just use bit operations from  INTEGER_8, INTEGER_16, INTEGER_32, INTEGER or INTEGER_64.";
char*s102_1550836304A="Keyword \"class\" expected.";
char*s352_1186844731A="Bad target type. The expected type is ";
char*s379_30745830A="\' is out of INTEGER_32 range.";
char*s429_1134247532A="Found two possible default creation procedures for expanded type ";
char*s115_375072661A="char**se_argv";
char*s829_1278999019A="GC_invoke_finalizers();\nhandle(SE_HANDLE_EXIT_GC,NULL);\175""\n";
char*s753_849265556A=". Please check unicode charts.";
char*s109_298390A="Done.\n";
char*s102_734506354A="Opening \"<<\" of manifest generic creation expected.";
char*s111_721564652A=" NoVersion NoIcons";
char*s33_15448A="call";
char*s384_3147A="cpp";
char*s613_26975282A="(void*)&C";
char*s102_822318035A="Replaced misspelled \"Result\".";
char*s115_756717624A="Procedure without Current";
char*s33_207673214A="force_to_real_64";
char*s102_1926379486A="Ignored extra \",\".";
char*s646_1901947715A="/*[INTERNAL_C_LOCAL list*/\n";
char*s613_26975293A="(void**)&";
char*s487_1329824754A="Using `Void\' as an item of a manifest TUPLE is not good practice because `Void\' has no accurate type. You can work around by using an extra non-initialized local variable of some accurate type. Another work around is to use an explicit creation of the TUPLE. As an example `create \173""TUPLE[STRING,ANY]\175"".make_2(Void,Void)\' can be used to create a TUPLE[STRING,ANY] with default values.";
char*s277_2040665077A="Invalid collect value: must be either yes, no, or \"bdw\"";
char*s115_1811657197A="se_frame_descriptor fd=\173""\"<atexit wrapper>\",0,0,\"\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=NULL;\nds.exception_origin=NULL;\nds.locals=NULL;\nds.depth=0;\n";
char*s113_3169A="gcc";
char*s33_207673231A="force_to_real_32";
char*s630_3175A="if(";
char*s35_2248290A="version";
char*s34_3175A="end";
char*s635_653639191A="The `deep_twin\'/`is_deep_equal\' problem comes from this attribute.";
char*s118_938738041A="It is useless to undefine this deferred method.";
char*s832_884381655A="*)o)->header.flag=FSOH_MARKED;\n";
char*s716_3181A="elt";
char*s714_146599966A="*)se_malloc(sizeof(void*)))";
char*s716_156962A="(&(u->";
char*s697_46245A=".secd";
char*s103_1452518781A="Expected \"]\" (to finish generic argument list).";
char*s109_689013605A="Expanded Target Function Call";
char*s277_1389956963A="Please, also note that you can use the \"ace_check\" command\nto view all informations stored into your ACE file.\n";
char*s115_36460172A="Defining ";
char*s33_7095298A="FUNCTION";
char*s478_3196A="get";
char*s115_323348966A="se_general_trace_switch=(";
char*s115_2101369329A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_profile+i);\n\175""\n";
char*s33_280482649A="Boolean_bits";
char*s832_244523906A="=o1;\n\175""\n\175""\nif (dead)\173""\ngc_free";
char*s832_3209A="\173""\nT";
char*s635_802840A="))))\174""((";
char*s635_1679626025A="((real64_t)(";
char*s613_3212A="u->";
char*s487_2088401A="make_..";
char*s630_602573626A="\173""int requireresult=1;\n";
char*s346_97896378A=" into formal type ";
char*s109_633144097A="The current directory ";
char*s111_9366A=".txt";
char*s102_1898638542A="Expression expected (\"inspect ... \").";
char*s102_1460213717A="End of manifest array expected.";
char*s103_92397395A="Closing \"\175""\" expected.";
char*s635_1278500877A="((T0*)se_string(";
char*s628_7224500A="INT16_C(";
char*s635_15533A="ceil";
char*s102_1452100558A="No more DOUBLE type mark (update your code). This DOUBLE type mark is automatically replaced with REAL which is actually equivalent to REAL_64. Also consider to use REAL_32 or REAL_80 when you prefer. Also consider command pretty to replace automatically all DOUBLE with REAL.";
char*s102_850458948A="Expression expected after the \"if\" keyword.";
char*s33_421505A="method";
char*s370_336696676A="\") this expression is the ";
char*s749_2068836731A="Overlapping slices. (Wrong inspect statement.)";
char*s102_1389575653A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure using the previous CHARACTER constant as the target).";
char*s483_1088102843A="..........................";
char*s630_4179775A=")->id)\173""\n";
char*s118_2035830473A="\nFEATURE_STAMPs with rename  = ";
char*s102_638895319A="Missing \')\' to end `c_inline_h\' call.";
char*s628_40427625A="UINT16_C(";
char*s336_770157670A="Loop_variant";
char*s828_80501401A="Internal problem while searching for \"mark_item\".";
char*s417_835850355A=".....         local unique buffer          .....";
char*s109_498062040A="#(1)\nOriginal SmartEiffel code:\nCopyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE\nCopyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE\nD.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER, F.MERIZEN\n    http://smarteiffel.loria.fr\n";
char*s542_651043570A="specializing one type";
char*s613_1610470399A="\" is deferred in type ";
char*s832_834589410A="*)o)->header.flag==FSOH_UNMARKED)\173""\n";
char*s613_46337A="=(u->";
char*s277_1811847991A="Non empty unquoted name expected here.";
char*s115_660780608A="void se_prinT9(FILE* file, T9*o)";
char*s33_7704337A="PLATFORM";
char*s115_15589A="argc";
char*s635_1206509635A="o1,o2);\175""\n\175""\n";
char*s111_3291A="int";
char*s111_1346168095A="Unable to find the compiler type of \"";
char*s115_46350A="=1;\173""\n";
char*s33_33120277A="CHARACTER";
char*s716_38305571A="unsigned int rsoc_count_ceil";
char*s111_3294A="lcc";
char*s109_1255397791A="Will generate live type: ";
char*s115_616198177A="switch(((se_agent0*)a)->creation_mold_id)\173""\n";
char*s832_40205A="(o);\n";
char*s109_1928938448A=" formal generic arguments while the maximum allowed is ";
char*s343_70962A="Type ";
char*s115_960414291A="Agent call wrapper";
char*s34_1072344038A="SmartEiffel";
char*s102_1725672511A="Type mark expected after a colon mark inside a local variable list.";
char*s115_2115332211A="\175""\nreturn 0;\n";
char*s123_287218105A=".... unique buffer ....";
char*s102_2008366323A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous CHARACTER constant as the target).";
char*s109_1896793334A="\". This is not possible as this class is basically used by Liberty Eiffel internals. Please pick another name.";
char*s635_83277A="isinf";
char*s832_1316551052A="Unexpected closure on weak_ref\?!";
char*s280_1897894366A="Expanded classes can be inserted only.";
char*s477_1810101146A="Bad external \"C++\" definition.\nexternal \"";
char*s111_3320A="man";
char*s408_276773717A=" which is out of range -15..15 because target type is INTEGER_16.";
char*s471_1050501857A="` in class ";
char*s635_104084395A="((int8_t)(";
char*s572_13424808A="\011""create \173""";
char*s628_15629A="ddt1";
char*s346_83290A="item_";
char*s477_34086A="*)a1)";
char*s636_105695965A=")+a3tmp,((";
char*s647_58505493A="The Precursor routine is a deferred routine.";
char*s102_147793411A="Void is not a valid BOOLEAN expression (just after keyword \"if\").";
char*s34_1223234252A="debug_check";
char*s458_221949868A=" Actually, feature ";
char*s376_3337A="no ";
char*s102_1297544492A="\" is not valid keyword.\"";
char*s115_1125599439A="return((T0*)s);\n";
char*s716_259021955A="s=new7();\n";
char*s578_1500847347A="R = R \174""\174"" ((o1->_";
char*s111_150382995A="\"[General] bin\" key is missing.";
char*s285_360205908A="Too many live types (the maximum is ";
char*s379_1731781A="Value `";
char*s102_760340765A="Syntax error while trying to parse the header of routine `";
char*s753_1398420907A=" Missing character number ";
char*s636_129654140A=";\nmemcpy((";
char*s750_89481A="state";
char*s115_511465169A="Compiling routines for ";
char*s370_240593583A="\" (i.e. when the type of Current is \"";
char*s370_611824887A="In the context \"";
char*s716_3374A="new";
char*s483_192265186A="Cannot pass ";
char*s635_83345A="isnan";
char*s30_1102047298A="\" is not allowed when an ACE file (";
char*s102_1109293176A="Void cannot be used after unary \"+\" operator.";
char*s109_292482A="Class ";
char*s33_698215697A="Maximum_real";
char*s109_763853019A="\".\nToo long TUPLE (the TUPLE you want has ";
char*s630_23451005A="/*i*/=0;\n";
char*s115_3393A="lsv";
char*s102_883016350A="Missing \",\" added.";
char*s413_739187517A="Creation call on formal generic type (";
char*s33_89510A="stdin";
char*s33_1297876698A="is_not_null";
char*s115_42279221A="Procedure";
char*s102_1390190909A="An expanded class cannot inherit from other classes, it can only have an \"insert\" clause (replaced).";
char*s630_2024156039A="/*[manifest INSPECT*/\n";
char*s636_1062582514A=")-a3tmp+1)*sizeof(T";
char*s277_1977886A="collect";
char*s34_3415A="old";
char*s666_22122412A=" because ";
char*s113_15721A="dice";
char*s33_3421A="not";
char*s115_5164112A=", agent_profile, ";
char*s635_1338608648A="R=se_deep_twin_search((void*)C);\nif(NULL==R)\173""\n";
char*s829_1808489692A="(void*obj,void*_)";
char*s115_3430A="\175"";\n";
char*s102_2053250287A="\')\' expected to end arguments list.";
char*s630_169510A="++;\n\175""\n";
char*s115_1855175789A="se_profile_t atexit_profile";
char*s111_759424351A=" is not supported as a C++ compiler. I will continue, but expect some problems.\n";
char*s102_2060176323A="Expression expected.";
char*s478_83406A="macro";
char*s33_15751A="code";
char*s106_1449185201A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
char*s109_3451A="\175"".`";
char*s115_2123070311A=", agent_switch_profile, ";
char*s832_1242450095A="if (size<=(";
char*s102_239621812A="Bad create expression (\'\175""\' expected).";
char*s115_3457A="orp";
char*s283_1534075159A=" does not have ";
char*s405_362752532A="Invalid comparison of expression ";
char*s350_1742784741A="Feature found is not a procedure.";
char*s370_1485100899A="..... unique buffer 2 .....";
char*s102_95110222A="Added missing \")\"";
char*s33_3460A="\174""<<";
char*s716_1203674198A="#ifndef FIXED_STACK_BOTTOM\nif(!valid_stack_bottom) stack_bottom = (void**)(void*)&valid_stack_bottom;\n#endif\n";
char*s111_1067454155A="Reading loadpath files\n";
char*s832_46525A=">1)\173""\n";
char*s33_3472A="\174"">>";
char*s111_270309168A="Currently handled compiler names:\n";
char*s33_3474A="pow";
char*s115_3475A="se_";
char*s115_2038260346A="else fprintf(SE_ERR, \"Cannot open profile.se for writing.\\n\");\n\175""\n";
char*s999_10220290A="function";
char*s628_3485A="vc(";
char*s111_592781506A="Local Cluster";
char*s635_1821634438A="(((se_agent*)C)->u0.eq==((se_agent*)a1)->u0.eq)&&(((se_agent*)C)->u0.eq((se_agent*)C,(se_agent*)a1))";
char*s625_22854451A="/*:RF2*/)";
char*s115_120095614A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_inv_profile+i);\n\175""\n";
char*s33_1418282620A="INTEGER_GENERAL";
char*s613_20240284A="),&(a2->c";
char*s113_3494A="tcc";
char*s115_325655889A="#define SE_SEDB 1\n";
char*s478_3496A="set";
char*s376_1317154036A="live id-field: ";
char*s409_176211197A=" which is of type ";
char*s370_1984383762A="For inspect statement, the expression type can be only INTEGER, CHARACTER, STRING, or FIXED_STRING. (Actually ";
char*s33_3501A="put";
char*s115_1572014572A=";\nwhile (i < imax) \173""\n";
char*s102_46597328A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous `True\' constant as target).";
char*s102_1631593164A="Void cannot be the left-hand side of the binary \"*\" operator.";
char*s832_1973244310A="))+sizeof(rsoh);\nsize=((size+(sizeof(double)-1))&\176""(sizeof(double)-1));\n";
char*s832_1173325215A="void gc_update_weak_ref_item";
char*s120_253892190A="exceptions";
char*s833_27492334A="*sizeof(T";
char*s485_1387816739A="Cannot rename feature `c_inline_h\' because this name is used as a keyword to handle the corresponding \"built_in\" feature of ANY.";
char*s833_136857117A=",(unsigned long)(";
char*s612_1199805276A="fprintf(file,\"\\n\\t[ \");\n";
char*s409_256961544A="The left-hand side of an assignment attempt must not be expanded. (Actually, the left-hand side is of type ";
char*s118_1129671576A="Assigned feature is not a query in type";
char*s90_3520A="ti_";
char*s111_15828A="cpml";
char*s832_1058430701A="o1->header.next=gc_free";
char*s115_1728206941A="((/*UT*/(void)(";
char*s33_15831A="copy";
char*s458_1606367935A="Using a static constant expression just after the \"is\" keyword is suitable only for a constant attribute definition. The constant found (i.e. ";
char*s33_1947246A="bit_set";
char*s29_1767481079A="precompile_header";
char*s109_1225577982A="Reference Target Monomorphic Procedure Call";
char*s102_1522646678A="Missing \'(\' after `c_inline_c\'.";
char*s33_1947251A="bit_put";
char*s716_1713875121A="GC support: generating header.\n";
char*s34_77350A="alias";
char*s102_1931146896A="Bad procedure definition.";
char*s432_1379248421A="Formal generic name appears twice in formal generic list (VCFG.2).";
char*s102_201048978A=" cannot be used just after agent keyword. The type of the target must be given. Consider using the curly braces notation, e.g. `\173""TARGET_TYPE\175""\'.";
char*s791_789213750A=" (kept)\nRedundant definition ";
char*s833_692716864A=".space_used);\n";
char*s628_4622950A="/*NAI*/(";
char*s638_646768902A=";\n\173""\nstatic ";
char*s102_1167481808A=" digits). You must use exactely 2, 4, 8 or 16 digits only. A 2 digits value denote an INTEGER_8, a 4 digits value denote an INTEGER_16, a 8 digits value denote an INTEGER_32, and, finally, a 16 digits value denote an INTEGER_64. (See examples in file \"SmartEiffel/tutorial/hexadecimal.e\".)";
char*s694_1499315956A="No split enabled.\n";
char*s90_1462938943A="NATIVE_ARRAY[NATIVE_ARRAY[...]] is not currently supported by the introspection system.";
char*s566_3557A="tmp";
char*s115_1965730A="break;\n";
char*s103_176469602A="In extended form of manifest string. Bad character before \'%\'.";
char*s277_2100317873A="Unquoted filenames are deprecated. Please add quotes here.";
char*s102_3567A="top";
char*s613_9720A="=CA_";
char*s828_936093505A="native_array_collector_tag";
char*s751_858562A=" _NULL ";
char*s628_23186700A="/*NVND*/(";
char*s714_28273584A=",sizeof(T";
char*s115_357794960A="T0* se_manifest";
char*s102_161325869A="Empty manifest array is not a valid notation. If you want to create an empty ARRAY, just use an ordinary creation call of class ARRAY.";
char*s635_304601115A="signal_exception_number";
char*s716_9980517A="gc_sweep";
char*s34_3595A="sys";
char*s832_1645106999A=",\n(void(*)(mch*))";
char*s477_852437A="*)a1)->";
char*s115_77412A="case ";
char*s34_3601A="use";
char*s96_1229059519A="Bad root procedure name (\"";
char*s115_726227573A="*sizeof(se_profile_t));\nqsort(sorted_profile, ";
char*s115_434116584A="*sizeof(se_profile_t));\nqsort(sorted_agent_profile, ";
char*s716_15915A="if((";
char*s102_1061217192A="Classes with an external type must be expanded or deferred.";
char*s714_1193180751A="s=((T7*)se_malloc(sizeof(T7)));\n";
char*s94_1554312113A=".... local buffer ....";
char*s832_239388241A="n->object=";
char*s613_9775A="=CL_";
char*s33_279523519A="to_pointer";
char*s277_551231644A="Multiple ACE files in the command line: \"";
char*s96_620670284A="\nparent-count: ";
char*s542_965507650A="inlining dynamic dispatch";
char*s115_1065652086A="\173""\nFILE *profile_file = fopen(\"profile.se\", \"w\");\nif (profile_file!=NULL) \173""\nint i;\nse_profile_t sorted_profile[";
char*s716_1549077634A="handle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s630_206626A=";\nelse";
char*s277_3645A="yes";
char*s637_54686040A="return ((";
char*s30_1009954795A="\". Must not use Eiffel source file suffix with option \"-o <executable_name>\".";
char*s715_1527912055A="GC_disable();\n";
char*s115_1723513855A="stop_profile(parent_profile, &local_profile);\n";
char*s34_89771A="trace";
char*s716_961294240A="if(!gc_is_off && !garbage_delayed())\173""\n";
char*s109_2106290588A="Exponent of infix \"^\" must be a positive INTEGER. Exponent actual value is \"";
char*s102_1522646803A="Missing \'(\' after `c_inline_h\'.";
char*s33_577213499A="is_not_a_number";
char*s613_1115628985A="handle(SE_HANDLE_EXCEPTION_SET,NULL);if(SETJMP(rc.jb)!=0)\173""/*rescue*/\n";
char*s102_375534514A="Bad creation instruction (type or \'!\' expected).";
char*s33_3669A="xor";
char*s646_1750246116A="Declared INTERNAL_C_LOCAL: ";
char*s612_1199620901A="fprintf(file,\"\\n\\t  \");\n";
char*s33_911175911A="internals_from_generating_type";
char*s630_1631421108A="/*storage*/=((";
char*s999_28287A="\" at ";
char*s635_755813960A="]), se_argv[";
char*s277_261396584A="The value of the environment variable \"SmartEiffel\" is:\n\"";
char*s33_169371474A="DISPOSABLE";
char*s285_1539722017A=" correct items).\n";
char*s34_16001A="else";
char*s115_395316170A=" */\nif (expression == NULL) return 1;\n";
char*s33_1947419A="bit_xor";
char*s115_1565125654A="];\nse_profile_t sorted_inv_profile[";
char*s455_1087076085A="Double definition of feature ";
char*s413_581709925A=" is not in the creation list of type ";
char*s716_89821A="store";
char*s115_1773201687A="\n#ifdef __cplusplus\n\175""\n#endif\n";
char*s96_1914699291A="Wrong number of generic argument";
char*s118_429361964A="Can\'t join these two concrete features. What\'s called a concrete feature here is a feature which is not deferred. You may consider to undefine one feature. May be.";
char*s102_1453066751A="Must use exactly 16 hexadecimal digits for INTEGER_64.";
char*s115_56845112A="volatile ";
char*s428_1288915017A="... unique buffer ...";
char*s408_1469170081A="Overflow of infix \"*\" with INTEGER_64 operands. (";
char*s808_1635136368A="\" (resolved as \"";
char*s34_937397683A="The $ operator must be followed by the final name of a feature which is not a constant attribute or by the name of some local variable as well.";
char*s343_1524252299A=". Signature of the redefined feature is not valid.";
char*s336_560316788A="No_more_memory";
char*s33_2218105A="rounded";
char*s111_89862A="strip";
char*s285_411001267A=" in any cluster. Don\'t expect the compilation to succeed.\n";
char*s409_1933023161A=".) Invalid assignment test.";
char*s407_1140411454A="The declaration type of this expression is ";
char*s33_203589551A="manifest_initialize";
char*s635_9905A="C->_";
char*s635_34510A="))\174""\174""(";
char*s630_3760A="\175""\175""\n";
char*s96_510352234A="A class cannot be expanded and deferred (VTEC.1).";
char*s402_1128496981A=" can be assigned into ";
char*s102_407741255A="_inline_agent";
char*s115_22971612A="];\nmemcpy(sorted_profile, profile, ";
char*s750_560556710A="\") in the same inspect.";
char*s408_944882A=" times ";
char*s635_437573617A="((T6)((C->id==a1->id)\?!memcmp(C,a1,sizeof(*C)):0))";
char*s115_1316373138A="/*se_evobt*/";
char*s613_403595A="u->CA_";
char*s635_2030510390A=",C->_capacity);\n";
char*s109_956422775A="Simplify done";
char*s418_1931700734A="Here is the corresponding feature definition (not an attribute).";
char*s569_638047023A="Call on a Void target in the live code (when the type of Current is ";
char*s277_1737556726A=". The first one is in the cluster \"";
char*s33_275488632A="Maximum_double";
char*s277_2044479327A="\nEiffel class file searching is being done according to the ACE file \"";
char*s35_77608A="cecil";
char*s635_9980719A="if(R)R=r";
char*s124_113009969A=" in file \"";
char*s115_122027336A="init_profile(&prof, \"se_msi";
char*s832_40705A=")n);\n";
char*s34_2593373A="cpp_linker_options";
char*s467_907165587A=" appears at least twice. The client lists will be merged, but please fix the export clauses.";
char*s639_2187411A="se_atT[";
char*s999_1760616840A="Could not load the plugin; one dependancy is not satisfied: location <";
char*s277_1799491166A="\" in any known cluster.";
char*s440_892969089A="   default assertion (";
char*s109_1194472660A="Reference Target Monomorphic Function Call";
char*s102_1943393816A="Argument name ";
char*s477_9808515A="delete((";
char*s791_65332A="] in ";
char*s613_2187432A="return ";
char*s715_357653724A=")GC_call_with_alloc_lock((GC_fn_type)bdw_weakref_getlink,(bdw_Twr*)(";
char*s613_403650A="u->CL_";
char*s751_16139A="il2@";
char*s103_372047073A="Deleted extra separator.";
char*s666_1864907075A="To many actual arguments for agent call. (The agent you are trying to call has no arguments.)";
char*s33_440571A="target";
char*s102_2082787810A="Error while reading a real. Missing \"\175""\" \?";
char*s109_388205767A="Total Number of \"inspect\" used for Dynamic dispatch: ";
char*s33_1604522960A="to_integer_8";
char*s829_888029880A="c=o->_capacity;\n";
char*s287_2064444A="infix \"";
char*s33_2187464A="se_argc";
char*s115_697705640A="sorted_all_profile[";
char*s285_188525860A="Corrupted *.id file (after ";
char*s34_49076540A="assertion";
char*s275_1587749191A="Aliased STRINGs: ";
char*s111_143937264A="-subsystem";
char*s109_1131498768A=" does not belong to any known cluster.";
char*s277_452889A="system";
char*s115_1450791030A="[hc]\" not found).";
char*s834_1411018665A=".store_left=0;\n\175""\n";
char*s429_2134616155A=" is expanded).";
char*s405_333554149A="Such a weird comparison with Void is not allowed because it would be always ";
char*s115_397592212A="\",1\175"";\nse_dump_stack ds;\n";
char*s35_16177A="help";
char*s405_461679483A="Cannot compare an expanded expression with a reference expression.";
char*s33_2187483A="se_argv";
char*s636_1502256459A="]),&a1tmp,sizeof(T";
char*s611_11241768A="struct S";
char*s34_59251A="False";
char*s287_1224218969A="The source lines involved by the message are the following:\n\n";
char*s287_1750778A="Warning";
char*s110_2107398012A="\nLiberty Eiffel The GNU Eiffel Compiler, Eiffel tools and libraries\n    release #(1)\n\nCopyright (C), #(2) - #(3)\n    http://www.liberty-eiffel.org\n";
char*s105_745978733A="\' is defined more than once";
char*s832_384078512A="\173""rsoh*h=((rsoh*)o)-1;\nif((h->header.magic_flag)==RSOH_UNMARKED)\173""\nh->header.magic_flag=RSOH_MARKED;\n\173""\n";
char*s109_2045223723A="Cannot collect feature \173""";
char*s666_191115496A=". Its type is ";
char*s115_522691310A="ds.caller=NULL;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s108_1442714837A="Assignment graph: ";
char*s111_1056930268A="You can also have a look at http://liberty-eiffel.blogspot.com/wiki/index.php/";
char*s636_2187545A="se_die(";
char*s102_1687580001A="Void is not a valid expression inside \"when\" part of an inspect statement.";
char*s102_1301660112A="Bad formal arguments list.";
char*s115_1266427187A="if (!prof_init)\173""memset(&prof,0,sizeof(prof));prof_init=1;\175""\n";
char*s492_455005721A="Same type appears more than once.";
char*s115_1136118256A="............ unique buffer ...........";
char*s473_779913846A="Error in until part of loop definition.";
char*s374_389128515A=" Cannot assign Void into ";
char*s647_7440512A="Feature ";
char*s635_77767A="ceilf";
char*s115_2060090728A="fprintf(file, \"NATIVE_ARRAY[CHARACTER]#%p\\n\",(void*)*o);";
char*s277_641030424A="Non empty quoted string expected here.";
char*s635_77773A="ceill";
char*s832_1869083728A="void gc_update_weak_ref_item_polymorph(Tgc* item)";
char*s34_16264A="from";
char*s34_9790205A="deferred";
char*s577_1476287022A="typedef T0 T";
char*s829_646707803A=")se_malloc((*n)*sizeof(T";
char*s102_99041221A="\' instead.";
char*s628_7225250A="INT32_C(";
char*s628_2187584A="se_cmp1";
char*s628_2187585A="se_cmp2";
char*s34_265093627A="loop_check";
char*s115_1234811086A="memcpy(sorted_all_profile, profile, ";
char*s407_435568604A="\"if\" (or \"elseif\" as well) must be followed by a BOOLEAN expression.";
char*s32_635943583A="Feature `is_deep_equal\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s103_175744216A="Added \"(\".";
char*s115_700572143A="init_profile(inv_profile+";
char*s33_1223936132A="deep_memcmp";
char*s628_40428375A="UINT32_C(";
char*s336_1207039342A="Void_attached_to_expanded";
char*s408_511502716A="Cannot divide ";
char*s33_37186806A="NATURAL_8";
char*s808_1847764413A="Cycle detected:\n";
char*s613_2187619A="se_cmpT";
char*s630_809795A="((T0*)(";
char*s376_4488096A=" feature";
char*s613_208313786A="ds.caller=caller;\n";
char*s103_175744241A="Added \")\".";
char*s33_77832A="blank";
char*s277_1667312535A="Cluster path expected after cluster name.";
char*s277_90141A="wedit";
char*s396_1814961148A="Unused local variable.";
char*s458_161769183A=") cannot be used as the definition of the feature ";
char*s372_432936020A="Cannot find Base Class for ";
char*s115_889346373A="global_profile=local_profile;\n";
char*s115_4980205A=",NULL);\n";
char*s102_872019014A=" or the whole expression as well. It\'s up to you to decide now.";
char*s118_7612837A="In type ";
char*s336_41769343A="Os_signal";
char*s277_1984169029A="Cannot find the class \"";
char*s102_1476889913A="Empty list not allowed for manifest generic creation.";
char*s716_2039472678A="stack_bottom=((void**)(void*)(&argc));\n";
char*s572_26108906A="Unknown feature name ";
char*s33_65574A="TUPLE";
char*s33_197002151A="force_to_natural_64";
char*s630_440120430A=")->_storage_lower;\n";
char*s716_533301931A="void(*gc_mark_agent_mold)(se_agent*);\n";
char*s636_388821092A="Class NATIVE_ARRAY has been tampered with. Unknown procedure: ";
char*s102_1160088831A="\" cannot be a valid class name (only upper case letters are allowed in class names). \"";
char*s102_902126A=" first.";
char*s630_2089246593A="if(requireresult)\173""\n";
char*s635_234855416A="_t)(((uint";
char*s33_550709268A="NATIVE_ARRAY_COLLECTOR";
char*s115_253935823A="];\nse_profile_t sorted_agent_profile[";
char*s96_1468715266A=". This creation call is thus not allowed.";
char*s33_197002168A="force_to_natural_32";
char*s102_732932648A="Load class \"";
char*s613_657822788A="ds.fd=&se_ifd";
char*s630_2353775A="\175""else\173""\n";
char*s103_1836169859A="Unexpected character in hexadecimal unicode.";
char*s34_434665A="option";
char*s103_175744316A="Added \",\".";
char*s115_2060613700A="T0*se_string(";
char*s418_626532654A="This feature name is not an expression (no result and not writable).";
char*s33_197002174A="force_to_natural_16";
char*s477_397949195A="\"\n_________";
char*s404_1543474532A="Actually, `Void\' has no accurate type. Keep in mind that `Void\' is just a way to denote the default value for a type or to denote the lack of an object. One can use `Void\' as the left-hand-side of an assignment or to replace some actual argument. (See \"http://liberty-eiffel.blogspot.com/wiki/en/index.php/Void\" for details.) At time being, the type ANY will be used for this occurrence `Void\'. Please update your code with a more accurate expression, may be by adding an extra non-initialized local variable.";
char*s401_647790517A="This variable is used in a closure. Beware, each time the method is called, a lot of memory may be wasted.";
char*s115_2114508771A="int c,char*e)";
char*s277_1805205737A="Files are being searched for in the following list of clusters (";
char*s33_573080478A="raise_exception";
char*s405_2089449608A="An expanded value can be compared only with the same other expanded value. Expression ";
char*s753_1139569132A="Invalid byte in UTF-8 sequence. This character is  number ";
char*s111_1832417772A="Bad use of command `";
char*s636_84085A="\174""(1<<";
char*s102_1732402521A="Instruction expected.";
char*s830_742356016A="typedef struct B";
char*s630_47187A="==0) ";
char*s608_1152812249A="/* Extra external prototype for line ";
char*s118_1248054333A="Add undefine or redefine to all inherited version of feature ";
char*s33_53339A="ARRAY";
char*s30_1335263213A=": missing file name after -cecil flag.\n";
char*s716_1085305030A="gc_align_mark";
char*s285_838840612A="Previous IDs reloaded (max_id = ";
char*s108_1616517694A="destination-graph-nodes: ";
char*s577_1476281050A="typedef uint";
char*s578_742356033A="typedef struct S";
char*s829_1456062714A=",NULL,NULL,NULL);\no->bdw_markna=(void*)HIDE_POINTER(markna);\n*markna=(T0*)o;\nGC_GENERAL_REGISTER_DISAPPEARING_LINK(&(o->bdw_markna),markna);\nbdw_in_assign=0;\nGC_enable();\nif(bdw_delayed_finalize)\173""\nbdw_delayed_finalize=0;\nreturn NULL;\175""\175""\nreturn o;\n";
char*s33_49076823A="clear_all";
char*s115_1858528797A="\n(fprintf(SE_ERR,\"%s\\n\",";
char*s613_1949908058A="*u=(void*)new_agent(";
char*s115_10940631A="se_evobt";
char*s714_870210728A="fprintf(SE_ERR,\"No GC compiled in, no information available\\n\");\n";
char*s109_218672210A=".............. once unique buffer ......................";
char*s440_397660162A="   exclude ";
char*s30_375350487A=": the \"-case_insensitive\" flag is no longer supported.\n";
char*s111_1361085152A="@linkit.com\ndelete linkit.com;";
char*s716_1403828457A="store_chunk";
char*s481_1610077639A=" open operand expression is out of \"agent\" keyword scope.";
char*s115_16487A="int ";
char*s102_398318341A="\' does not fit on INTEGER_64).";
char*s346_731327330A="Agent calls need a tuple!";
char*s103_595894613A="Unexpected character in decimal ascii code.";
char*s102_1174611449A="Separator expected to end hexadecimal constant.";
char*s750_2027238465A="Only manifest strings are accepted in \"when\" clauses of \"inspect\" (in order to ensure that the STRING won\'t change at runtime). Note that even a constant of type STRING can have its content changed at runtime.";
char*s829_718028873A="int i,c,g;T0*e;T0**na;T";
char*s34_78002A="check";
char*s370_165601417A="CHARACTER ";
char*s753_1927020241A="Invalid unicode value: 0x";
char*s343_1246984134A=") this type mark is resolved as ";
char*s715_1062817045A="GC support (root functions).\n";
char*s115_1617526527A="se_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\nds.depth=0;\n";
char*s630_16510A="\175""\n\175""\n";
char*s33_1202672333A="with_capacity";
char*s102_897447412A="Cannot use ";
char*s111_19761224A=" Data=Far";
char*s115_1201497496A="*C;\nva_list pa;\nint i=0;\nint imax;\nva_start(pa,argc);\nC=";
char*s808_1959331451A="Empty loadpath: \"";
char*s832_1990989A="if(((gc";
char*s102_521861207A="The convert support is EXPERIMENTAL (work in progress).";
char*s115_5367889A="*eiffel_root_object";
char*s102_586311386A="Bad creation instruction (\'!\' expected).";
char*s613_422487A="locexp";
char*s115_47278A="==0)\173""";
char*s102_1093012317A="Second identifier of a \"rename\" pair expected.";
char*s638_41131A=";\n_r=";
char*s102_1437345301A="Syntax error while trying to parse the beginning of a new feature definition. Feature name expected. Class name ";
char*s999_2072196164A="The default key \"function\" was not found. Invalid auto_init file.";
char*s33_1744612358A="is_basic_expanded_type";
char*s102_1759774576A="You are probably trying to use the new inherit/insert mechanism. With Liberty Eiffel, this can be achieved thanks to the new \"insert\" clause. The new \"insert\" clause comes just after the traditional \"inherit\" clause with a similar syntax.";
char*s449_1118729658A="When the context of the validation is ";
char*s115_2096892436A="p[0]=\"\?\?\?\";\n";
char*s638_1659544035A=");\nR=&_r;\n\175""\n";
char*s102_4235A=" \011""\000""\n";
char*s109_1610926534A="Void target Procedure Call";
char*s102_1154110220A="Cannot use anchored type mark definition as a valid parent.";
char*s276_956361723A="Remainder: \"";
char*s115_1110850242A="fprintf(profile_file, \"\\n===============================================================================\\n\");\n";
char*s115_1377391529A="Executable is up-to-date (no C compilation, no linking done).\n";
char*s635_884813300A=";\nT0*o2=a1ptr->_";
char*s635_4881995A="->id)==(";
char*s115_1197714671A="(T0* expression)";
char*s630_840791A="((void)";
char*s103_543076045A="Type mark expected.";
char*s716_280766651A="store_left";
char*s105_42698349A="The key \'";
char*s697_928596125A="\" not changed.\n";
char*s115_246893097A="v=ac_lvc(c++,v,";
char*s115_1911279888A=")));\nC[i]=element;\ni++;\n\175""\nva_end(pa);\nreturn C;\n";
char*s402_332834879A="forced assignment (\"::=\").";
char*s376_78082A="dead ";
char*s111_1223801083A="Selecting C++ compiler: ";
char*s409_1907958363A=". (This assignment test is always True.)";
char*s483_94643563A=" is deferred. (Cannot create object.)";
char*s635_17743770A=")\n#endif\n";
char*s115_1964848975A="start_sumup_profile(profile_file);\ni=";
char*s715_871385705A="GC_dump();\n";
char*s102_688657949A="Empty \"when\" clause in \"inspect\" statement.";
char*s34_90408A="until";
char*s832_1314337673A=".store_left))\173""\nrsoh*r=";
char*s103_1242149539A="Right hand side expression of := assignment expected here.";
char*s33_7748406A="REAL_128";
char*s526_840796792A="Empty manifest array not allowed. (If you really need to do it, just replace it with something like:\ncreate \173""ARRAY[ANY]\175"".make(1, 0)";
char*s628_3934795A="(((T0*)(";
char*s336_198146473A="Class_invariant";
char*s102_126038302A="Writable entity expected here (`Current\' is not writable).";
char*s33_16616A="last";
char*s111_2121681051A="Unknown C++ compiler type \"";
char*s628_36122993A="INT16_MIN";
char*s829_182705A="0*));\n";
char*s408_1718483009A="Overflow for opposite of Minimum_integer_8.";
char*s34_16630A="jobs";
char*s102_494839979A="Empty argument list (deleted).";
char*s105_1784452489A="Could not execute \'";
char*s34_10208843A="external";
char*s34_56255230A="undefined";
char*s111_725963810A="\". Please fix your configuration file or choose another C mode.";
char*s33_16639A="item";
char*s33_78150A="atan2";
char*s102_2016523575A="In compound (";
char*s449_1888871872A="TUPLE type expected for open arguments of agent type. (See also the next fatal error message.)";
char*s34_1730514379A="cpp_compiler_options";
char*s500_1879799154A="Must not use old inside some old expression (VAOL.2).";
char*s630_1553642381A="default: error1(\"Invalid ::= assignment (inserted type).\",";
char*s675_1166590709A="Deferred feature must not have rescue compound.";
char*s832_1396798042A=".store_left-=size;\nif(";
char*s33_705019679A="die_with_code";
char*s33_1339128A="BOOLEAN";
char*s33_451899881A="type_attribute_name";
char*s113_59731A="Elate";
char*s540_2014364610A="run-time-set:\n";
char*s111_39204698A="SCOPTIONS";
char*s111_61342149A="No information available about the system used (check your\nLiberty Eiffel installation).\n";
char*s102_768172015A="Hexadecimal digit expected while reading CHARACTER constant.";
char*s476_1979303915A="\":\" expected";
char*s635_17743865A=")\n#else\n(";
char*s346_416499A="item_1";
char*s103_1226144723A="Variable `Result\' is valid only inside a function.";
char*s346_416500A="item_2";
char*s370_61858840A=" which is not allowed.)";
char*s33_16686A="make";
char*s832_1279738389A="++;\n\175""\nelse\173""\nc=gc_fsoc_get1();\nif(";
char*s364_881547256A="Cannot use here a manifest STRING because the previous one used in this \"inspect\" statement is not a manifest STRING.";
char*s35_385751A="c_mode";
char*s833_666336072A=")\nfprintf(SE_GCINFO,\"%d\\t%lu\\t%d\\t";
char*s833_41300A=";\nif(";
char*s696_355003A="][0-9]";
char*s751_78209A="ddt1@";
char*s829_1037766A="(int n)";
char*s115_561301605A="*/: error2(expression,/*unknown-position*/0);break;\n";
char*s115_988839165A="se_frame_descriptor root=\173""\"<system root>\",1,0,\"";
char*s379_31214580A="\' is out of INTEGER_16 range.";
char*s635_106047655A="),a1ptr->_";
char*s277_2085574777A="external_lib";
char*s111_84381A="mieee";
char*s277_416541A="legacy";
char*s630_4425A="\nif(";
char*s612_1511378937A="fprintf(file,\"#%p\",(void*)*o);\n";
char*s33_90544A="upper";
char*s115_280139425A="uint16_t s";
char*s402_29037A=" ::= ";
char*s715_255799920A="GC_invoke_finalizers();\nhandle(SE_HANDLE_EXIT_GC,NULL);\n";
char*s753_888288799A="Overlong sequence, must be refused by any UTF-8 complient decoder for security reasons.";
char*s34_427898753A="# Beginning of parallelizable section";
char*s630_847125A=");\nif (";
char*s635_111269879A="R=se_deep_equal_search(C,a1);\n";
char*s374_1881300092A="Assignment of a reference type into an expanded type is not allowed. ";
char*s343_2084824380A=" (More explaination below.)";
char*s276_988261007A="Bad external signature (missing opening \"(\" delimiter.";
char*s115_1240218271A="se_argc=argc;\nse_argv=argv;\n";
char*s103_175744666A="Added \":\".";
char*s698_1085938891A="By-type splitter enabled.\n";
char*s543_32450971A="C:\\SE.CFG";
char*s543_311952415A="liberty-eiffel";
char*s628_920950A="/*IC*/(";
char*s34_78263A="debug";
char*s630_958274895A="!=NULL)\173""error1(\"Invalid ::= assignment (inserted type).\",";
char*s636_804085A="&(\176""(1<<";
char*s115_561947515A=" element=((";
char*s34_16761A="like";
char*s749_786403659A="Internal error inside WHEN_ITEM_2 (compiler error).";
char*s102_1559455194A="Expression \"old\" can be used in ensure clause only (VAOL.1).";
char*s115_21391495A=",((void)(";
char*s103_175744691A="Added \";\".";
char*s102_1421961899A="The basic = operator cannot be redefined. (This is a hard-coded builtin that we must trust.)";
char*s357_1479430694A="This call has no result.";
char*s440_597973944A="Could not load class in cluster ";
char*s115_16782A="link";
char*s34_84443A="local";
char*s690_161074567A="<Universe>";
char*s413_182862A=" into ";
char*s109_1914558593A="The root class must not be expanded (sorry, but this is a limitation of the compiler).";
char*s109_1450022771A="Unknown feature `";
char*s613_430519127A="ds.locals=locals;\n";
char*s102_611217054A="Error in constant or manifest creation.";
char*s402_138555764A=" by using an ordinary \":=\" assignment ";
char*s111_1615398571A="..................................";
char*s776_1400894751A="... once unique buffer ..................................";
char*s106_1880881887A="................";
char*s753_263008962A=" bytes sequence.";
char*s33_839855894A="TEXT_FILE_WRITE";
char*s102_1075925125A="Must not use local variable in ensure assertions (VEEN).";
char*s102_488830629A="Void cannot be the left-hand side of infix operator \"";
char*s343_2050169721A="In the parent context (i.e in ";
char*s635_1174230416A="_t)((((uint";
char*s109_1661328107A=". Yours is in the cluster \"";
char*s33_2126626A="or else";
char*s115_179423058A="if(ds.fd->assertion_flag)\173""\nds.fd->assertion_flag=0;\n";
char*s109_42846255A="No such TUPLE definition in file \"";
char*s402_1816745449A="::= assignment (a forced assignment).";
char*s476_56907446A="type_name";
char*s716_614557109A="/*NON_VOID_NO_DISPATCH:*/\n";
char*s476_10559665A="location";
char*s578_1208522276A="typedef int T";
char*s716_1215177661A="\173""int i=SE_MAXID-1;\nwhile(i>=0)\173""\nif(g[i]!=NULL)gc_mark7(g[i]);\ni--;\175""\n\175""\n";
char*s118_576322499A=" cannot be an assigner of the feature ";
char*s408_1592935176A=" which is out of range 0..7 because target type is INTEGER_8.";
char*s33_324411A="STRING";
char*s33_1739790308A="type_generator";
char*s96_15142174A="Bad root class (this class has no creation clause).";
char*s635_195246A="->id))";
char*s578_1502207936A="R = R \174""\174"" se_cmpT";
char*s700_1345295929A="Multiple rename for the same feature is not allowed.";
char*s111_149455415A="Unknown compiler type \"";
char*s635_1605175681A="se_deep_twin_start();\n";
char*s109_22271191A=" argument";
char*s458_375578482A="Value out of INTEGER_8 range.";
char*s613_948421114A=";\nds.current=((void*)&C);\n";
char*s613_35330A=" afp_";
char*s118_784841421A="Unable to solve cyclic anchored types.";
char*s102_107634778A="Because of the usual low priority of prefix minus, `-foo.bar\' is actually equivalent to `-(foo.bar)\'. In order to avoid a possible mistake here, it is mandatory for you to add extra parentheses here. You can wrap ";
char*s408_350193314A="Overflow of infix \"-\" with INTEGER_64 operands. (";
char*s716_269141588A="\173""/*mark_item*/\n";
char*s105_1043946153A="Unexpected text continuation";
char*s111_1515266530A="You must choose either -cc or -c_mode, but you cannot use them both.";
char*s115_1065942137A="print_profile(profile_file, &root_profile);\n";
char*s102_104977558A="Inline agent or expression expected after agent keyword.";
char*s124_1662662954A="SmallEiffelDirectory";
char*s405_401707956A=" is obviously expanded (i.e. the written type mark is \"";
char*s477_16902A="new ";
char*s429_1878889060A="Feature `manifest_make\' must have at least one INTEGER argument.";
char*s115_18131599A="se_dump_stack*,";
char*s543_1185594A="/sys/rc";
char*s832_784300160A=";\no2=o1+c->count_minus_one;\nfor(;o1<=o2;o1++)\173""\nif((o1->header.flag)==FSOH_MARKED)\173""\no1->header.flag=FSOH_UNMARKED;\n";
char*s829_1812279886A="void*result=GC_MALLOC_ATOMIC(n*sizeof(bdw_Twr));\nse_check_malloc(result);\nreturn result;\n";
char*s33_243411981A="bit_rotate";
char*s33_1419919903A="Maximum_character_code";
char*s102_2102385657A="Empty Cecil file (use -verbose flag for details).";
char*s408_211605167A="Overflow of infix \"-\" with INTEGER_8 operands. (";
char*s102_762747069A="\"retry\" cannot be outside of a rescue clause.";
char*s111_466551816A="$ link/exe=";
char*s111_2009849A="generic";
char*s115_1743948446A="==2, \"Recursive once function.\");\n\175""\n";
char*s834_1682659883A=".chunk_list=NULL;\n";
char*s832_1007239A="*b=((gc";
char*s793_630125369A="**** Fatal error: no $#(1) defined!";
char*s102_2028592127A="Removed unexpected blank space(s) just before this dot (assume you really want to call a procedure using the previous manifest expression as the target).";
char*s96_1838187926A="class-name: ";
char*s477_1163823042A="\nSee SmartEiffel/tutorial/external/C++ directory for more information.\n (Internal state = ";
char*s793_17725666A="#(1)/#(2)";
char*s33_1770803725A="from_external_sized_copy";
char*s34_16942A="loop";
char*s750_989731302A="Second occurrence of this value (\"";
char*s402_897982986A=" (\"\?=\" is not necessary).";
char*s829_1038016A="(int*n)";
char*s109_1783880762A="Collecting done";
char*s34_10049231A="generate";
char*s630_206419907A="fd.assertion_flag=1;\nfree_exception_frames();\n";
char*s832_931143030A="=n->header.next;\n\175""\nelse\173""\nif(c==NULL)c=gc_fsoc_get2();\n";
char*s625_810433A="(/*RF2:";
char*s280_1973946666A="TUPLE type expected for open arguments of agent type.";
char*s102_1062177790A="Extra \",\" ignored.";
char*s999_1994165009A="No support found for this external \"plug_in\" (plugin: \"";
char*s613_46733806A="static se_frame_descriptor fd=\173""";
char*s280_1838870713A=" has two conflicting external types";
char*s630_1008067448A="internal_exception_handler(";
char*s109_485115581A=" (magic_count=";
char*s473_2101296982A=" type is not allowed.)";
char*s832_90782A="void ";
char*s999_1508488213A=" defined in ";
char*s630_20481355A=") break;\n";
char*s642_90792A="void*";
char*s34_78490A="class";
char*s35_78495A="clean";
char*s111_146157A=" /link";
char*s716_1428771266A="void  gc_info(void)";
char*s346_931579788A="Cannot pass Void as argument (the formal type is expanded).";
char*s999_1942675017A="Including source ";
char*s635_252669317A="((void*)a1);\n";
char*s33_41849945A="Real_bits";
char*s124_27561173A="Trying to read file \"";
char*s115_1533928773A=".......................................";
char*s808_2007377394A="Unknown loadpath";
char*s103_1658160521A="Expected \"[\" (to start generic argument list).";
char*s635_933501A="(NULL!=";
char*s478_1136691048A="\"set\", \"get\", or \"access\" keyword expected.";
char*s115_1170250908A="(/*UA*/((void)(";
char*s376_35157672A="Adapting ";
char*s102_1436398529A="Keyword \"loop\" expected (in a loop).";
char*s714_1657834530A="Compiling without Garbage Collector!\n";
char*s829_1619999729A="void bdw_weakref_setlink(bdw_Twr*wr,T0*r)";
char*s33_447584A="stderr";
char*s102_1414519430A="Error while reading fractional part of a real value (digit expected after the dot).";
char*s115_1404148845A="parent_profile,";
char*s115_958964069A=" agent wrapper: ";
char*s638_90405963A="*id=(*((T0**)R))->id;\n";
char*s485_439056951A="New name and old name must be different.";
char*s352_767649523A="..... unique target buffer .....";
char*s33_1554777A="POINTER";
char*s17_1216703285A="Some feature is not yet implemented (i.e. feature `not_yet_implemented\' of\nclass ANY has been called somewhere). Just run this code under the debugger\nto know the `not_yet_implemented\' caller.\n\nThe error occured in the type";
char*s456_22861847A=" insert: ";
char*s115_530940601A="\" (i.e. file(s) \"";
char*s115_724500276A="((/*agent*/void*)a)";
char*s481_1723490337A=" open operand cannot be the target of an agent call.";
char*s115_2109816196A="int argc,...)";
char*s33_591417242A="standard_twin";
char*s635_10895A="EIF_";
char*s102_2096474678A="**** Found potentially assignable expression";
char*s999_1439959996A=">. Strange dependency!";
char*s715_1061058398A="(GC_get_heap_size())";
char*s635_10430693A="isnormal";
char*s109_445497083A="Finished inlining of dynamic dispatch.\n";
char*s832_176986A="--;\nn=";
char*s115_997623147A="),\nfprintf(SE_ERR,\"-manifest_string_trace: line ";
char*s613_1623721137A="... once unique buffer ...";
char*s115_2055072316A="(T7*)se_string(";
char*s111_631091213A="\"[General] flavor\" key is missing.";
char*s33_1735712398A="object_as_pointer";
char*s832_73472312A="(&(o1->object));\n";
char*s96_625881326A=" is a generic class (missing actual generic";
char*s34_78591A="boost";
char*s630_379993A="ac_civ";
char*s714_1750560930A="se_malloc(1)";
char*s109_1224226011A="C.ADRIAN, P.REDAELLI, R.MACK";
char*s408_163270777A=" which is out of INTEGER_32 range.)";
char*s379_561523426A="...........";
char*s409_1490189105A=" while expression ";
char*s343_1060258809A="Incompatible number of arguments.";
char*s277_2108992007A="external_c_files";
char*s33_1192911276A="object_memory";
char*s102_631447998A="Must use exactely two hexadecimal digit for a CHARACTER constant.";
char*s34_10990481A="separate";
char*s635_1514442508A="((void*)(&a1));\n";
char*s716_84761A="newCL";
char*s102_1632732392A="Slash (\"/\") expected (inside CHARACTER constant).";
char*s33_167970159A="TEXT_FILE_READ";
char*s115_1253959973A="Function without Current";
char*s577_565060278A="/* C Header Pass 1: */\n";
char*s635_78629A="ds.p,";
char*s109_1605895597A="\" redefined as \"";
char*s105_126291003A="Bad program.\n(Closing \")\" not found.)";
char*s277_1658492806A="\" file.\nACE file not found.";
char*s33_48856070A="arguments";
char*s33_1622700141A="deep_twin_from";
char*s613_1694771411A="typedef struct _se_";
char*s115_78646A="ds.p=";
char*s283_722230651A=" which is actually already renamed as ";
char*s613_404651A="u->eq=";
char*s628_8087250A="UINT8_C(";
char*s630_119389596A="/*state*/=";
char*s102_1453916708A="Unexpected \";\" to end rename list (deleted).";
char*s102_844703215A="Infix operator name expected.";
char*s115_2237652A="static ";
char*s30_1364794873A="Unable to remove existing the file \"";
char*s409_1256137461A="Invalid assignment test. The left-hand side expression must conforms with the right-hand side. The left-hand side is of type ";
char*s647_1465905014A=" is deferred in type ";
char*s105_618869258A="Inserted \':\'";
char*s29_1852009437A=": missing C mode name after -c_mode flag.\n";
char*s103_174945438A="Error inside multi-line manifest string.";
char*s35_1777434714A="safety_check";
char*s102_501268295A=" to rename a feature. (Feature name expected.)";
char*s630_380065A="ac_ens";
char*s612_605650769A=" = \");\nse_prinT";
char*s109_313299890A="Cannot load root class ";
char*s102_1950357785A="End of TUPLE expression expected.";
char*s102_2077708091A="Unable to find the feature name which is mandatory just after the \"frozen\" keyword.";
char*s672_1760457965A="require else";
char*s115_850522083A="init_profile(&runinit_profile, \"<runinit>\");\n";
char*s111_447734A="wcc386";
char*s115_824324978A="se_introspecT[";
char*s357_793028699A="Feature found is a procedure.";
char*s413_2007408328A=" which is a simple and predefined expanded type.";
char*s34_17176A="none";
char*s405_1090404950A=" result.) (VWEQ)";
char*s336_1492212881A="System_level_type_error";
char*s693_78239462A="Classes path set more than once";
char*s102_2141291014A="Empty formal argument list (deleted).";
char*s647_1548937422A="Keyword \"require else\" replaced with \"require\" (There is no inherited require assertion here).";
char*s34_17206A="note";
char*s124_210141519A="Renaming \"";
char*s34_2065491A="inherit";
char*s611_565066528A="/* C Header Pass 3: */\n";
char*s115_27063164A="init_profile(agent_switch_profile+";
char*s636_1719326284A="\173""/*dumb copy*/";
char*s124_349372A="Total ";
char*s115_106460275A="*)a)->afp(";
char*s543_1722217257A="C:\\LIBERTY.CFG";
char*s33_84881A="low_8";
char*s34_17221A="once";
char*s115_1917882A="agents ";
char*s402_1424594977A="The expression ";
char*s834_576790349A=".store_left>0)\173""\n";
char*s111_129391217A="\" does not contain name of a valid file.\n";
char*s33_2038667775A="like Current";
char*s749_1762204931A="Not a good slice. The lower bound (";
char*s832_1497878015A=";\nif(gc_find_chunk(na)!=NULL)\173""/* non external NA */\n   rsoh*h=((rsoh*)na)-1;\n   if((h->header.magic_flag)==RSOH_UNMARKED)\173""\n      h->header.magic_flag=RSOH_MARKED;\n";
char*s102_2127445170A="Character \'%\"\' inserted after \"prefix\".";
char*s33_50246319A="generator";
char*s277_926093361A="The valid values for split are either \"legacy\" or \"by_type\".";
char*s542_1134353920A="safety checking";
char*s630_1898591066A="creatinstexp";
char*s115_545118879A="Precursor routine";
char*s630_380168A="ac_inv";
char*s102_23410A=" \011""[\000""\n";
char*s115_508495830A=").\",NULL);\n";
char*s832_77562923A="(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;\n";
char*s458_1790874766A="The type of this constant feature should be INTEGER or REAL.";
char*s370_7238542A="INTEGER ";
char*s102_469031018A="Expression expected after \"old\".";
char*s716_453998A="void X";
char*s635_1671077900A="((uint16_t)(";
char*s630_1952787551A="\173""int c=0;int v=0;\n";
char*s832_1739163321A=";o1++)\173""\nif((o1->header.flag)==FSOH_MARKED)\173""\no1->header.flag=FSOH_UNMARKED;\n";
char*s33_447851A="stdout";
char*s280_689575137A="Cyclic inheritance graph: ";
char*s483_29585A=" >> \175""";
char*s578_100561530A="), &(o2->_";
char*s33_2098363273A="is_subnormal";
char*s109_1004555549A="Internal compiler error. Definition of infix \"^\" of INTEGER_GENERAL is not coherent with compiler builtin simplifications.";
char*s33_349117293A="NATIVE_ARRAY";
char*s30_1812938425A="Bad executable name: \"";
char*s103_1861857328A="Deleted extra semi-colon.";
char*s118_1816788953A=". The assigner feature is expected to have exactly one more argument than the assigned feature.";
char*s647_1541882313A=" is inherited more than once.";
char*s543_4992A="    ";
char*s750_2131486419A="inspectManifestStringExpression";
char*s102_179688005A="Expected a non-empty types list.";
char*s102_928941315A="Constraint Class name expected.";
char*s109_1836299930A="Measurements done during inlining of dynamic dispatch:\n";
char*s124_195766720A="Unable to write error(s)/warning(s) redirection output file \"";
char*s102_1680421289A="Void cannot be the left-hand side of the binary \"+\" operator.";
char*s408_165614527A=" which is out of INTEGER_16 range.)";
char*s33_84969A="lower";
char*s613_2142146116A="int R=1;\nse_";
char*s630_380218A="ac_liv";
char*s829_101355036A="if(bdw_in_assign)bdw_delayed_finalize=1;\nelse\173""\nhandle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s408_1057872442A=" which is out of range -63 ..63 because target type is INTEGER_64.";
char*s635_204519611A="if(R)\173""\nT0*o1=C->_";
char*s999_838816886A="). No description file found.";
char*s118_1998329594A="\" come from the same original feature via multiple \"insert\" paths, but none comes via an \"inherit\" path.\nBelow, you get the feature evolution step by step. Note that in the end (type ";
char*s829_800004081A="T0*bdw_weakref_getlink(bdw_Twr*wr)";
char*s102_75828399A="\" as a local variable name.";
char*s102_1204389280A="You are using a case sensitive language in which all class names must use only upper case letters. This decision was made to make the code more readable and to allow better error messages as well as syntax error recovery. The name \"";
char*s440_1628100917A="Unable to find file for class \"";
char*s103_1578831409A="Expression expected after assignment test \"\?:=\".";
char*s102_1307652273A="Expected a feature name to assign.";
char*s102_1690004585A="Writable entity expected here. Argument ";
char*s829_486352305A="mark_native_arrays(";
char*s429_1627141371A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_make\').";
char*s35_914215870A="high_memory_compiler";
char*s111_1588150185A="The selected system name is \"";
char*s111_91157A="wlink";
char*s791_1932458562A="\' key in the ini file must be an integer.\n";
char*s471_375013061A="Such an expression cannot be on the left-hand side of an assignment operator. There is no assigner to `";
char*s96_8198176A="TUPLE...";
char*s635_60405A="R=1;\n";
char*s714_1345708525A="\173""/*mark_item*/\175""\n";
char*s458_1875641781A="Value out of INTEGER_16 range.";
char*s832_1831440704A="\175"",NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc";
char*s409_29662A=" \?:= ";
char*s749_1309017823A="The value is already part of previously encountered slice. (Wrong inspect statement.)";
char*s33_1487451A="NATURAL";
char*s277_1453633985A="Unknown assertion level tag.";
char*s115_495363549A="stop_profile(&master_profile, &global_profile);\n";
char*s715_1240206596A="void gc_start(void)";
char*s102_1545228536A="Cannot open Cecil file (use -verbose flag for details).";
char*s402_277033810A=" while the expression ";
char*s102_973007162A="Empty debug key list (deleted).";
char*s111_561720547A="\": unknown C compiler name after -cc flag or in the ACE file.\n";
char*s364_197895058A="Must use here a manifest STRING because the previous one used in this \"inspect\" statement is a manifest STRING.";
char*s109_1889118664A="No Polymorphic Call Site in the Live Code.\n";
char*s613_1387812168A=");\nu->creation_mold_id=";
char*s387_668815628A="The slice includes an already encountered value. (Wrong inspect statement.)";
char*s102_2108887750A="The base type is no longer used. Class ROUTINE now has only one formal argument. Just remove this unused type mark.";
char*s33_240810599A="c_inline_c";
char*s543_165909873A="/etc/liberty-eiffel";
char*s115_2022630A="error0(";
char*s113_11253A="BeOS";
char*s33_240810604A="c_inline_h";
char*s630_2022635A="error1(";
char*s119_128358027A="..................................................";
char*s34_392625A="assign";
char*s613_4999725A="*a2=(se_";
char*s102_199494346A="Keyword \"end\" expected at the end of a class.";
char*s613_706329A="\",1,0,\"";
char*s830_1777096676A="\n#define gc_mark";
char*s666_143852403A=". (The whole type of the agent your are trying to launch is ";
char*s647_831146693A="All ancestors are deferred, hence making this Precursor call not valid.";
char*s33_17422A="\174"">>>";
char*s33_2054549840A="manifest_put";
char*s102_1912621670A="This name cannot be used as a valid class name.";
char*s646_265537649A="/*INTERNAL_C_LOCAL list]*/\n";
char*s630_380343A="ac_req";
char*s666_167300030A=" into formal argument of type ";
char*s716_1384921237A="handle(SE_HANDLE_EXIT_GC,NULL);\n";
char*s102_922446006A="Overflow while reading integer constant. Value `";
char*s102_66884963A="Error while reading an integer constant. Missing \"\175""\" \?";
char*s102_134219969A="Error while reading an hexadecimal value. Missing \"\175""\" \?";
char*s30_53561911A="no_rescue";
char*s115_471553120A="parent_profile=&global_profile;\n";
char*s716_1374304640A="fprintf(SE_GCINFO,\"--------------------\\nNumber\\tTotal\\tStore\\tName\\ncreated\\tsize\\tleft\\n\");\n";
char*s630_504830035A=")) \173""switch(";
char*s386_128333478A="The corresponding feature definition.";
char*s111_262628264A="linkit.com";
char*s630_1888091524A="goto retry_tag;\n";
char*s477_1809088081A="data_member ";
char*s102_1701980726A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure using the previous STRING as target).";
char*s33_337331A="Result";
char*s115_17480A="se_i";
char*s96_1056980719A="Procedure \"";
char*s115_1680956616A="se_profile_t root_profile";
char*s102_2060540980A="Empty formal generic list (deleted).";
char*s638_5313505A="*exp=0;\n";
char*s35_17498A="sedb";
char*s124_1293738877A=" is not set.\n";
char*s102_1046025807A="The old \"select\" option of the \"inherit\" clause is now obsolete. You have to update your code with the new \"insert\" mechanism. With Liberty Eiffel, this can be achieved thanks to the new \"insert\" clause. The new \"insert\" clause comes just after the traditional \"inherit\" clause with a similar syntax.";
char*s33_1483884743A="native_array_internals_from_generating_type";
char*s577_985967445A="; /*NATURAL_";
char*s636_2102695A="memcpy(";
char*s115_17507A="prof";
char*s647_139854341A="Signature of the redefined feature is not valid.";
char*s102_2176510A="plug_in";
char*s102_552734069A="The SCOOP attempt implementation has been abandoned (December 2006). ";
char*s830_1387277146A="object;union \173""void*flag;gc";
char*s109_1556970935A="Unsafe call site (see also next warning).";
char*s716_35966A=" elt=";
char*s638_5313530A="*exp=1;\n";
char*s636_1416678934A=">>8)&0xFF00)\174""(((uint32_t)";
char*s387_492964813A="Second occurrence for this value in the same inspect. (Wrong inspect statement.)";
char*s103_1538234998A="Index value expected (\"indexing ...\").";
char*s34_306165094A="smarteiffel_options";
char*s109_921818688A="Monomorphic Procedure Call";
char*s408_1505530135A="Overflow of infix \"*\" with INTEGER_16 operands. (";
char*s635_46980416A="_t)((uint";
char*s118_870131842A=" (given first) can\'t be accepted because a concrete feature is inherited. What\'s called a concrete feature here is a feature which is not deferred. You may consider to add a redefine or an undefine. May be.";
char*s115_2072467813A="&local_profile";
char*s408_177461A=" by 0.";
char*s109_572614135A=" formal argument";
char*s283_867234734A="Redefinition of ";
char*s832_97510A="\175""\175""\175""\175""\n";
char*s96_445214625A=" is invalid. A deferred class must not be expanded.";
char*s29_386614A="bdw_gc";
char*s277_929353692A="linker_options";
char*s577_1316811340A="/*BUG:WR@runtime!*/";
char*s526_637371887A="Cannot create an ARRAY with only `Void\' items.";
char*s716_558682149A="void*gc_mark_agent_mold;\n";
char*s543_1707891936A="/.liberty-eiffel";
char*s543_11429A="HOME";
char*s109_170061979A="Target Type Prediction Score: ";
char*s716_398948A="gc_lib";
char*s613_5284A="\" (\"";
char*s102_755120513A="Inside a client list, only plain class names are allowed. (Class names must use only uppercase letters.)";
char*s517_890319497A=" which is out of INTEGER_64 range.";
char*s102_2087550139A="Keyword \"end\" added to finish this \"if\" statement.";
char*s613_21632225A="*)u1;\nse_";
char*s716_328118105A="manifest_string_mark1();\n";
char*s832_775406525A="p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));\nfor(;((void*)p)>=((void*)o);p--)\173""\ne=*p;\n";
char*s482_1370872538A="Invalid notation for 0.0.";
char*s829_473982927A="if(g!=o->bdw_generation)\173""\n";
char*s635_520373770A="((int16_t)(";
char*s35_10714216A="no_split";
char*s643_448205A="uint32";
char*s635_1836091144A="Bad number of arguments of external signature.";
char*s121_300594A="File \"";
char*s33_1740332382A="Minimum_double";
char*s109_1379717706A="Now inlining dynamic dispatch (using inspect instructions)\n";
char*s102_1606714210A="Since february 2006, for SmartEiffel release 2.3, the old legacy NONE type mark is obsolete. Keep in mind that an empty class name list such as \173""\175"" does indicate no exportation at all, hence making NONE useless and probably misleading for newcomers. So, just remove this NONE class name now. Please update your code now.";
char*s33_1644425991A="manifest_semicolon_check";
char*s647_1677586033A=". This can lead to catcalls!";
char*s613_4434071A=" called.";
char*s630_4766225A=" while (";
char*s413_1119905623A="`manifest_create\' is not an ordinary creation procedure. Please use the \173""";
char*s829_1509872874A="*o=*markna;\nGC_disable();\n";
char*s34_75797981A=" has no compiler-defined `deep_twin\' or `is_deep_equal\' because the corresponding allocated size is not part of the NATIVE_ARRAY object. The client class of this NATIVE_ARRAY type is supposed to use a `capacity\' attribute which contains the corresponding number of allocated items (see STRING or ARRAY for example).";
char*s716_49680837A="if (i <= ";
char*s103_744085684A="Right hand side expression of \?= assignment expected here.";
char*s115_1173628471A="]=runinit_profile;\n";
char*s566_146251545A=".unlock*/\n";
char*s33_267647687A="standard_is_equal";
char*s115_825893997A="/* Allocate an Eiffel STRING given its size and native storage */\n";
char*s478_380590A="access";
char*s829_1832086881A="(o)==NULL&&GC_should_invoke_finalizers())bdw_run_finalizers();\n";
char*s405_988692517A="\"). You can use the Void comparison only when other type mark is a reference type or, if it is an expanded type, it must be an anchor or some formal generic argument. Fix this error first.";
char*s385_5382A=" -- ";
char*s647_2025498932A=") of the concrete feature (inherited from type ";
char*s471_789350917A=" by a call to \173""";
char*s102_96053257A="No parent after \"insert\" keyword (an empty list is not allowed here).";
char*s277_17696A="root";
char*s102_1066804080A="Missing \":\" before the type mark\?";
char*s102_1062283098A="Only simple and statically computable expression are allowed here (inside \"when\" of \"inspect\" statement).";
char*s109_109671582A=" while there is no actual argument list in the call.";
char*s287_1831619428A="Too many errors.\n";
char*s334_1262756502A="Parsing Cecil file: ";
char*s716_444175272A="#define SE_GC_LIB 1\n";
char*s34_17715A="then";
char*s277_880804011A="Keyword \"root\" expected. Invalid ACE file.";
char*s638_300665A="R=(*((";
char*s103_2004339522A="Added missing brackets to enclose the previous \"once\" manifest STRING.";
char*s343_1001314405A="Incompatible signatures. (One has argument(s) but not the other.)";
char*s283_92467250A="Cannot redefine ";
char*s287_878860A="------\n";
char*s635_537910373A="se_deep_twin_trats()\n";
char*s102_112999293A="Instruction expected here. True alone is not an instruction.";
char*s571_30034A="&(((T";
char*s102_568400887A="`indexing\' is an obsolete keyword, please use `note\' instead.";
char*s115_1968768303A="master_profile.profile=NULL;\n";
char*s102_783329131A="Total time spent in parser: ";
char*s613_180709512A="return u->R;\n";
char*s102_1984637890A=" is not a feature name.";
char*s118_1605047378A=" type.\n\nFirst \"inherit\" path (from parent to child):\n   ";
char*s115_1435285930A="Define initialize stuff.\n";
char*s102_79251A="false";
char*s102_756929053A="Must use exactly 2 hexadecimal digits for INTEGER_8.";
char*s102_142936234A=" cannot be used as a feature name to start a new feature definition. Parser lost. Sorry. Check before and after that point.";
char*s647_21306364A="This Precursor call is ambiguous because the type ";
char*s115_738771309A="void initialize_eiffel_runtime(int argc,char*argv[])";
char*s109_295542551A="Polymorphic Function Call";
char*s613_386819A="caller";
char*s374_22401251A=" context.";
char*s103_348041349A="Error in inspect.";
char*s115_401124480A=" run classes :\n";
char*s343_1149307517A="Bad redefinition. An attribute must be redefined as an attribute only (VDRD.6).";
char*s429_1837585965A="Creation procedure not found.";
char*s716_1642168697A="void(*gc_mark_agent_mold)(se_";
char*s386_305790140A="This is not an INTEGER expression.";
char*s613_242108838A=" (1 feature).\n";
char*s613_56760755A="void*eq;\n";
char*s613_60837A="R=C->";
char*s613_1367040625A="retry_tag:\n";
char*s33_1979951A="dispose";
char*s486_1965077754A="Such an \"inspect\" statement is for type STRING or FIXED_STRING. (The type of ";
char*s115_471707221A="*sizeof(se_profile_t));\nqsort(sorted_inv_profile, ";
char*s464_1809998749A="\' not found.";
char*s113_17794A="vbcc";
char*s33_386854A="calloc";
char*s115_1844536619A="se_local_profile_t*,";
char*s612_1151663379A="fprintf(file,\"%llu\",(long long unsigned int)((uint64_t) *o));";
char*s102_776600004A="Explicit creation/create type mark should not be anchored.";
char*s830_1126647264A="*next;\175"" header;\175"";\n";
char*s384_2014931627A="External feature must not have rescue compound.";
char*s102_150329797A="Error while reading hexadecimal value.";
char*s115_802495724A="\");\nstart_profile(parent_profile, &local_profile);\n";
char*s124_1723571071A="................................................................";
char*s115_719604853A="=((T0*)eiffel_root_object);\n";
char*s113_39617954A="Macintosh";
char*s111_25704393A="/LIBPATH:";
char*s572_5515A="\").\n";
char*s102_397329363A="Inheritance option not at a correct place. The correct order is: \"rename... export... undefine... redefine...\".";
char*s115_1881374985A="memcpy(sorted_agent_profile, agent_profile, ";
char*s115_713312393A=", inv_profile, ";
char*s102_676769302A="Syntax error while trying to parse the beginning of a new feature definition. Expression ";
char*s33_79341A="count";
char*s613_882065083A=";\nstruct _se_";
char*s115_862271166A="ds.fd->assertion_flag=1;\n\175""\n";
char*s287_60894A="Error";
char*s33_48672249A="bit_clear";
char*s115_23988287A="#include ";
char*s115_1682814572A="manifest_put(";
char*s33_572288431A="to_natural_16";
char*s109_1019367716A=" (For this call, the target is the implicit non written `Current\' which is of type ";
char*s542_1381550903A="simplifying";
char*s793_2078852867A="#(1)/.config";
char*s33_572288437A="to_natural_32";
char*s716_189437896A="unsigned int fsoc_count_ceil";
char*s716_1891487260A="(gc_memory_used())";
char*s109_91926102A=" starting from cluster ";
char*s408_530141799A="Violated require assertion. Argument value is ";
char*s613_560761477A="internal_exception_handler(Routine_failure);\n\175""\n";
char*s102_202933204A=" cannot be an expression. ";
char*s33_572288454A="to_natural_64";
char*s115_1672511676A="global_profile.profile=&root_profile;\n";
char*s715_6943896A="GC_DEBUG";
char*s102_120546715A="Left hand side expression of := assignment must be a feature call.";
char*s109_479236135A="Result type of a once function must not involve formal generic names nor anchored types (VFFD.8).";
char*s612_5580A="\");\n";
char*s109_1865554673A="Live_type_map size=";
char*s102_922212712A="Variant (INTEGER) Expression Expected.";
char*s109_1162901343A="Starting optimization (";
char*s613_674382779A="(void**)&R,";
char*s109_1546692995A=" while the actual argument list has ";
char*s483_1411247976A=". (Actual bunch size is ";
char*s715_1665893228A="Adding Boehm-Demers-Weiser Garbage Collector.\n";
char*s115_1842506892A="se_local_profile_t local_profile;\nstatic se_profile_t prof;\nstatic int prof_init=0;\n";
char*s115_4692662A="#define ";
char*s829_2070967345A="typedef struct bdw_Swr\173""Tid id;T0*o;\175""bdw_Twr;\n";
char*s630_312808564A=")->_storage + ((";
char*s628_218852042A="(/*OUTCA*/CA_";
char*s115_1994596535A="void(*se_prinT[";
char*s641_17916A="uint";
char*s829_42521A=")obj)";
char*s109_5615A="\".)\n";
char*s115_4631170A="/*PCO*/\n";
char*s115_1413407004A="Cecil (C function for external code) :\n";
char*s33_1680926299A="default_create";
char*s34_436196A="rename";
char*s483_1142240176A=" into formal argument which is of type ";
char*s791_602797481A="Redundant key definition found in section [";
char*s111_120239233A="1234567890";
char*s832_28263330A=",size));\n";
char*s33_506823435A="manifest_creation";
char*s35_10554609A="loadpath";
char*s277_816126476A="Unused obsolete flag -wedit / option wedit.";
char*s102_1869854287A="Unexpected bracket after a comma.";
char*s102_2009918711A="Error inside feature name definition. Unable to find the synonymous name which must be just after the previous colon mark \",\".";
char*s696_861846863A="Legacy splitter enabled.\n";
char*s33_39002989A="PREDICATE";
char*s542_456083848A="The system is not type safe (read previous warnings carefully).";
char*s29_85614A="no_gc";
char*s630_521905705A=")->_count;\n";
char*s832_291421585A="size=(size*sizeof(";
char*s115_1586354711A="uint32_t lsi";
char*s458_865125357A="A \"unique\" definition is actually a constant attribute definition.";
char*s715_1166044581A="GC_java_finalization=1;\nGC_finalize_on_demand=1;\nGC_finalizer_notifier=bdw_run_finalizers;\nGC_INIT();\nGC_stackbottom=(char*)(void*)&argc;\n";
char*s102_971408488A="Right hand side expression of ";
char*s490_1773984820A=" Replace your code with:\n\n      agent ";
char*s109_866669263A="Handling include of \"";
char*s477_1961687A="delete ";
char*s120_51895507A="error1(\"Invalid inspect (nothing selected).\",";
char*s124_1635864124A="SmartEiffelDirectory";
char*s832_1815688614A="*)(&(c->first_object)));\nif(c->header.state_type==FSO_STORE_CHUNK)\173""\nfor(;o1<";
char*s102_210812758A="\" does not contain class \"";
char*s402_1250079569A="The left-hand side of ";
char*s647_1722095007A="Signature (adapted in the type ";
char*s429_1333985363A="Feature `manifest_make\' must be a procedure.";
char*s115_2041682A="extern ";
char*s352_786054293A="Forbidden call (i.e. exportation rules violated) when the type of Current is ";
char*s613_988243818A="\173""Tid id;\nint creation_mold_id;\n";
char*s33_1937220099A="is_deep_equal";
char*s613_5720A="\",1\175""";
char*s832_598811726A=".store_left>sizeof(rsoh))\173""\nr->header.size=size;\n";
char*s110_1461366457A="Version of command \"#(1)\" is:";
char*s753_1613492996A="Invalid byte as first character of UTF-8 sequence.";
char*s102_18036A="true";
char*s33_247239028A="collecting";
char*s715_1942608409A="gc_start();\n";
char*s716_41125176A="gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);\n((gc";
char*s833_1506490209A=")\nfprintf(SE_GCINFO,\"%d\\t%d\\t\\t";
char*s628_1406782500A="/*ND*/(T0*)(";
char*s29_425790270A=": missing split mode after -split flag.\n";
char*s115_2103819988A="int se_strucT";
char*s405_1816888147A=". Comparison not allowed (VWEQ).";
char*s102_1694969179A="Such an expression cannot be on the left-hand side of an assignment operator. A dot can never be used for the left-hand side part of an assignment operator. Valid left-hand side can be Result, some local or the name of an attribute of Current. See also http://SmartEiffel/wiki/en/Syntax_diagrams#Writable.php for details.";
char*s115_1836282258A="se_local_profile_t global_profile";
char*s628_1188262106A="/*$*/((void*)W";
char*s102_825716016A="Name of the current class expected.";
char*s832_1649648619A="o=(&(p->object));\n";
char*s115_273731430A="se_string(";
char*s33_1549680A="REAL_32";
char*s830_130382376A=";\nstruct B";
char*s476_1848584263A="Double definition found for key ";
char*s343_1642968637A="\' but different signatures. According to the join rule, the signatures have to be identical in the final class.";
char*s832_1040644265A="*n;\nfsoc*c;\n";
char*s115_1042003640A="int(*eq)(se_agent*,se_agent*);\n\175"";\n";
char*s374_5787A=" := ";
char*s34_18090A="when";
char*s456_114137597A=" inherit: ";
char*s636_946895A="#endif\n";
char*s402_1721307786A="Void cannot be the right-hand side of a ";
char*s33_1549697A="REAL_64";
char*s115_1352413868A="int32_t c,uint16_t*s,int32_t sc,int16_t*lsv,int32_t*lsi)";
char*s608_11952A="T0**";
char*s33_1549703A="REAL_80";
char*s109_98784712A="\' in type ";
char*s276_1968202785A=" (See next message to locate the error.)";
char*s33_18110A="twin";
char*s115_1063704391A="fprintf(profile_file, \"\\n===============================================================================\\nDetailed profile:\\n\");\n";
char*s613_1566831588A="ds.exception_origin=NULL;\n";
char*s115_1339521386A="fprintf(profile_file, \"===============================================================================\\nSummary:\\n\");\n";
char*s277_374877A="_check";
char*s715_674383009A="(void*)0,0,";
char*s715_1635390646A="GC support (functions).\n";
char*s832_2021999449A="gc_update_weak_ref_item";
char*s647_1849347035A=") is not compatible with the deferred one comming from parent type ";
char*s115_1460025642A="start_profile(&master_profile, &global_profile);\n";
char*s832_484169497A=".store_left=0;\n\175""\n(r->header.magic_flag)=RSOH_UNMARKED;\n((void)memset((r+1),0,r->header.size-sizeof(rsoh)));\nreturn((T";
char*s483_14429929A=" not correctly equiped for manifest generic creation (`manifest_creation\' missing in the creation clause).";
char*s124_809686569A="\".\nCommand aborted.\n";
char*s630_6575105A=";break;\n";
char*s113_18144A="vpcc";
char*s102_18150A="void";
char*s118_290966604A=") there are two versions of the same initial feature with two different names. To  fix this, either use enough \"inherit\" links in place of \"insert\" links to have one \"inherit\" path or rename the feature to get the same name in ";
char*s832_322115272A="*)(wr->o);\nif (obj_ptr != NULL)\173""\nint swept = (((void*)obj_ptr) <= ((void*)wr));\nif (swept != (obj_ptr->header.flag == FSOH_MARKED)) /* **** TODO: was FSOH_UNMARKED\?\?\?\? (incoherent with comment below) */\n/* (already swept) xor marked */\nwr->o = NULL;\n\175""\n";
char*s636_2122389958A="se_print_run_time_stack();\n";
char*s115_1624663341A=")(va_arg(pa,";
char*s102_1320619413A="Added missing \":\" semicolon before this type mark.";
char*s102_442256615A="\" aborted.\n";
char*s628_112304676A="..........";
char*s459_2015374870A="Conflict between argument/feature name (VRFA).";
char*s613_472574902A="(se_agent*u1, se_agent*u2)";
char*s277_1325140408A=": cannot use -sedb with -boost flag.\n";
char*s35_267875778A="no_warning";
char*s478_18186A="type";
char*s832_1985327250A="se_gc_check_id(o,";
char*s832_1196941282A="n->object=M";
char*s33_1176378494A="type_can_be_assigned_to_item";
char*s635_559906822A=" built-in: ";
char*s543_1096544670A="/lang/eiffel/.serc";
char*s124_203714719A="Obsolete \"";
char*s33_55924644A="std_error";
char*s830_2097247A="na_env ";
char*s122_2120987577A="..... unique buffer .....";
char*s402_5912A=" \?= ";
char*s283_1153312264A=" not found in this class.";
char*s115_163413385A="se_profile_t agent_profile";
char*s832_1800342110A="++;\n\175""\nelse if(";
char*s613_1992825354A="\173""\"invariant ";
char*s635_854330615A="\175""\nse_deep_equal_trats()\n";
char*s999_1067567332A="The plugin ";
char*s33_1673348567A="open_argument_index";
char*s109_5873980A="Unknown infix operator \"";
char*s643_399591A="double";
char*s96_1539816514A=" is not a generic class. (See file \"";
char*s124_44975894A="Writing \"";
char*s34_56927287A="c_linker_path";
char*s635_1709245815A=";\nerror0(\"Invalid deep_twin.\",NULL)";
char*s635_4680700A="!memcmp(";
char*s102_518055462A="Local variable name expected after comma inside local variable list.";
char*s483_84293096A="Wrong number of arguments for manifest generic creation.";
char*s33_1831158645A="INTERNALS_HANDLER";
char*s832_175186427A="*old_gc_free=gc_free";
char*s102_732257893A="\')\' expected in expression.";
char*s630_352968782A=");\nif(NULL!=(";
char*s115_49152444A="ds.caller";
char*s376_18257A="yes ";
char*s409_902517583A="........................";
char*s828_496139469A="Internal problem for \"mark_native_arrays\".";
char*s287_927785894A="Fatal Error";
char*s336_673829558A="Incorrect_inspect_value";
char*s364_1664909434A="Cannot use \'..\' with manifest strings.";
char*s458_529299514A="A boolean constant cannot be an assigner.";
char*s102_1387339410A=" is not writable. Cannot use ";
char*s102_445504446A="\" expected.";
char*s109_1242126608A="Starting type safety check";
char*s35_10714862A="no_strip";
char*s111_1494914262A=" Ignore=93,194,304";
char*s115_5980A=" C;\n";
char*s458_827998241A=" has no result type";
char*s432_983618541A=" Constraint Generic Violation.";
char*s715_341361877A="int bdw_in_assign";
char*s716_1869700848A="*)eiffel_root_object)->header.flag=FSOH_UNMARKED;\n";
char*s109_1568923104A=" must have a feature named `";
char*s113_448859A="wcl386";
char*s33_1553736287A="REAL_EXTENDED";
char*s34_1980461A="convert";
char*s832_744114A="&&(((gc";
char*s102_1575461624A="A feature name cannot be used to indicate exportation status in a client list. Only plain class names are allowed here (class names must use only uppercase letters).";
char*s102_1181926797A="Added \"end\" for inspect instruction.";
char*s636_531809155A=">>8);\n#else\n";
char*s115_8359055A="set_dump_stack_top(";
char*s102_1978106088A="Erreur while reading a number.";
char*s33_9712276A="as_16_ne";
char*s716_172080A="*)o);\n";
char*s638_705408837A="*id=_r->id;R=&_r;break;\ndefault:break;\n\175""\n\175""\n\175""\n";
char*s34_1168210079A="cpp_linker_path";
char*s829_1664195965A="void*bdw_na_assign_innerT";
char*s635_42916A="(uint";
char*s29_24284008A=": missing compiler name after -cc flag.\n";
char*s716_249330648A="gc_info_nb";
char*s283_1145998825A="\" (forbidden or not yet implemented).";
char*s635_842552A="*)R)=*C";
char*s115_431043495A="*sizeof(se_profile_t));\n";
char*s115_490486762A="local_profile.profile=&atexit_profile;\n";
char*s102_727903062A="Bad create expression (\'\173""\' expected).";
char*s111_165012750A="\"[General] os\" key is missing.";
char*s111_2075119688A="#1#2#3#4#5#6#7#8#9#\?.o";
char*s428_306215109A="An assertion must be a BOOLEAN expression.";
char*s102_1583181163A="Void is not a valid inspect expression (just after keyword \"inspect\").";
char*s115_1377208779A=";\nstart_profile(parent_profile, &local_profile);\n";
char*s635_153655A="&(C->_";
char*s109_212031001A="The main procedure must not have arguments.";
char*s102_12184A="NONE";
char*s108_1152235958A=" transitions.\n";
char*s115_1160736641A="Manifest String";
char*s85_1501391323A="Adapting Cecil features.\n";
char*s115_12188A="T7*g";
char*s115_113036818A="local_profile.profile=agent_switch_profile+";
char*s115_12201A="T7*t";
char*s102_34383990A="Error while reading a number.";
char*s103_35386613A="...............................................";
char*s453_498169402A=". An expanded type must have one unique creation procedure with no argument: the creation procedure used for automatic initialization. Please, consider to add explicitely the `default_create\' procedure from ANY or some other existing procedure with no arguments. For expanded class with no creation clause, the `default_create\' procedure is the one used for automatic initialization.";
char*s102_1593742473A="Closing \">>\" of manifest generic creation expected.";
char*s118_740900172A="Assigned feature not found in type";
char*s102_2018315248A="Parsing Cecil File: \"";
char*s115_1009317511A="Compiling/Sorting ";
char*s102_124311631A="Void cannot be the left-hand side of the binary \"^\" operator.";
char*s526_1359629264A="The old manifest ARRAY notation can only be used when the common type mark for all items of the manifest ARRAY exists, is not ambiguous and is easy to compute! By the way, it is not easy or possible to compute the most general type for the following set of types: \173""";
char*s432_1920465143A="Actual generic derivation ";
char*s690_8777401A="Universe";
char*s115_1838958244A="/*agent*/T0*a";
char*s102_1962710217A="\")\" expected to end debug string list.";
char*s832_1901427808A="T0* obj_ptr = item->o;\nif (obj_ptr != NULL)\173""\nint obj_size=se_strucT[obj_ptr->id];\nint swept";
char*s832_365929075A=".count_minus_one;\nn=";
char*s834_958639438A=".store->header.magic_flag=RSOH_FREE;\n";
char*s716_1328320695A="mark_stack_and_registers();\ngc_sweep();\ncollector_counter++;\n";
char*s111_5578901A="-include";
char*s336_176865800A="Developer_exception";
char*s628_7227375A="INT64_C(";
char*s102_431394186A="Character \'%\"\' inserted.";
char*s613_9589368A="agent_eq";
char*s829_1048179568A="GC_disable();\nif(wr->o)GC_unregister_disappearing_link((void**)&(wr->o));\nwr->o=r;\nif(r)GC_GENERAL_REGISTER_DISAPPEARING_LINK((void**)&(wr->o),(void*)r);\nGC_enable();\n";
char*s35_388005040A="case_insensitive";
char*s111_1319327951A="loadpath.se";
char*s647_374042271A="The \"feature\" clause declares a narrower client list than";
char*s109_3579844A=" (type \"";
char*s34_1747646688A="c_strip_path";
char*s578_51582255A="int R=0;\n";
char*s714_264935842A="))->o)=(T0*)(";
char*s124_141444A="\" as \"";
char*s103_432335312A="Same identifier appears twice (local/formal).";
char*s832_1265395998A=".store))+size));\n\175""\nelse \173""\nr->header.size=size+";
char*s628_40430500A="UINT64_C(";
char*s613_5794220A="=(u->CA_";
char*s277_1598804806A="At this point in the ACE file, you are supposed to say \"yes\", \"no\", or \"all\".";
char*s628_860088160A="(/*OUTCL:OUT*/*CL_";
char*s105_356743A="Bad program.\n(No program name found.)";
char*s115_209121A="(live)";
char*s102_1615234134A="Since february 2006, for SmartEiffel release 2.3, the old legacy NONE type mark is obsolete. Keep in mind that an empty class name list like \173""\175"" do indicate no exportation at all, hence making NONE unuseful and probably misleading for newcomers. So, just remove this NONE class name right now. Please update your code now.";
char*s613_338723264A="This routine is actually deferred is still in the live code set. (You will have a crash at run-time if the dynamic type of Current is ";
char*s458_1573210512A="The type of this constant feature should be CHARACTER.";
char*s115_1790869799A="C++ external definitions.\n";
char*s613_3912034A="(&(a1->c";
char*s668_1257368965A="ensure then";

#ifdef __cplusplus
}
#endif
