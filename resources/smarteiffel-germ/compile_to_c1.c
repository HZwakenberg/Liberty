#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by 
Liberty Eiffel The GNU Eiffel Compiler, Eiffel tools and libraries
    release 2014.dev (Alexander Graham Bell)

Copyright (C), 2011-2014 - C.ADRIAN, P.REDAELLI, R.MACK
    http://www.liberty-eiffel.org

Original SmartEiffel code:
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER, F.MERIZEN
    http://smarteiffel.loria.fr
C Compiler options used: -pipe -O2 -fno-gcse
*/

#ifdef __cplusplus
}
#endif
#include "compile_to_c.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
	*dest++ = (*src << 8) | (*src >> 8);
	src++;
  }
}


void se_check_malloc(const void*result, const char*format, ...) {
  if (result == NULL) {
	handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
	internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
	error0("No more memory.", NULL);
#else
	va_list arg;
	va_start(arg, format);
	vfprintf(SE_ERR,format, arg);
	va_end(arg);
	exit(EXIT_FAILURE);
#endif
  }
}

/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
   return se_malloc_(size, malloc);
}

void* se_malloc_(size_t size, void*(*alloc)(size_t)) {
  void *result = alloc(size);
  se_check_malloc(result, "No more memory (malloc failed).\n");
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
   return se_calloc_(nmemb, size, calloc);
}

void* se_calloc_(size_t nmemb, size_t size, void*(*alloc)(size_t,size_t)) {
  void *result = alloc(nmemb,size);
  se_check_malloc(result, "No more memory (calloc failed: %lu x %lu).\n", nmemb, size);
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  se_check_malloc(result, "No more memory (realloc failed).\n");
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
	Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
	handlers[i](action, data);
	/* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_win32
static char* envp(void) {
  static char* result = "\0";/* *** Maybe call GetFullPathName to set =C: and friends */
  return result;
}

EIF_BOOLEAN basic_exec_win32_execute(se_exec_data_t*data, char*args, EIF_BOOLEAN keep_env, char*add_env, HANDLE*in_h, HANDLE*out_h, HANDLE*err_h) {
  STARTUPINFO start_info;
  EIF_BOOLEAN result = 0;

  ZeroMemory( &start_info, sizeof(STARTUPINFO) );

  start_info.cb = sizeof(STARTUPINFO);
  if(in_h) {
    start_info.hStdInput = in_h[0];
    SetHandleInformation(in_h[1], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdInput) goto leave;
  if(out_h) {
    start_info.hStdOutput = out_h[1];
    SetHandleInformation(out_h[0], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdOutput) goto leave;
  if(err_h) {
    start_info.hStdError = err_h[1];
    SetHandleInformation(err_h[0], HANDLE_FLAG_INHERIT, 0);
  } else {
    start_info.hStdError = GetStdHandle(STD_ERROR_HANDLE);
  }
  if(INVALID_HANDLE_VALUE == start_info.hStdError) goto leave;
  start_info.dwFlags |= STARTF_USESTDHANDLES;

  if(CreateProcess(NULL, args,
                   NULL,                                /* process security attributes          */
                   NULL,                                /* primary thread security attributes   */
                   TRUE,                                /* handles are inherited                */
                   0,                                   /* creation flags                       */
                   keep_env?NULL:envp(),
                   NULL,                                /* use parent's current directory       */
                   &start_info,                         /* STARTUPINFO pointer                  */
                   &data->process_information)) {       /* receives PROCESS_INFORMATION         */
    CloseHandle(data->process_information.hThread);
    data->running = 1;
    result = 1;
  }
 leave:
  if(in_h) CloseHandle(in_h[0]);
  if(out_h) CloseHandle(out_h[1]);
  if(err_h) CloseHandle(err_h[1]);
  return result;
}

EIF_BOOLEAN basic_exec_init_pipe(HANDLE*pipe) {
  SECURITY_ATTRIBUTES security_attributes;

  // Set the bInheritHandle flag so pipe handles are inherited.

  security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
  security_attributes.bInheritHandle = TRUE;
  security_attributes.lpSecurityDescriptor = NULL;

  return CreatePipe(pipe, pipe+1, &security_attributes, 0);
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  EIF_BOOLEAN result = (EIF_BOOLEAN)0;
  if (data->running) {
    result = (WaitForSingleObject(data->process_information.hProcess, 0) == WAIT_OBJECT_0);
    if (result) {
      /* child is finished */
      DWORD status;
      GetExitCodeProcess(data->process_information.hProcess, &status);
      /* *** Could have failed */
      basic_exec_cleanup(data, status);
    }
  }
  else{
    result = (EIF_BOOLEAN)1;
  }
  return result;
}

void basic_exec_wait(se_exec_data_t*data) {
  if (data->running) {
    DWORD status;
    WaitForSingleObject(data->process_information.hProcess, INFINITE);
    GetExitCodeProcess(data->process_information.hProcess, &status);
    /* *** Any of these calls could have failed, right? */
    basic_exec_cleanup(data, status);
  }
}

EIF_INTEGER basic_exec_win32_get_character (HANDLE h) {
  char result;
  DWORD num_read;

  ReadFile(h, &result, 1, &num_read, NULL);
  if(!num_read) return -1;
  return result;
}

void basic_exec_win32_put_character(HANDLE h, EIF_CHARACTER c) {
  DWORD num_written;

  WriteFile(h, &c, 1, &num_written, NULL);
  /* *** Do something if num_written!=1 or WriteFile returned 0. */
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
  data->status = status;
  data->running = 0;
  CloseHandle(data->process_information.hProcess);
}

EIF_BOOLEAN basic_exec_win32_wait_any(HANDLE*handles, DWORD count, se_exec_data_t*data) {
  DWORD result = WaitForMultipleObjects(count, handles, FALSE, INFINITE);
  EIF_BOOLEAN success = (result < (WAIT_OBJECT_0 + count));
  if(success) {
    int index = result - WAIT_OBJECT_0;
    HANDLE handle = handles[index];
    GetExitCodeProcess(handle, &data->status);
    data->process_information.hProcess = handle;
  }
  return success;
}

EIF_BOOLEAN basic_exec_win32_any_finished(HANDLE*handles, DWORD count, se_exec_data_t*data ) {
  DWORD result = WaitForMultipleObjects(count, handles, FALSE, 0);
  EIF_BOOLEAN success = (result < (WAIT_OBJECT_0 + count));
  if(success) {
    int index = result - WAIT_OBJECT_0;
    HANDLE handle = handles[index];
    GetExitCodeProcess(handle, &data->status);
    data->process_information.hProcess = handle;
  }
  return success;
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   return -1;
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   return -1;
}
#else
EIF_INTEGER basic_exec_win32_get_character (void *h) {
  return 0;
}

void basic_exec_win32_put_character(void *h, EIF_CHARACTER c) {
}

EIF_BOOLEAN basic_exec_win32_wait_any(void*handles, int count, se_exec_data_t*data) {
  return 0;
}

EIF_BOOLEAN basic_exec_win32_any_finished(void*handles, int count, se_exec_data_t*data) {
  return 0;
}

EIF_BOOLEAN basic_exec_win32_execute(se_exec_data_t*data, char*args, EIF_BOOLEAN keep_env, char*add_env, void*in_h, void*out_h, void*err_h) {
  return 0;
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_posix
static char** envp(void) {
  static char* result[] = {"PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL};
  return result;
}

static int arr_size(char** arr){
  int size = 0;
  while(arr[size] != NULL) {
    size++;
  }
  return size;
}

static int find_variable(char** env, char* var){
  int location;
  int src_size;
  if(var == NULL || env == NULL)
    return -1;
  src_size = strchr(var, '=') - var + 1;
  for(location = 0; env[location] != NULL; location++){
    if(strncasecmp(env[location], var, src_size) == 0){
      return location;
    }
  }
  return -1;
}

static void check_write(int expected, int actual) {
   if (actual != expected) {
    handle(SE_HANDLE_RUNTIME_ERROR, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#elif !defined(SE_BOOST)
    error0("Routine failure: could not write.", NULL);
#else
    fprintf(SE_ERR,"Routine failure (write returned %d but expected %d).\n", actual, expected);
    exit(EXIT_FAILURE);
#endif
  }
}

EIF_BOOLEAN basic_exec_posix_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  int id = fork();
  if (id == 0) {
    /* child */

    if(in_fd) {
      dup2(in_fd[0], 0);
      close(in_fd[1]);
    }

    if(out_fd) {
      dup2(out_fd[1], 1);
      close(out_fd[0]);
    }

    if(err_fd) {
      dup2(err_fd[1], 2);
      close(err_fd[0]);
    }

    if (prog == NULL && args == NULL) {
      data->running = 1;
      data->child = 1;
#ifdef SE_SEDB
      sedb_duplicate();
#endif
      return 1;
    } else {
      if (add_env == NULL && keep_env) {
        execvp(prog, args); /* NO RETURN in child */
        se_print_run_time_stack();
        exit(1);
      }else{
        char** new_env;
        char** old_env;
        int old_size, add_size;
        int src, dest = 0;
        if(keep_env){
          old_env = environ;
        }else{
          old_env = envp();
        }
        old_size = arr_size(old_env);
        add_size = arr_size(add_env);
        new_env = malloc(sizeof(void*) * (old_size + add_size));

        /* we first copy the pointers from the old env */
        for(src = 0; src < old_size; src++){
          new_env[dest++] = old_env[src];
        }

        /* now the ones from add_env */
        for(src = 0; src < add_size; src++){
          int override = find_variable(old_env, add_env[src]);
          if (override >= 0){
            new_env[override] = add_env[src];
          }else{
            new_env[dest++] = add_env[src];
          }
        }

        execve(prog, args, new_env); /* NO RETURN in child */
        se_print_run_time_stack();
        exit(1);
      }
    }
  }
  else if (id > 0) {
    /* father */
    data->id = id;
    data->running = 1;
    data->child = 0;
    if(in_fd) close(in_fd[0]);
    if(out_fd) close(out_fd[1]);
    if(err_fd) close(err_fd[1]);
    return 1;
  } else {
    return 0; /* ... in father only */
  }
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  EIF_BOOLEAN result = (EIF_BOOLEAN)0;
  int status;
  if (data->running) {
    int id = waitpid(data->id, &status, WNOHANG);
    if (id == data->id) {
      /* child is finished */
      result = (EIF_BOOLEAN)(id == data->id);
      basic_exec_cleanup(data, status);
    }
  }
  else{
    result = (EIF_BOOLEAN)1;
  }
  return result;
}

void basic_exec_wait(se_exec_data_t*data) {
  int status;
  if (data->running) {
    int id = waitpid(data->id, &status, 0);
    if (id == data->id) {
      basic_exec_cleanup(data, status);
    }
  }
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
  data->status = WEXITSTATUS(status);
  data->running = 0;
}

EIF_INTEGER basic_exec_posix_get_character (EIF_INTEGER fd) {
  EIF_INTEGER result = -1;
  char buf[1];
  ssize_t r = read(fd, buf, 1);
  if (r > 0) {
    result = 0xff & ((EIF_INTEGER)(buf[0]));
  }
  return result;
}

void basic_exec_posix_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
  char buf[1];
  buf[0] = c;
  check_write(1, write(fd, buf, 1));
}

void basic_exec_posix_wait_any(se_exec_data_t*data) {
  data->id = wait(&data->status);
}

void basic_exec_posix_any_finished(se_exec_data_t*data) {
  data->id = waitpid(-1, &data->status, WNOHANG);
}

/*
 * See http://stackoverflow.com/questions/282176/waitpid-equivalent-with-timeout
 *
 * (with specific adaptation to Liberty Eiffel)
 */
static int waitpid_selfpipe[2];
static EIF_OBJECT waitpid_input;

static void waitpid_sigh(int n) {
   check_write(1, write(waitpid_selfpipe[1], "", 1));
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
   waitpid_input = obj;
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   static init = 0;
   static struct sigaction act;
   if (!init) {
      init = 1;
      if (pipe(waitpid_selfpipe) == -1) {
         waitpid_selfpipe[0] = -1;
      }
      else {
         fcntl(waitpid_selfpipe[0], F_SETFL, fcntl(waitpid_selfpipe[0], F_GETFL) | O_NONBLOCK);
         fcntl(waitpid_selfpipe[1], F_SETFL, fcntl(waitpid_selfpipe[1], F_GETFL) | O_NONBLOCK);
         memset(&act, 0, sizeof(act));
         act.sa_handler = waitpid_sigh;
         sigaction(SIGCHLD, &act, NULL);
      }
   }
   return waitpid_selfpipe[0];
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   static char dummy[4096];
   char *buffer = (char*)data;
   int pid, status;

   while (read(waitpid_selfpipe[0], dummy, sizeof(dummy)) > 0);

   while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
      oob_info(waitpid_input, pid, status);
   }

   buffer[0] = 0;
   return 1;
}
#else
EIF_INTEGER basic_exec_posix_get_character (EIF_INTEGER fd) {
  return 0;
}

void basic_exec_posix_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
}

void basic_exec_posix_wait_any(se_exec_data_t*data) {
}

void basic_exec_posix_any_finished(se_exec_data_t*data) {
}

EIF_BOOLEAN basic_exec_posix_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  return 0;
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if basic_exec_system == basic_exec_system_none
/* Dummy implementation that always reports an error back to the Eiffel side */

EIF_BOOLEAN basic_exec_execute(se_exec_data_t*data, char*prog, char**args, EIF_BOOLEAN keep_env, char**add_env, int* in_fd, int* out_fd, int* err_fd) {
  return 0;
}

EIF_BOOLEAN basic_exec_is_finished(se_exec_data_t*data) {
  return (EIF_BOOLEAN)0;
}

void basic_exec_wait(se_exec_data_t*data) {
}

EIF_INTEGER basic_exec_get_character (EIF_INTEGER fd) {
  return (EIF_INTEGER)0;
}

void basic_exec_put_character(EIF_INTEGER fd, EIF_CHARACTER c) {
}

void basic_exec_cleanup(se_exec_data_t*data, int status) {
}

void basic_exec_waitpid_init(EIF_OBJECT obj) {
}

EIF_INTEGER basic_exec_waitpid_fd(void) {
   return -1;
}

EIF_INTEGER basic_exec_waitpid_read_buffer(void*data) {
   return -1;
}
#else
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
EIF_BOOLEAN mbi_inc (int32_t *p) {
    if ((++(*p)) == 0) {
      return 1;
    }
    else {
      return 0;
    }
}

EIF_BOOLEAN mbi_add (int32_t a, int32_t b, int32_t *p) {
  (*p) = a + b;
  if (((uint32_t)(*p)) < ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_add_with_inc (int32_t a, int32_t b, int32_t *p) {
  (*p) = a + b + 1;
  if (((uint32_t)(*p)) <= ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_dec (int32_t *p) {
    if (((*p)--) == 0) {
      return 1;
    }
    else {
      return 0;
    }
}

EIF_BOOLEAN mbi_subtract (int32_t a, int32_t b, int32_t *p) {
  (*p) = a - b;
  if (((uint32_t)(*p)) > ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_BOOLEAN mbi_subtract_with_dec (int32_t a, int32_t b, int32_t *p) {
  (*p) = a - b - 1;
  if (((uint32_t)(*p)) >= ((uint32_t)(a))) {
    return 1;
  }
  else {
    return 0;
  }
}

EIF_INTEGER mbi_multiply (int32_t a, int32_t b, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_multiply_with_add (int32_t a, int32_t b, int32_t c, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b)) + ((uint32_t)(c));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_multiply_with_2_add (int32_t a, int32_t b, int32_t c, int32_t d, int32_t *p) {
  uint64_t x;
  x = ((uint64_t)((uint32_t)(a))) * ((uint32_t)(b)) + ((uint32_t)(c)) + ((uint32_t)(d));
  (*p) = (uint32_t)(x);
  return ((uint32_t)(x >> 32));
}

EIF_INTEGER mbi_divide (int32_t a, int32_t b, int32_t d, int32_t *r) {
  uint64_t x;
  x = (((uint64_t)((uint32_t)(a))) << 32) + ((uint32_t)(b));
  (*r) = (uint32_t)(x % ((uint32_t)(d)));
  return ((uint32_t)(x / ((uint32_t)(d))));
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
void sprintf_real_64(EIF_CHARACTER* b, EIF_CHARACTER m, int32_t f, real64_t r) {
  char fmt[32];
  fmt[0]='%';
  fmt[1]='.';
  sprintf(fmt+2, "%d%c", f, m);
  sprintf((char*)b, fmt, r);
}

void sprintf_real_extended(EIF_CHARACTER* b, EIF_CHARACTER m, int32_t f, real_extended_t r) {
  char fmt[32];
  fmt[0]='%';
  fmt[1]='.';
  sprintf(fmt+2, "%dL%c", f, m);
  sprintf((char*)b, fmt, r);
}

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    size_t dummy = fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#ifdef WIN32
#define SIMULATED_MODE
/* The simulated mode for WIN32.
*/
typedef struct _SIMULATED_DIR {
  HANDLE handle;
  WIN32_FIND_DATA data;
  int entry_used;
  char * pattern;
} SIMULATED_DIR;

static SIMULATED_DIR* simulated_opendir(char* path) {
  int len = strlen((char*)path);
  char* pattern = se_malloc(len + 5);
  SIMULATED_DIR* result = se_malloc(sizeof(SIMULATED_DIR));

  pattern = strcpy(pattern,(char*)path);
  if (pattern[len - 1] != '\\') pattern[len++] = '\\';
  pattern[len++] = '*';
  pattern[len++] = '.';
  pattern[len++] = '*';
  pattern[len++] = 0;
  result->handle = FindFirstFile(pattern,&(result->data));
  if (result->handle == INVALID_HANDLE_VALUE) {
    free(pattern);
    free(result);
    return NULL;
  } else {
    result->pattern = pattern;
  }
  result->entry_used = 0;
  return result;
}

static void* simulated_readdir(SIMULATED_DIR* dirstream) {
  if (dirstream->entry_used) {
    if (FindNextFile(dirstream->handle,&(dirstream->data))) {
      dirstream->entry_used = 1;
      return dirstream;
    }
    else {
      return NULL;
    }
  }
  else {
    dirstream->entry_used = 1;
    return dirstream;
  }
}

#define simulated_get_entry_name(x) ((x)->data.cFileName)

static int simulated_closedir(SIMULATED_DIR* dirstream) {
  FindClose(dirstream->handle);
  free(dirstream->pattern);
  free(dirstream);
  return 0;
}


/* GCC(MingW32) doesn't need these prototypes; whereas, LCC needs them. */
char * getcwd(char* buffer, int maxlen);
int chdir(const char* buffer);
int mkdir(const char* directory_path);
int rmdir(const char* directory_path);


#define simulated_getcwd(x, y) getcwd(x, y)
#define simulated_chdir(x) chdir(x)
#define simulated_rmdir(x) rmdir(x)

int simulated_mkdir(const char* directory_path, int perm) {

  mkdir(directory_path);
  return 0;
}

#endif  /* WIN32 */

#ifdef AMIGA
#define SIMULATED_MODE
/* The simulated mode for AmigaOS 2.04+
   Author: Thomas Aglassinger <agi@rieska.oulu.fi>

   Normally this shouldn't be necessary as all compilers include a
   simulation of the Un*x directory API. However, they differ in
   certain details, often resulting into compiler errors. Thus a
   implementation using native AmigaDOS calls seems preferable.

   Note that many of the happenings below have to deal with the
   various idiosyncracies of the "dos.library", which are not all
   documented clearly in the Autodocs. The biggest surprises should
   be reflected in comments. But consider reading chapter 17 of
   Ralph Babel's "Amiga Guru Book" before changing anything.
*/
#include <exec/types.h>
#include <dos/dos.h>
#include <dos/dostags.h>

#include <proto/exec.h>
#include <proto/dos.h>

typedef struct _SIMULATED_DIR {
  struct FileInfoBlock *info;
  BPTR lock;
} SIMULATED_DIR;


/* Release all resources allocated during `simulated_opendir'; also
   works correctly if structure was only partially initialized.
*/
static void free_simulated_dir(SIMULATED_DIR * dir) {
  if (dir != NULL) {
    if (dir->lock != NULL) {
      UnLock(dir->lock);
    }
    if (dir->info != NULL) {
      FreeDosObject(DOS_FIB, dir->info);
    }
    free(dir);
  }
}

static SIMULATED_DIR * simulated_opendir(char *path) {
  BOOL ok = FALSE;
  SIMULATED_DIR *result = se_malloc(sizeof(SIMULATED_DIR));

  if (result != NULL) {
    result->lock = NULL;
    result->info = (struct FileInfoBlock *) AllocDosObject(DOS_FIB, NULL);
    if (result->info != NULL) {
      result->lock = Lock(path, ACCESS_READ);
      if (result->lock != NULL) {
	ok = (Examine(result->lock, result->info) != DOSFALSE);
	if (ok) {
	  /* Ensure we are scanning a directory, not a file */
	  ok = (result->info->fib_DirEntryType >= 0)
	    && (result->info->fib_DirEntryType != ST_SOFTLINK);
	}
      }
    }
  }
  if (!ok) {
    free_simulated_dir(result);
    result = NULL;
  }
  return result;
}

static void * simulated_readdir(SIMULATED_DIR * dirstream) {
  BOOL ok;
  SIMULATED_DIR *result = NULL;

  ok = (ExNext(dirstream->lock, dirstream->info) != DOSFALSE);

  if (ok) {
    result = dirstream;
  }
  return (void *) result;
}

#define simulated_get_entry_name(entry) ((entry)->info->fib_FileName)

static int simulated_closedir(SIMULATED_DIR * dirstream) {
  free_simulated_dir(dirstream);
  return 0;
}


static EIF_POINTER simulated_getcwd(char *buffer, size_t maximum_length) {
     EIF_POINTER result = NULL;
     BPTR lock = Lock("", ACCESS_READ);
     if (lock != NULL) {
       if (NameFromLock(lock, buffer, maximum_length) != DOSFALSE) {
         result = (EIF_POINTER) buffer;
       }
       UnLock(lock);
     }
     return result;
   }

static int simulated_chdir(char *name) {
  int result = -1;
  BPTR lock = Lock(name, ACCESS_READ);
  if (lock != NULL) {
    /* Change the current working directory (CWD) of the task
     */
    BPTR old_lock = CurrentDir(lock);

    /* Attempt to update internal buffer of the process.
       If we are not running in a process, but a plain task, this
       call does not cause any harm.
    */
    /* FIXME: What's the result of SetCurrentDirName() in a plain
       task? If it is FALSE, the below code won't work.
    */
    if (SetCurrentDirName(name)) {
      /* If this was successful, unlock `old_lock' because we
	 are not going to restore it later; this routine is one
	 of the few cases where such behavior is appropriate.
      */
      UnLock(old_lock);
      result = 0;
    }
    else {
      /* If it fails, restore the previous CWD and make the
	 whole routine fail.
      */
      CurrentDir(old_lock);
    }
  }
  return result;
}

static void strip_trailing_slash(char *path, size_t *length,
				 BOOL * stripped) {
  /* Used in `simulated_mkdir' and `simulated_rmdir' to temporarily
     blank out a possible traling slash (/) in the directory path.
     `restore_trailing_slash' puts it back in place afterwards.
  */
  *length = strlen(path);
  if ((*length > 0) && (path[*length - 1] == '/')) {
    *stripped = TRUE;
    path[*length - 1] = '\0';
  } else {
    *stripped = FALSE;
  }
}

static void restore_trailing_slash(char *path, size_t *length,
				   BOOL * stripped) {
  if (*stripped) {
    path[*length - 1] = '/';
  }
}

static int simulated_mkdir(char *directory_path, int permission) {
  BPTR lock;
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;

  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  lock = CreateDir(directory_path);
  if (lock != NULL) {
    UnLock(lock);
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}

static int simulated_rmdir(char *directory_path) {
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;

  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  if (DeleteFile(directory_path)) {
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}
#endif /* AMIGA */

/*--------------------------------------------------------------------
  At his point, either this is a Linux/POSIX platform or some
  SIMULATED_MODE is defined. Unsupported platform should add their own
  SIMULATED_MODE before.
*/

EIF_POINTER directory_open(EIF_POINTER path) {
#ifndef SIMULATED_MODE
  return (opendir(((char*) path)));
#else
  return (simulated_opendir(((char*) path)));
#endif
}

EIF_POINTER directory_read_entry(EIF_POINTER dirstream) {
#ifndef SIMULATED_MODE
  return readdir((DIR*)dirstream);
#else
  return simulated_readdir((SIMULATED_DIR*)dirstream);
#endif
}

EIF_POINTER directory_get_entry_name(EIF_POINTER entry) {
#ifndef SIMULATED_MODE
  return (((struct dirent*)entry)->d_name);
#else
  return simulated_get_entry_name((SIMULATED_DIR*)entry);
#endif
}

EIF_BOOLEAN directory_close(EIF_POINTER dirstream) {
  int status;
#ifndef SIMULATED_MODE
  status = (closedir((DIR*)dirstream) == 0);
#else
  status = (simulated_closedir((SIMULATED_DIR*)dirstream) == 0);
#endif
  return ((EIF_BOOLEAN)(status ? 1 : 0));
}

EIF_POINTER directory_cwd(void) {
  static char* buf = NULL;
#ifdef WIN32
  /* MS Windows requires size to be an int; whereas in non-windows systems,
     it needs to be size_t
  */
  static int size = 0;
#else
  static size_t size = 0;
#endif
  int status;
  if (buf == NULL) {
    size = 256;
    buf = (char*)se_malloc(size);
  }


#ifndef SIMULATED_MODE
  status = (getcwd(buf,size) != NULL);
#else
  status = (simulated_getcwd(buf,size) != NULL);
#endif


  if (status) {
    return buf;
  }
  else {
    free(buf);
    size = size * 2;
    buf = (char*)se_malloc(size);
    return directory_cwd();
  }
}

EIF_BOOLEAN directory_chdir(EIF_POINTER destination) {
  int status;
#ifndef SIMULATED_MODE
  status = (chdir((char*)destination));
#else
  status = simulated_chdir((char*)destination);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN directory_mkdir(EIF_POINTER directory_path){
  int status;
#ifndef SIMULATED_MODE
  status = (mkdir((char*)directory_path,0777));
#else
  status = simulated_mkdir((char*)directory_path,0777);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN directory_rmdir(EIF_POINTER directory_path){
  int status;
#ifndef SIMULATED_MODE
  status = rmdir((char*)directory_path);
#else
  status = simulated_rmdir((char*)directory_path);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/

EIF_INTEGER fstat_st_size(EIF_POINTER path) {

	struct stat buf;
	int test;

	test = stat(path, &buf);
	return (test == 0 ? buf.st_size : -1);

}

EIF_INTEGER_64 fstat_st_mtime(EIF_POINTER path) {

	struct stat buf;
	int test;

	test = stat(path, &buf);
	return (test == 0 ? buf.st_mtime : -1);

}

EIF_BOOLEAN fstat_st_is_file(EIF_POINTER path) {
#if defined S_ISREG
  struct stat buf;

  return stat((const char *)path, &buf)?0:!!S_ISREG(buf.st_mode);
#elif defined WIN32
  EIF_BOOLEAN result;
  HANDLE h=CreateFile((LPCTSTR)path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		      NULL, OPEN_EXISTING, 0, NULL);

  if(INVALID_HANDLE_VALUE == h) {
    return 0;
  }
  result = (GetFileType(h) == FILE_TYPE_DISK)
    && !(GetFileAttributes((LPCTSTR) path) & FILE_ATTRIBUTE_DIRECTORY);
  CloseHandle(h);
  return result;
#else
  printf("fstat_st_is_file (in SmartEiffel/sys/io/c/fstat.c)\nnot yet implemented for this architecture.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

EIF_BOOLEAN fstat_st_is_dir(EIF_POINTER path) {
#if defined S_ISDIR
  struct stat buf;

  return stat((const char *)path, &buf)?0:!!S_ISDIR(buf.st_mode);
#elif defined WIN32
  DWORD attr =GetFileAttributes((LPCTSTR) path);
  return (attr != INVALID_FILE_ATTRIBUTES)  && (attr & FILE_ATTRIBUTE_DIRECTORY);
#else
  printf("fstat_st_is_dir (in SmartEiffel/sys/io/c/fstat.c)\nnot yet implemented for this architecture.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
EIF_INTEGER basic_microsecond_microsecond = 0;
EIF_INTEGER_64 basic_microsecond_time = 0;

void _basic_microsecond_update(void) {
#ifndef WIN32
  struct timeval t;

  gettimeofday (&t, NULL);
  basic_microsecond_time = t.tv_sec;
  basic_microsecond_microsecond = t.tv_usec;
#else
  static DWORD ref_uptime = -1; /* max value as ref_uptime is unsigned */
  static time_t ref_time;
  DWORD uptime;

  /*  uptime = timeGetTime();*/
  uptime = GetTickCount();

  if (uptime < ref_uptime) {
    /* !!! this test manages first call AND 50th day ;-)  */
    ref_uptime = uptime;
    time(&ref_time);
  }

  basic_microsecond_time = ref_time + (uptime - ref_uptime)/1000;
  basic_microsecond_microsecond = ((uptime - ref_uptime) % 1000) * 1000;
#endif
}

int se_cmpT535(T535* o1,T535* o2){
int R=0;
R = R || ((o1->_current_entry) != (o2->_current_entry));
R = R || ((o1->_directory_stream) != (o2->_directory_stream));
return R;
}/*--*/

int se_cmpT346(T346* o1,T346* o2){
int R=0;
R = R || ((o1->_mangling) != (o2->_mangling));
return R;
}/*--*/

int se_cmpT696(T696* o1,T696* o2){
int R=0;
return R;
}/*--*/

int se_cmpT779(T779* o1,T779* o2){
int R=0;
R = R || ((o1->_hashed_string_memory) != (o2->_hashed_string_memory));
R = R || ((o1->_column) != (o2->_column));
R = R || ((o1->_line) != (o2->_line));
return R;
}/*--*/
T1065 M1065=0;
T1069 M1069=0;
T1076 M1076={1076,NULL};
T1077 M1077={1077,NULL};
T1082 M1082=0;

int se_cmpT716(T716* o1,T716* o2){
int R=0;
R = R || ((o1->_time_memory) != (o2->_time_memory));
return R;
}/*--*/

int se_cmpT480(T480* o1,T480* o2){
int R=0;
R = R || se_cmpT716(&(o1->_time), &(o2->_time));
R = R || ((o1->_microsecond) != (o2->_microsecond));
return R;
}/*--*/

int se_cmpT1115(T1115* o1,T1115* o2){
int R=0;
R = R || ((o1->_comparator) != (o2->_comparator));
return R;
}/*--*/
T1115 M1115={(void*)0};
T1119 M1119={1119,NULL};
T1170 M1170={1170,NULL};
T1173 M1173={1173,NULL};
T1176 M1176={1176,NULL};

int se_cmpT343(T343* o1,T343* o2){
int R=0;
R = R || ((o1->_class_name) != (o2->_class_name));
R = R || ((o1->_feature_name) != (o2->_feature_name));
R = R || ((o1->_hash_code) != (o2->_hash_code));
return R;
}/*--*/
T1193 M1193={1193,NULL};
T1196 M1196={1196,NULL};
T1201 M1201={1201,NULL};
T1212 M1212={1212,NULL};
T1216 M1216={1216,NULL};

int se_cmpT319(T319* o1,T319* o2){
int R=0;
R = R || ((o1->_item_memory) != (o2->_item_memory));
R = R || ((o1->_capacity) != (o2->_capacity));
return R;
}/*--*/

int se_cmpT531(T531* o1,T531* o2){
int R=0;
R = R || ((o1->_group) != (o2->_group));
R = R || ((o1->_direct_error) != (o2->_direct_error));
R = R || ((o1->_keep_environment) != (o2->_keep_environment));
R = R || ((o1->_direct_input) != (o2->_direct_input));
R = R || ((o1->_direct_output) != (o2->_direct_output));
return R;
}/*--*/
T1238 M1238={1238,NULL};
T1241 M1241={1241,NULL};
T1246 M1246={1246,NULL};
T1247 M1247={1247,NULL};
T1283 M1283={1283,NULL};
T1285 M1285={1285,NULL};
T1294 M1294={1294,NULL};
T1297 M1297={1297,NULL};
T1300 M1300={1300,NULL};
T1305 M1305={1305,NULL};
T1311 M1311={1311,NULL};
T1314 M1314={1314,NULL};
T1323 M1323={1323,NULL};
T1327 M1327={1327,NULL};
T1330 M1330={1330,NULL};
T1331 M1331={1331,NULL};
T1334 M1334={1334,NULL};
T1339 M1339={1339,NULL};
T1343 M1343={1343,NULL};
T1346 M1346={1346,NULL};
T1349 M1349={1349,NULL};
T1354 M1354={1354,NULL};
T1357 M1357={1357,NULL};
T1362 M1362={1362,NULL};
T1363 M1363={1363,NULL};
T1366 M1366={1366,NULL};
T1371 M1371={1371,NULL};
T1386 M1386={1386,NULL};
T1389 M1389={1389,NULL};
T1395 M1395={1395,NULL};
T1399 M1399={1399,NULL};
T1401 M1401={1401,NULL};
T1406 M1406={1406,NULL};
T1409 M1409={1409,NULL};
T1412 M1412={1412,NULL};
T1423 M1423={1423,NULL};
T1430 M1430={1430,NULL};
T1433 M1433=0;
T1437 M1437={1437,NULL};
T1440 M1440={1440,NULL};
T1446 M1446={1446,NULL};
T1456 M1456={1456,NULL};
T1459 M1459={1459,NULL};
T1464 M1464={1464,NULL};
T1469 M1469={1469,NULL};
T1473 M1473=0;

int se_cmpT756(T756* o1,T756* o2){
int R=0;
R = R || ((o1->_first_error) != (o2->_first_error));
R = R || ((o1->_first_error_character) != (o2->_first_error_character));
R = R || ((o1->_first_error_index) != (o2->_first_error_index));
return R;
}/*--*/
T1501 M1501=0;
T1506 M1506={1506,NULL};
T1509 M1509={1509,NULL};
T1512 M1512={1512,NULL};
T1513 M1513={1513,NULL};
T1516 M1516={1516,NULL};
T1526 M1526={1526,NULL};
T1531 M1531=0;
T1545 M1545=0;
T1553 M1553=0;
T1560 M1560=0;
T1573 M1573={1573,NULL};
T1597 M1597=0;
T1601 M1601={1601,NULL};
T29 M29={(void*)0,0,0};
T291 M291=0;
T112 M112={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,{(void*)0,(void*)0},0,0,0};
T125 M125={(void*)0,(void*)0,(void*)0,0,0};
T1005 M1005=(void*)0;
T103 M103={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0,0,0,0,0,'\0',0,0,0,0,{(void*)0,0,0},0,0,0};
T278 M278={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0,0,0,0,0,0,'\0',{(void*)0,0,0},0,0,0,0,0,0,0};
T116 M116={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
T110 M110={(void*)0,0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
T286 M286={0,0};
T276 M276=(void*)0;
T292 M292=0;
T7 M7={7,(void*)0,0,0,0,0,0};
T1034 M1034={1034,(void*)0,0,0,0};
T288 M288={(void*)0,0,0,0,0,0};
T86 M86={(void*)0,0};
T1035 M1035={(void*)0};
T290 M290=0;
T544 M544=0;
T535 M535={(void*)0,(void*)0};
T78 M78={78};
T1036 M1036={1036,(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T547 M547={547,(void*)0,(void*)0};
T551 M551={551,(void*)0,(void*)0};
T552 M552={552};
T553 M553={553};
T554 M554={554};
T555 M555={555};
T1037 M1037={(void*)0};
T1038 M1038={0};
T101 M101={(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,'\0'};
T546 M546={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T534 M534=0;
T458 M458={458,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0};
T655 M655={655,(void*)0};
T81 M81={81,(void*)0};
T69 M69={69,(void*)0,(void*)0,0,0};
T459 M459={459,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T1039 M1039={(void*)0,0,0,0};
T105 M105={(void*)0,0};
T122 M122={(void*)0,(void*)0,(void*)0,0};
T697 M697={697,(void*)0,(void*)0,0};
T701 M701={701,(void*)0,0,(void*)0,(void*)0,(void*)0,0,0};
T699 M699={699,(void*)0,(void*)0,0,0};
T556 M556={(void*)0,(void*)0,0,{(void*)0,(void*)0},(void*)0,0};
T693 M693={693,(void*)0,(void*)0,0,{(void*)0,(void*)0}};
T346 M346={0};
T431 M431={431,(void*)0,{0},0};
T1040 M1040={1040,(void*)0,0,0,0,0};
T328 M328={(void*)0,(void*)0,(void*)0,0,0,0};
T696 M696={0};
T1041 M1041={(void*)0,0,0,0};
T441 M441={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,'\0'};
T779 M779={(void*)0,0,0};
T578 M578={578,0,{(void*)0},(void*)0};
T611 M611={611,(void*)0};
T612 M612={612,(void*)0};
T613 M613={613,(void*)0};
T614 M614={614,(void*)0};
T615 M615={615,(void*)0};
T627 M627={627};
T628 M628={628};
T629 M629={629,(void*)0,(void*)0};
T631 M631={631,(void*)0};
T632 M632={632,(void*)0};
T636 M636={636,(void*)0,(void*)0,(void*)0,0};
T637 M637={637,(void*)0,(void*)0,(void*)0,(void*)0};
T638 M638={638,(void*)0,(void*)0,(void*)0,(void*)0};
T639 M639={639,(void*)0,(void*)0,(void*)0};
T640 M640={640,0};
T641 M641={641,0};
T642 M642={642};
T644 M644={644};
T645 M645={645};
T643 M643={643};
T646 M646={646};
T647 M647={647,0};
T648 M648={648,(void*)0,(void*)0,0};
T1042 M1042={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1043 M1043={(void*)0,0,0,0};
T377 M377={377,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0,0,0,0,0};
T97 M97={97,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0,0};
T95 M95={(void*)0,(void*)0,(void*)0,0,0,{0},0};
T281 M281={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T89 M89={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T543 M543={(void*)0,(void*)0,0,{{0},0},0,0,0};
T1045 M1045={(void*)0,0,0,0,0};
T336 M336={(void*)0,(void*)0,0,0};
T109 M109=(void*)0;
T107 M107={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0};
T115 M115=(void*)0;
T124 M124=(void*)0;
T123 M123={0};
T126 M126=(void*)0;
T91 M91={(void*)0,(void*)0,{0},(void*)0,(void*)0,(void*)0,(void*)0,0,{0},0};
T446 M446={446,(void*)0,(void*)0,0};
T1047 M1047={(void*)0,0,0,0,0};
T1048 M1048={(void*)0,(void*)0,0,0,0,0};
T1049 M1049={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1050 M1050={(void*)0,0,0,0};
T301 M301={301,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0};
T1051 M1051={(void*)0,(void*)0,0,0,0,0};
T119 M119={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0};
T285 M285={(void*)0,{0},0};
T435 M435={435,(void*)0,(void*)0,0};
T1054 M1054={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T577 M577=0;
T1055 M1055={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1056 M1056={(void*)0,(void*)0,0,0,0,0};
T1057 M1057={0};
T717 M717={717,0};
T718 M718={718,(void*)0,(void*)0,(void*)0,0};
T719 M719={719,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T313 M313={313,(void*)0,(void*)0,(void*)0,(void*)0};
T541 M541={(void*)0,(void*)0};
T1060 M1060={(void*)0,0,0,0};
T1061 M1061={(void*)0,(void*)0,0,0,0,0};
T1062 M1062={(void*)0,0,0,0};
T710 M710={710,(void*)0};
T1063 M1063={(void*)0,0,0,0,0,0};
T709 M709={(void*)0,(void*)0,0};
T1064 M1064={(void*)0,0,0,0};
T335 M335={(void*)0,(void*)0,(void*)0};
T1068 M1068={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T796 M796=0;
T793 M793={793,(void*)0};
T795 M795={795,(void*)0,(void*)0,0};
T1070 M1070={(void*)0,0,0,0};
T1071 M1071={(void*)0};
T59 M59={0,(void*)0,{(void*)0,0}};
T794 M794={794,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1072 M1072={(void*)0,(void*)0,(void*)0};
T1078 M1078={(void*)0,(void*)0,(void*)0};
T1079 M1079={(void*)0,(void*)0,0,0,0,0};
T80 M80=0;
T1080 M1080={(void*)0,0,0,0};
T1084 M1084={(void*)0,0,0,0};
T106 M106={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0,0,0,{(void*)0,0,0},0,0,'\0'};
T1087 M1087={(void*)0,0,0,0};
T772 M772={772,{(void*)0,(void*)0},(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T812 M812={812,{(void*)0,(void*)0},(void*)0,(void*)0,(void*)0,(void*)0,0};
T1089 M1089={(void*)0,(void*)0,0,0,0,0};
T1091 M1091={(void*)0,(void*)0,0,0,0,0};
T1093 M1093={(void*)0,(void*)0,0,0,0,0};
T1095 M1095={(void*)0,(void*)0,0,0,0,0};
T774 M774={(void*)0,(void*)0};
T480 M480={{0},0};
T1098 M1098={1098,(void*)0,0,0,0,0,0};
T362 M362={362,(void*)0,(void*)0};
T1099 M1099={1099,(void*)0,0,0,0,0,0};
T401 M401={401,(void*)0,(void*)0};
T1100 M1100={(void*)0,0,0,0};
T456 M456={(void*)0,(void*)0,0,0,{0},(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T427 M427={(void*)0,(void*)0,(void*)0};
T389 M389={389,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,{0},0};
T433 M433={{0},(void*)0,0};
T434 M434={(void*)0,(void*)0,0};
T494 M494={494,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0};
T503 M503={503,(void*)0,{0},0};
T505 M505={505,{0},(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T120 M120={0,0};
T506 M506={506,{0},(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T452 M452={452,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T417 M417={417,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T469 M469={469,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T390 M390={390,(void*)0,(void*)0,0};
T444 M444={444,(void*)0,(void*)0,0};
T416 M416={416,(void*)0,(void*)0,(void*)0,0,0};
T442 M442={442,(void*)0,(void*)0,(void*)0,0,0};
T412 M412={412,(void*)0,(void*)0,(void*)0,(void*)0,0};
T445 M445={445,(void*)0,(void*)0,0};
T443 M443={443,(void*)0,(void*)0,(void*)0,0,0};
T449 M449={449,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T447 M447={447,(void*)0,(void*)0,(void*)0,0};
T450 M450={450,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T453 M453={453,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T277 M277={(void*)0,(void*)0,0,0};
T475 M475={475,(void*)0};
T477 M477={477,(void*)0,(void*)0,(void*)0,(void*)0,0};
T478 M478={478,(void*)0,(void*)0,(void*)0};
T479 M479={479,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T432 M432={(void*)0,(void*)0,{0},(void*)0,(void*)0};
T1101 M1101={(void*)0,0,0,0};
T284 M284={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T486 M486={(void*)0,(void*)0};
T1102 M1102={(void*)0,0,0,0};
T527 M527={527,(void*)0,{0}};
T496 M496={496,(void*)0,(void*)0,(void*)0,(void*)0,0};
T410 M410={410,(void*)0,(void*)0,(void*)0};
T482 M482={482,(void*)0,{0},(void*)0,0};
T380 M380={380,(void*)0,(void*)0,0,{0},0};
T483 M483={483,(void*)0,(void*)0,(void*)0,{0}};
T484 M484={484,(void*)0,{0},(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,{0}};
T347 M347={(void*)0,(void*)0};
T356 M356={356,(void*)0,(void*)0,(void*)0,(void*)0,0};
T359 M359={359,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T361 M361={361,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T350 M350={350,(void*)0,(void*)0,(void*)0,(void*)0,0};
T354 M354={354,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T355 M355={355,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T498 M498={498,(void*)0,(void*)0,(void*)0,(void*)0,0};
T499 M499={499,(void*)0,(void*)0,(void*)0,(void*)0,0};
T500 M500={500,(void*)0,(void*)0,(void*)0,(void*)0,0};
T488 M488={488,(void*)0,(void*)0,{0}};
T394 M394={394,{0}};
T463 M463={463,{0}};
T470 M470={470,{0},(void*)0,'\0'};
T489 M489={489,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T524 M524={524,(void*)0,(void*)0,{0}};
T525 M525={525,(void*)0,(void*)0,(void*)0,0,{0}};
T1103 M1103={(void*)0,0,0,0};
T1104 M1104={1104,(void*)0,0,0,0,0};
T460 M460={460,(void*)0,(void*)0,(void*)0,(void*)0,0,{0}};
T461 M461={461,(void*)0};
T1105 M1105={1105,(void*)0,0,0,0,0};
T400 M400={400,(void*)0};
T1106 M1106={(void*)0,0,0,0,0};
T675 M675={675,(void*)0,(void*)0,0,0};
T1107 M1107={(void*)0,0,0,0};
T429 M429={429,(void*)0,(void*)0,(void*)0,(void*)0};
T1108 M1108={1108,(void*)0,0,0,0,0};
T397 M397={397,(void*)0,(void*)0,(void*)0,(void*)0,0,{0},0,0};
T455 M455={(void*)0,(void*)0};
T526 M526={526,(void*)0,(void*)0,0};
T1109 M1109={(void*)0,0,0,0};
T485 M485={485,(void*)0,(void*)0,{0},0};
T421 M421={421,(void*)0,(void*)0,{0},0};
T407 M407={407,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T1110 M1110={(void*)0,0,0,0};
T365 M365={365,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T378 M378={378,(void*)0,{0}};
T370 M370={370,(void*)0,(void*)0,(void*)0,(void*)0,{0},(void*)0,(void*)0,{0},0};
T487 M487={487,(void*)0,(void*)0,(void*)0,(void*)0,{0},(void*)0,(void*)0,{0},0};
T437 M437={437,(void*)0,(void*)0,{0},0};
T473 M473={473,(void*)0,(void*)0,(void*)0,(void*)0};
T474 M474={474,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T372 M372={372,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0}};
T413 M413={413,(void*)0,{0},(void*)0,(void*)0,0,0};
T471 M471={471,(void*)0,(void*)0,0,0,{0}};
T502 M502={502,(void*)0,(void*)0,(void*)0,(void*)0,{0},0};
T492 M492={492,(void*)0,{0}};
T375 M375={375,(void*)0,(void*)0,0};
T403 M403={403,(void*)0,(void*)0,0,0};
T472 M472={472,(void*)0,(void*)0,0};
T466 M466={466,{0},0};
T404 M404={404,(void*)0,0};
T671 M671={671,{0},(void*)0,(void*)0,0,0};
T491 M491={491,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,{0}};
T464 M464={464,(void*)0,(void*)0};
T405 M405={405,{0}};
T501 M501={501,(void*)0,{0},(void*)0};
T523 M523={523,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T522 M522={522,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T518 M518={518,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T519 M519={519,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T520 M520={520,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T521 M521={521,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T517 M517={517,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T383 M383={383,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T406 M406={406,(void*)0,(void*)0,{0},0};
T513 M513={513,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T514 M514={514,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T515 M515={515,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T516 M516={516,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T411 M411={411,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T512 M512={512,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T509 M509={509,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T510 M510={510,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T511 M511={511,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T508 M508={508,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T465 M465={465,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T507 M507={507,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T493 M493={(void*)0,(void*)0};
T287 M287={(void*)0,(void*)0,{0}};
T468 M468={(void*)0,(void*)0,(void*)0,{0}};
T467 M467={(void*)0,(void*)0};
T1113 M1113={(void*)0,0,0,0,0};
T430 M430={(void*)0,(void*)0,(void*)0,{0}};
T440 M440={(void*)0,(void*)0,(void*)0,(void*)0};
T773 M773={(void*)0,(void*)0,(void*)0};
T462 M462={{0},(void*)0};
T366 M366={366,(void*)0,(void*)0,0,{0},0,0};
T419 M419={419,(void*)0,(void*)0,(void*)0,(void*)0};
T402 M402={402,(void*)0,(void*)0,(void*)0,0,{0},0,0};
T1114 M1114={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T415 M415={415,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T1118 M1118={(void*)0,0,0,0};
T1120 M1120={(void*)0,(void*)0,(void*)0};
T1123 M1123={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1124 M1124={(void*)0,0,0,0,0};
T1126 M1126={(void*)0,0,0,0};
T692 M692={692,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T436 M436={436,(void*)0,(void*)0,{0},0};
T1127 M1127={(void*)0,0,0,0};
T1132 M1132={(void*)0,0,0,0};
T1133 M1133={(void*)0,(void*)0,0,0,0,0};
T457 M457={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1134 M1134={(void*)0,(void*)0,0,0,0,0};
T439 M439={(void*)0};
T454 M454={(void*)0};
T1135 M1135={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1136 M1136={(void*)0,(void*)0,0,0,0,0};
T1139 M1139={(void*)0,0,0,0};
T1140 M1140={(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1143 M1143={(void*)0,(void*)0,0,0,0,0};
T1144 M1144={(void*)0,0,0,0};
T1145 M1145={(void*)0,0,0,0};
T1146 M1146={(void*)0,0,0,0};
T1148 M1148={(void*)0,0,0,0};
T1149 M1149={(void*)0,0,0,0};
T1150 M1150={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T532 M532={(void*)0,(void*)0,0};
T1152 M1152={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1156 M1156={(void*)0,(void*)0,0,0,0,0};
T1157 M1157={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1158 M1158={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1159 M1159={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1160 M1160={(void*)0,0,0,0};
T536 M536={536,(void*)0,(void*)0,(void*)0};
T1161 M1161={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1162 M1162={(void*)0,0,0,0};
T571 M571={(void*)0,(void*)0};
T1164 M1164={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1165 M1165={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1166 M1166={(void*)0,0,0,0};
T409 M409={409,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T1168 M1168={(void*)0,(void*)0,(void*)0};
T1171 M1171={(void*)0,(void*)0,(void*)0};
T1174 M1174={(void*)0,0,0,0};
T1177 M1177={(void*)0,(void*)0,(void*)0};
T1179 M1179={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1180 M1180={(void*)0,0,0,0};
T650 M650={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0};
T1181 M1181={(void*)0,(void*)0,0,0,0,0};
T1182 M1182={(void*)0,0,0,0,0,0};
T1183 M1183={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T343 M343={(void*)0,(void*)0,0};
T1184 M1184={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1189 M1189={(void*)0,(void*)0,0,0,0,0};
T1190 M1190={(void*)0,0,0,0,0};
T1191 M1191={(void*)0,0,0,0,0};
T1192 M1192={(void*)0,0,0,0};
T1194 M1194={(void*)0,(void*)0,(void*)0};
T1197 M1197={(void*)0,(void*)0,0};
T1200 M1200={(void*)0,(void*)0};
T1204 M1204={(void*)0,(void*)0,0,0,0,0};
T831 M831={831,(void*)0,(void*)0,(void*)0};
T832 M832=(void*)0;
T833 M833={833,(void*)0,(void*)0,(void*)0};
T835 M835={835,(void*)0};
T837 M837={837,(void*)0,(void*)0,(void*)0};
T838 M838={838};
T839 M839={839};
T840 M840={840,0};
T1205 M1205={(void*)0,0,0,0};
T834 M834={834,(void*)0,0,0};
T841 M841={841,(void*)0,(void*)0};
T1206 M1206={(void*)0,0,0,0};
T1207 M1207={(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0};
T1211 M1211={(void*)0,(void*)0,0};
T1215 M1215={(void*)0,0,0,0};
T573 M573={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1217 M1217={(void*)0,(void*)0,(void*)0};
T1219 M1219={(void*)0};
T1221 M1221={(void*)0,0,0,0,0,0};
T1222 M1222={(void*)0,0,0,0};
T319 M319={(void*)0,0};
T736 M736=0;
T1224 M1224={(void*)0,(void*)0,0,0,0,0};
T1227 M1227={(void*)0,0,0,0,0,0};
T1231 M1231={(void*)0,(void*)0,(void*)0,0,0,0,0};
T1232 M1232={1232,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T531 M531={(void*)0,0,0,0,0};
T1234 M1234={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T798 M798={798,(void*)0};
T1236 M1236={(void*)0,0,0,0};
T1237 M1237={(void*)0,(void*)0,0,0,0,0};
T1239 M1239={(void*)0,(void*)0,(void*)0};
T1242 M1242={(void*)0,(void*)0,(void*)0};
T1245 M1245={(void*)0,(void*)0};
T1248 M1248={(void*)0,(void*)0,0};
T1250 M1250={(void*)0,(void*)0,0,0,0,0};
T716 M716={0};
T690 M690={690,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T687 M687={687,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T574 M574={574,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T691 M691={691,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1254 M1254={1254,(void*)0,0,0,0};
T1256 M1256={1256,(void*)0,0,0,0};
T684 M684={684,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T677 M677={677,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T680 M680={680,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T682 M682={682,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T689 M689={689,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T683 M683={683,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T679 M679={679,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T681 M681={681,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T688 M688={688,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T426 M426={(void*)0};
T1258 M1258={(void*)0,0,0,0,0};
T1259 M1259={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1260 M1260={(void*)0,(void*)0,0,0,0,0};
T703 M703={(void*)0};
T1267 M1267={(void*)0,0,0,0};
T1271 M1271={(void*)0,0,0,0};
T752 M752={752,(void*)0,(void*)0,(void*)0,(void*)0};
T1273 M1273={(void*)0,0,0,0};
T388 M388={388,(void*)0,(void*)0};
T664 M664={664,(void*)0};
T666 M666={666,(void*)0,(void*)0,(void*)0};
T1274 M1274={(void*)0,0,0,0};
T1275 M1275={(void*)0,0,0,0};
T667 M667={667,(void*)0,(void*)0,0,0,{0}};
T1276 M1276={(void*)0,0,0,0};
T1277 M1277={(void*)0,0,0,0};
T1278 M1278={(void*)0,(void*)0,0,0,0,0};
T1282 M1282={(void*)0,(void*)0};
T1286 M1286={(void*)0,(void*)0,(void*)0};
T1293 M1293={(void*)0,(void*)0,0};
T1296 M1296={(void*)0,(void*)0,(void*)0};
T1298 M1298={(void*)0,0,0,0};
T1299 M1299={(void*)0,0,0,0};
T1301 M1301={(void*)0,(void*)0,(void*)0};
T1304 M1304={(void*)0,(void*)0,0};
T1309 M1309={(void*)0,(void*)0,(void*)0,(void*)0};
T1312 M1312={(void*)0,(void*)0,0,0,0,0};
T1315 M1315={(void*)0,(void*)0,(void*)0};
T1321 M1321={(void*)0,(void*)0,(void*)0};
T1326 M1326={(void*)0,(void*)0};
T1329 M1329={(void*)0,(void*)0};
T1332 M1332={(void*)0,(void*)0,(void*)0};
T1335 M1335={(void*)0,(void*)0,(void*)0};
T1338 M1338={(void*)0,(void*)0};
T1341 M1341={(void*)0,(void*)0,(void*)0};
T1345 M1345={(void*)0,(void*)0};
T1347 M1347={(void*)0,(void*)0,(void*)0};
T422 M422={422,(void*)0,0};
T753 M753={(void*)0,(void*)0,{0},0};
T1353 M1353={(void*)0,(void*)0,(void*)0};
T1358 M1358={(void*)0,(void*)0,(void*)0};
T1361 M1361={(void*)0,{(void*)0,(void*)0,0}};
T1364 M1364={(void*)0,{(void*)0,(void*)0,0},(void*)0};
T1367 M1367={(void*)0,(void*)0,(void*)0};
T1372 M1372={(void*)0,(void*)0,(void*)0};
T867 M867={(void*)0};
T1374 M1374={(void*)0,0,0,0};
T1377 M1377={(void*)0,0,0,0};
T1378 M1378={(void*)0,(void*)0,(void*)0,0,0};
T1379 M1379={1379,(void*)0,0,0,0};
T1380 M1380={(void*)0,(void*)0,0,0,0,0};
T364 M364={364,0,{0},(void*)0,(void*)0};
T1383 M1383={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1387 M1387={(void*)0,(void*)0,(void*)0};
T1392 M1392={(void*)0,(void*)0,(void*)0};
T1393 M1393={1393,(void*)0,0,0};
T790 M790={790,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0};
T791 M791={791,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0,0,0};
T792 M792={792,(void*)0,0,0,0};
T787 M787={787,(void*)0,(void*)0};
T788 M788={788,(void*)0,(void*)0,0};
T789 M789={789};
T1397 M1397={(void*)0,(void*)0,(void*)0};
T1402 M1402={(void*)0,(void*)0,(void*)0};
T1405 M1405={(void*)0,(void*)0,(void*)0};
T1407 M1407={(void*)0,0,0,0};
T1410 M1410={(void*)0,(void*)0,(void*)0};
T1413 M1413={(void*)0,(void*)0,(void*)0};
T1415 M1415={(void*)0,0,0,0};
T1421 M1421={(void*)0,(void*)0,0,0,0,0};
T1424 M1424={(void*)0,(void*)0,(void*)0};
T1429 M1429={(void*)0,(void*)0,(void*)0};
T857 M857={(void*)0,(void*)0,(void*)0,0,0,0,0};
T1436 M1436={(void*)0,(void*)0,(void*)0};
T1439 M1439={(void*)0,(void*)0};
T1441 M1441={(void*)0,0,0,0,0,0};
T1442 M1442={(void*)0,(void*)0,0,0,0,0};
T1443 M1443={(void*)0,(void*)0,0,0,0,0};
T1447 M1447={(void*)0,(void*)0,(void*)0};
T345 M345={0};
T1449 M1449={(void*)0,(void*)0,(void*)0,0,0,0,0,0,0};
T1451 M1451={(void*)0,(void*)0,(void*)0,(void*)0,0,0,0};
T1452 M1452={0,'\0'};
T1453 M1453={(void*)0,0,0,0};
T1454 M1454={(void*)0,(void*)0,0};
T1457 M1457={(void*)0,(void*)0,0};
T1460 M1460={(void*)0,0,0,0};
T1461 M1461={(void*)0,(void*)0,0,0,0,0};
T1465 M1465={(void*)0,(void*)0};
T1466 M1466={(void*)0,(void*)0,0,0,0,0};
T1470 M1470={(void*)0,(void*)0,(void*)0};
T61 M61={(void*)0,(void*)0,0};
T800 M800={800,(void*)0,(void*)0,'\0',0};
T756 M756={(void*)0,0,0};
T673 M673={673,0,{0},'\0'};
T1477 M1477={(void*)0,(void*)0,0,0,0,0};
T1478 M1478={(void*)0,(void*)0};
T1479 M1479={(void*)0,(void*)0,0,0,0,0};
T1480 M1480={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1482 M1482={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T1485 M1485={(void*)0,(void*)0,(void*)0,0,0,0,0,0};
T658 M658={658,(void*)0,(void*)0};
T662 M662={662,(void*)0,(void*)0,(void*)0};
T661 M661={661,(void*)0,(void*)0};
T570 M570={570,(void*)0,(void*)0,{0}};
T663 M663={663,(void*)0};
T660 M660={660,{0},(void*)0,(void*)0,(void*)0,0};
T672 M672={672,(void*)0,0};
T656 M656={656,(void*)0,(void*)0,0,{0},0};
T657 M657={657,(void*)0,{0}};
T674 M674={674,(void*)0,0,0,{0},0};
T337 M337=0;
T1486 M1486={(void*)0,0,0,0};
T1487 M1487={(void*)0,(void*)0,(void*)0,0,0,0,{0},0};
T533 M533={533,(void*)0,(void*)0,(void*)0};
T668 M668={668,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T568 M568={568,(void*)0,(void*)0,{0},0};
T676 M676={676,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1488 M1488={(void*)0};
T1489 M1489={(void*)0,0,0,0};
T1490 M1490={(void*)0,0,0,0};
T315 M315=0;
T1491 M1491={(void*)0,(void*)0,0,0,0,0};
T1492 M1492={(void*)0,0,0,0};
T1498 M1498={(void*)0,0,0,0};
T538 M538={(void*)0};
T127 M127={127,0,0};
T754 M754={754,(void*)0,(void*)0,0};
T759 M759={759,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T121 M121={0};
T1500 M1500={(void*)0,0,0,0,0};
T423 M423={423,(void*)0,(void*)0,(void*)0,(void*)0,0};
T420 M420={420,(void*)0,{0},(void*)0,(void*)0,0,0};
T374 M374={374,{0},(void*)0,'\0'};
T809 M809={809,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T653 M653={653,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T807 M807={807,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T760 M760={760,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T659 M659={659,{0},(void*)0,(void*)0,(void*)0};
T542 M542={542,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0,0};
T808 M808={808,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T652 M652={652,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,0};
T1502 M1502={(void*)0,0,0,0};
T859 M859={859,(void*)0,(void*)0,0,0};
T861 M861={861,(void*)0,(void*)0,0,0,0,0,'\0',0,'\0'};
T862 M862={862,(void*)0,(void*)0,(void*)0,0};
T863 M863={863,(void*)0,(void*)0,(void*)0,0,0,0,'\0',0,'\0'};
T1503 M1503={1503,(void*)0,0,0,0};
T1505 M1505={(void*)0,(void*)0,(void*)0};
T1507 M1507={(void*)0,(void*)0,(void*)0};
T1511 M1511={(void*)0,(void*)0};
T1514 M1514={(void*)0,(void*)0,(void*)0};
T1517 M1517={(void*)0,(void*)0,(void*)0};
T1519 M1519={(void*)0,0,0,0};
T1520 M1520={0,{0},(void*)0,(void*)0,0};
T1521 M1521={1521,(void*)0,0,0,0};
T665 M665={665,(void*)0,{0}};
T727 M727={727,0};
T1525 M1525={(void*)0,(void*)0};
T1006 M1006={(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,{0},0,0,{(void*)0,(void*)0},(void*)0,(void*)0,0};
T567 M567={(void*)0,(void*)0,0,0};
T649 M649={0};
T1534 M1534={(void*)0,0,0,0};
T1537 M1537={(void*)0,0,0,0,0};
T561 M561={561,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T562 M562={562,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T563 M563={563,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T564 M564={564,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T565 M565={565,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T566 M566={566,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
T1552 M1552={1552,(void*)0,0,0};
T814 M814={814,0,0};
T1554 M1554={(void*)0,0,0,0,0};
T1562 M1562={(void*)0,0,0,0};
T830 M830={830,0};
T1565 M1565={(void*)0,(void*)0,0,0,0,0};
T1566 M1566={(void*)0,0,0,0};
T732 M732={(void*)0,0,0,0,0};
T1567 M1567={(void*)0,0,0,0};
T1571 M1571={(void*)0,(void*)0,(void*)0};
T729 M729={729,(void*)0,0,0};
T1594 M1594={(void*)0,0,0,0};
T805 M805={805,(void*)0};
T1595 M1595={(void*)0,(void*)0,0,0,0,0};
T803 M803={803,0};
T1598 M1598={(void*)0,0,0,0};
T1600 M1600={(void*)0,(void*)0,0};
/*Aliased storage area or unicode storage.*/
char*s353_1195446850A=". (See the next error report for details.)";
char*s112_0A="";
char*s116_1418906530A="void se_msi";
char*s33_424424A="low_16";
char*s637_25969530A=",a1ptr->_";
char*s120_9A="\011""";
char*s110_10A="\n";
char*s33_424430A="low_32";
char*s375_1114345928A="Void cannot be assigned to an expanded entity.";
char*s650_1983193131A="To fix this ambiguous Precursor call you have to remove direct repeated inheritance. You may thus consider to add a new class which inherit ";
char*s30_199827552A=": level is already set to ";
char*s116_1564992795A="int se_general_trace_switch";
char*s637_59375621A="Class NATIVE_ARRAY has been tampered with. Unknown function: ";
char*s116_1772404517A="&local_profile,";
char*s103_1078639380A="Expression expected after \'implies\'.";
char*s430_772854717A="Feature `manifest_put\' must be a procedure.";
char*s103_1138390195A="Prefix operator name expected.";
char*s116_523400916A="Precomputed once function";
char*s103_393689A="bottom";
char*s472_218994080A="Replacing assign to \173""";
char*s116_12331A="NULL";
char*s615_5794275A="=(u->CL_";
char*s719_1880914324A="gc_agent*gcu=(gc_agent*)u;\nif (gcu->header.flag==FSOH_UNMARKED)\173""\ngcu->header.flag=FSOH_MARKED;\n";
char*s103_34A="\"";
char*s719_1607908341A="Adding SmartEiffel Garbage Collector.\n";
char*s33_38A="&";
char*s116_40A="(";
char*s116_41A=")";
char*s630_7233618A="INT8_MIN";
char*s33_42A="*";
char*s33_43A="+";
char*s116_44A=",";
char*s116_36951A="(T0*)";
char*s33_45A="-";
char*s459_46A=".";
char*s33_47A="/";
char*s628_48A="0";
char*s125_1071750288A="SmallEiffel";
char*s29_1889925553A="compile_to_c";
char*s419_532898088A=" See also the next message for more information.";
char*s615_1664036235A="set_dump_stack_top(caller);/*unlink*/\nreturn C;\n";
char*s477_58A=":";
char*s615_1023028228A=";\nu->afp=afp_";
char*s638_59A=";";
char*s120_60A="\n\n";
char*s33_60A="<";
char*s33_61A="=";
char*s637_2017590A="floor((";
char*s833_1752899740A="GC_REGISTER_FINALIZER_NO_ORDER(R, bdw_finalizeT";
char*s33_62A=">";
char*s30_63A="\?";
char*s794_1883030297A=" (discarded)\n";
char*s33_64A="@";
char*s106_1684808173A="Invalid empty file";
char*s640_1216329562A="if (!strcmp(attr,\"";
char*s103_67A="C";
char*s103_1268871407A="Bad inline agent definition (\"do...end\" routine body expected).";
char*s637_219498506A="Unknown \"$";
char*s30_1202957293A=": missing file path name after -output_error_warning_on flag.\n";
char*s34_212160365A="require_check";
char*s632_80037A="else ";
char*s33_12376A="REAL";
char*s119_325166540A="Can\'t join these two concrete features. What\'s called a concrete feature here is a feature which is not deferred. You may consider to undefine one feature or to add a redefine.";
char*s116_77A="M";
char*s431_77A="\011"" ";
char*s812_79A="\011""\"";
char*s116_1206795525A="c_plus_plus";
char*s116_441192857A="initialize_eiffel_runtime(argc,argv);\n";
char*s615_82A="R";
char*s543_251231528A="generating";
char*s116_1645835456A=");\nimax=argc";
char*s640_84A="T";
char*s116_2189840A="se_ums(";
char*s114_301485A="Cygwin";
char*s116_392938270A="init_profile(agent_profile+";
char*s615_585895143A="(se_dump_stack*caller,";
char*s630_91A="[";
char*s116_93A="]";
char*s33_94A="^";
char*s33_251231540A="generation";
char*s103_916596A=" items.";
char*s812_2008215484A=" (not in a loadpath)";
char*s719_152877053A="(/*malloc*/(T";
char*s112_99A="c";
char*s837_101A="e";
char*s278_376816512A="external_header_path";
char*s112_273430505A="return 0;\n";
char*s30_104A="h";
char*s632_105A="i";
char*s112_109A="m";
char*s441_178490A=" class";
char*s33_112335826A="signal_number";
char*s116_114A="r";
char*s97_772983982A="Problem with undefine of \"";
char*s567_1399364920A="/*auto-unlock tmp";
char*s30_118A="v";
char*s484_123A="\173""";
char*s33_124A="\174""";
char*s719_125A="\175""";
char*s33_126A="\176""";
char*s116_273430530A="return 1;\n";
char*s116_391886489A="])(FILE*,void*)";
char*s544_876265439A="/lang/eiffel/.liberty-eiffel";
char*s717_6284A="(((T";
char*s371_1485085274A="..... unique buffer 1 .....";
char*s403_1089483711A=" must not be expanded. (";
char*s637_579867211A="(T6)(C==a1)";
char*s103_629850238A="An expression has a result value. This is not an instruction.";
char*s116_1629400044A="#define SE_BOOST 1\n";
char*s33_80109A="fifth";
char*s632_252339A="=NULL;";
char*s119_612971904A="\n\nSecond \"insert\" path (from parent to child):\n   ";
char*s441_202915491A="Same class name appears twice.";
char*s401_446205995A="Same local name appears twice in this \"local\" variable list.";
char*s632_6305A=")&&(";
char*s103_280897875A=" for the left-hand side of an assignment.";
char*s409_1324593410A="Overflow of infix \"*\" with INTEGER_32 operands. (";
char*s34_1473988901A="c_linker_options";
char*s573_168A="\011""\173""";
char*s429_145102259A="(The type of this expression is actually ";
char*s103_339436953A="Compiler limitation: separate classes are not supported. SCOOP attempt implementation currently abandoned (December 2006).";
char*s112_539873441A="\" (default mode) selected.\n";
char*s459_1876110531A="Value out of INTEGER_32 range.";
char*s103_470853074A="The base type is no longer used. Class PROCEDURE now has only one formal argument. Just remove this unused type mark.";
char*s572_6330A="();\n";
char*s112_180A="\"\n";
char*s33_961210799A="allocated_bytes";
char*s116_116813823A="default:\nerror0(\"Internal error in agent launcher (";
char*s116_30942A=") */ ";
char*s116_37095A="(T6)(";
char*s833_61699A="NULL,";
char*s34_436911A="rescue";
char*s632_1341914655A="/*count*/=((";
char*s104_1604340919A="Bad clients list.";
char*s278_1341859296A="Keyword \"system\" expected. Invalid ACE file.";
char*s103_194A=" \"";
char*s650_42706587A="The type ";
char*s110_195A="%\n";
char*s116_475921520A="memcpy(sorted_agent_switch_profile, agent_switch_profile, ";
char*s614_619030689A="fprintf(file,\"\\n\\t]\");\n";
char*s288_200A=" (";
char*s632_117385886A="/*[inspect";
char*s719_786221024A="GC support: generating switch functions.\n";
char*s116_6355A=" R;\n";
char*s718_1409981632A=")REVEAL_POINTER(";
char*s116_204A="\"\"";
char*s630_205A="!(";
char*s833_85966583A="(o);\nGC_enable();\n";
char*s109_580488532A=" nodes and ";
char*s837_212314278A="->first_object)));\n";
char*s103_639285944A="Missing \')\' to end `c_inline_c\' call.";
char*s421_1085830094A="ifthen (empty)";
char*s110_215A=")\n";
char*s389_905138318A="Invalid unicode string at index ";
char*s278_216A="\".";
char*s337_2070057757A="Loop_invariant";
char*s33_217A="#*";
char*s477_218A=" :";
char*s33_218A="#+";
char*s637_160146A="))))))";
char*s116_993675817A="if(fd.assertion_flag)\173""\nfd.assertion_flag=0;\n";
char*s33_220A="#-";
char*s103_873294598A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous manifest STRING as target).";
char*s33_54688766A="se_atexit";
char*s637_4638080A="(T6)((!(";
char*s630_226A="!=";
char*s103_1922692108A="Replaced misspelled \"True\".";
char*s116_227A=" C";
char*s278_1302880443A="Error in the \"";
char*s337_1306325004A="Void_call_target";
char*s116_585944489A="Define C main function.\n";
char*s629_230A="&(";
char*s427_230A=",\n";
char*s632_236A="\')";
char*s613_237A=" M";
char*s116_240A="((";
char*s112_240A=".\n";
char*s754_241A="()";
char*s103_241A="\'.";
char*s544_242A="* ";
char*s630_36137368A="INT64_MIN";
char*s833_6395A=" R=(";
char*s611_244A=" T";
char*s116_245A=")(";
char*s717_246A="))";
char*s615_247A=" W";
char*s33_1682815431A="manifest_make";
char*s116_249A="),";
char*s116_251A="*)";
char*s97_251A=").";
char*s288_252A=", ";
char*s615_254A=",\"";
char*s637_255A="+(";
char*s579_255A=" _";
char*s110_542094038A="Expanded Target Procedure Call";
char*s609_257A=" a";
char*s116_257A="*/";
char*s629_258A=",&";
char*s615_259A=" c";
char*s632_259A=",\'";
char*s717_6411A="(-1)";
char*s110_262A=". ";
char*s34_10703002A="no_check";
char*s116_1312728230A="print_profile(profile_file, &runinit_profile);\n";
char*s632_264A=");";
char*s637_265A="-(";
char*s637_1665734122A="strlen(se_argv[";
char*s630_184795A="(T0*)(";
char*s615_436987A="resexp";
char*s450_1428348580A="This type mark is not a TUPLE type mark.";
char*s288_43325A=": and";
char*s120_270A="--";
char*s409_190952A=" with ";
char*s429_271A=".)";
char*s116_272A="&R";
char*s637_6425A="))/(";
char*s630_1097836905A="/*$*/(void*)&";
char*s104_116346440A="Unknown special character.";
char*s116_1017947719A="manifest_initialize(";
char*s555_276A="..";
char*s116_277A=" u";
char*s116_277C="*C";
char*s116_277B="/*";
char*s812_277A="./";
char*s380_278A=".0";
char*s110_1255776138A="Overflow while computing \"";
char*s110_1131876546A="Starting collect";
char*s116_282A="0*";
char*s33_282A="//";
char*s116_284B="0,";
char*s116_284A="(T";
char*s615_287A="&a";
char*s837_1854022405A=")))return;\nif(((char*)p)>((char*)(b+(c->count_minus_one))))return;\nif(((char*)p)<((char*)b))return;\nif(((((char*)p)-((char*)b))%sizeof(*p))==0)\173""\nif(p->header.flag==FSOH_UNMARKED)\173""\n";
char*s532_287A="->";
char*s532_80251A="empty";
char*s643_293A="10";
char*s643_294A="11";
char*s484_594795843A=", each bunch must have exactly ";
char*s643_295A="12";
char*s637_296A=")[";
char*s33_296A="/=";
char*s112_297A=".C";
char*s632_244699380A="default:;\n";
char*s112_298A="-I";
char*s441_299A=".E";
char*s288_300A=":\n";
char*s112_301A="-L";
char*s1006_302A=".H";
char*s116_6455A="));\n";
char*s484_305A=";\n";
char*s116_1754886761A="se_agent*);\n";
char*s116_317A=",a";
char*s33_406284A="fourth";
char*s33_42134669A="Precursor";
char*s430_325449730A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_put\').";
char*s116_1238750212A="get_profiler_started(&master_profile);\n";
char*s103_1088075316A="Cannot use a formal generic argument as a valid parent.";
char*s284_90592250A="Cannot undefine ";
char*s125_322A=": ";
char*s719_35343969A="FSOC_SIZE";
char*s790_324A="-c";
char*s637_325A="._";
char*s112_326A="-e";
char*s615_327A="*u";
char*s637_197159A=";\n*((T";
char*s112_327A=".a";
char*s362_327A="; ";
char*s32_329A=".c";
char*s579_1710309A="Tid id;";
char*s32_331A=".e";
char*s116_10739979A="mspalloc";
char*s615_815493762A="\n/*agent launcher*/";
char*s112_333A="-l";
char*s112_334A="/c";
char*s32_334A=".h";
char*s119_107193812A="It is useless to mark as \"redefine\" this deferred feature.";
char*s35_336A="-o";
char*s573_142931125A=" has no creation list. You must use the default creation method (named `default_create\' in class ANY, or just omit the method name).";
char*s112_340A="-s";
char*s112_341A=".o";
char*s544_342A="> ";
char*s630_345A="=(";
char*s33_1501191A="Current";
char*s478_348A="::";
char*s34_437070A="prefix";
char*s754_351A=":=";
char*s116_1243560324A="se_frame_descriptor fd=\173""\"<global-once-";
char*s121_1568216255A="internal_exception_handler(Void_call_target)";
char*s110_36611104A="You seem to have too classes named ";
char*s33_1578334651A="open_arguments";
char*s669_301503927A="Incompatible actual argument for agent call. Cannot pass `Void\' into formal argument of type ";
char*s527_360A="<<";
char*s380_360A="0x";
char*s33_361A="<=";
char*s414_1136256141A="Cannot use such a strange create expression for type ";
char*s477_2140868216A="Value expected";
char*s718_8033571A="]!=NULL)";
char*s640_754574290A=";\nif (_r==NULL) \173""R=&_r; *id=0;\175"" else \173""\nswitch(_r->id) \173""\n";
char*s632_366A="==";
char*s614_775396A="(&((*o)";
char*s104_1700247488A="Unexpected character in hexadecimal ascii code.";
char*s33_371A=">=";
char*s527_372A=">>";
char*s403_376A="\?=";
char*s837_377A="=H";
char*s837_166455A="(*o);\n";
char*s116_379A="C,";
char*s33_548214405A="REAL_GENERAL";
char*s470_898426A=".......";
char*s112_1561265653A="No default configuration file for Liberty Eiffel was found.\nPlease just re-run the Liberty Eiffel installation program.\nOn Unix-like system, just \"cd\" to the Liberty Eiffel directory and\nthen, type \"make\".\nOn Windows-like system, re-run the \"install.exe\" of Liberty Eiffel.\nNote: if you prefer, you can still rely on the \"";
char*s116_175857472A="manifest_make(";
char*s116_382A="=M";
char*s572_6534A="*((T";
char*s614_197373672A="fprintf(file,\"";
char*s112_62728285A="The configuration file seems invalid. Correct the above errors first.";
char*s33_10377126A="is_empty";
char*s630_1639500234A="NULL/*_POINTER*/";
char*s116_396A="C=";
char*s124_397A="BC";
char*s719_6550A=") \173""\n";
char*s459_1962655329A=" has an argument list";
char*s114_402A="CC";
char*s615_2054563574A="se_frame_descriptor fd=\173""\"create expression wrapper\",0,0,\"\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s406_1442631340A=". (See explaination below.)";
char*s34_9909665A="creation";
char*s116_6559A="*/\nT";
char*s837_1748680500A="=n->header.next;\n\175""\nelse if(";
char*s103_1011636926A="Void cannot be used after unary \"-\" operator.";
char*s615_1484470448A="rc.top_of_ds=&ds;\n";
char*s719_411A="CL";
char*s615_1212159A="==a2->c";
char*s103_1733505988A="Unexpected \"reference\" keyword.";
char*s116_1601653158A="se_local_profile_t local_profile, *parent_profile;\n";
char*s637_419A="=r";
char*s362_892535123A="Same argument name appears twice in this formal argument list.";
char*s116_1957408550A="invariant of ";
char*s116_781060556A="Internal stacks size used: ";
char*s116_726728775A="=2;\175""\nelse\173""\n";
char*s430_1604599495A="Feature `manifest_semicolon_check\' must be a constant (INTEGER or BOOLEAN).";
char*s414_343527626A=" Actually, just replace this create expression with ";
char*s104_74239A="]foo\"";
char*s719_6580A="*);\n";
char*s387_1808265259A="This is not an CHARACTER expression.";
char*s609_86545A="open_";
char*s441_205111678A="\" in cluster \"";
char*s104_696478167A="Bad (empty\?) ascii code.";
char*s459_1604408825A="Must not use such a non-static type mark for a constant-attribute definition.";
char*s281_38905513A="This is not a constant feature.";
char*s650_1447552176A=" the conforming parent(s) for ";
char*s33_1603529235A="to_natural_8";
char*s837_526175446A="*)(&(c->first_object)));\nif((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store";
char*s33_80416A="first";
char*s116_1793244543A="fclose(profile_file);\175""\n";
char*s638_1395477828A="/*se_fault*/\173""int*i=0;*i=0;\175""\n";
char*s833_733445699A="void bdw_finalizeT";
char*s33_878996813A="TYPED_INTERNALS";
char*s110_408537579A=". The number of dots\ngives the number of \"when\" clauses:\n";
char*s116_10666295A="\175""/*--*/\n";
char*s116_339308075A="/*The generic se_agent0 definition:*/\nstruct _se_agent0\173""\nTid id;\nTid creation_mold_id;\nvoid(*afp)(";
char*s409_1297676933A=" would give ";
char*s837_6614A="((gc";
char*s337_1489034545A="Routine_failure";
char*s1006_1935504882A="Strange dependency: location <";
char*s116_471A="R=";
char*s643_471A="T3";
char*s669_1084920002A="Bad number of actual arguments for agent call. (The agent you are trying to call has ";
char*s643_474A="T6";
char*s431_1240817101A="Bad comment to end a class.";
char*s643_476A="T8";
char*s112_1192507148A="Unknown os \"";
char*s33_1639475718A="UNICODE_STRING";
char*s638_529853775A=");\n\175""\nelse\173""\n";
char*s666_1937147216A="Cannot assign newly created ";
char*s110_1459577427A="Void target Function Call";
char*s441_397816412A="   include ";
char*s112_1721407046A="Math=IEEE Parameters=Both Code=Far";
char*s478_1577658176A="... unique local buffer ...";
char*s615_283801480A="void*afp;\n";
char*s650_1655357614A="Keyword \"require\" replaced with \"require else\" because there is an inherited require assertion.";
char*s800_498A="X:";
char*s34_2073386A="inspect";
char*s103_2117894368A="Void is not a valid BOOLEAN expression (just after keyword \"until\" of a loop).";
char*s572_6655A=")->_";
char*s30_613587359A="Flag or argument \"";
char*s630_506A="])";
char*s572_215791A="(void)";
char*s632_1181502A="==0 \174""\174"" ";
char*s833_1544707291A="void*bdw_na_assignT";
char*s103_1524784203A="Exponent part of a real value expected.";
char*s1006_1942892277A="Including header ";
char*s116_365905049A="init_profile(&root_profile, \"<root>\");\n";
char*s718_1970645590A="#define BDW_GC 1\n#define GC_I_HIDE_POINTERS 1\n#include <gc/gc.h>\n#define malloc(s) GC_MALLOC(s)\n#define calloc(n,s) GC_MALLOC_IGNORE_OFF_PAGE((s)*(n))\n#define realloc(p,s) GC_REALLOC((p),(s))\n#define free(p) p=NULL\n";
char*s473_334725631A="Error in variant part of loop definition.";
char*s794_1000694404A="].\nOriginal definition ";
char*s718_722650754A="se_malloc(sizeof(void*))";
char*s717_6671A="*/))";
char*s344_25373399A="Incompatible signatures. (One has a result type and not the other.)";
char*s116_526A="]=";
char*s718_1477636806A="#ifndef GC_DEBUG\n#define GC_DEBUG \"";
char*s632_1084495643A="\175""\175""/*manifest INSPECT]*/\n";
char*s409_889865702A=" which is out of INTEGER_8 range.)";
char*s33_534A="a1";
char*s637_535A="a2";
char*s112_6687A=" To ";
char*s499_2057854492A=" is 9223372036854775808 which is out of INTEGER_64 range.";
char*s116_932172292A="]=root_profile;\n";
char*s103_955638361A="Bad use of predefined type ARRAY.";
char*s103_9897510A="built_in";
char*s34_10315778A="indexing";
char*s33_552A="\\\\";
char*s477_1490203324A="Unexpected keys found\n";
char*s103_2030568676A=" is not writable (reached through closure). Cannot use ";
char*s116_1901889757A="/*\nANSI C code generated by ";
char*s123_557A="_R";
char*s837_25822456A=";\ngc_free";
char*s701_559A="_T";
char*s103_1471861047A="Syntax error inside \"local\" variable list definition. Encountered keyword \"";
char*s632_550508910A="assertion_depth=1;\nfree_exception_frames();\n";
char*s34_1532343833A="cpp_compiler_path";
char*s794_68224A="The \'";
char*s375_1744510279A=" Cannot assign ";
char*s288_22396357A=" columns ";
char*s630_570A="\\n";
char*s126_570A="__";
char*s632_1832703325A="/*UNUSED_EXPRESSION:*/(void)(";
char*s34_54418471A="reference";
char*s103_1228072329A="Such a constant cannot be used in \"when\" part of an inspect statement.";
char*s116_1988895671A="start_profile(parent_profile, &local_profile);\n";
char*s116_273430980A="return C;\n";
char*s579_166654A="* o1,T";
char*s278_1476966395A="More than one class in the system is named ";
char*s116_1290234339A="int se_argc";
char*s103_1961160815A="The \"separate\" keyword is still a reserved keyword in case of a new implementation attempt...";
char*s406_1037594318A=" (Error occurs while checking the code in ";
char*s103_751585121A="Error while reading hexadecimal number.";
char*s34_2233396A="runtime";
char*s717_273418685A="se_calloc(";
char*s30_1724187394A=": missing output name after -o flag.\n";
char*s34_48390502A="all_check";
char*s107_589A="bc";
char*s643_591A="_t";
char*s112_2077353217A="\" (alternate mode) selected.\n";
char*s278_2132072515A="\" ACE file.\n";
char*s35_594A="cc";
char*s837_596A="o)";
char*s33_9713026A="as_32_ne";
char*s33_36193081A="INTEGER_8";
char*s519_2080244194A="Division by zero.";
char*s34_600A="as";
char*s104_1317175740A="Too long hexadecimal sequence for a single unicode value.";
char*s110_1463938603A="Polymorphic Proceduire Call";
char*s114_603A="cl";
char*s837_604A="o1";
char*s837_6755A="++;\n";
char*s103_1207921682A="Manifest real value not compatible with this type.";
char*s110_801894175A="Unknown prefix operator \"";
char*s434_1773450779A="A formal generic argument must not use the name of some existing class.";
char*s103_437331A="result";
char*s414_1260488135A=" and you are done.";
char*s103_611A="do";
char*s33_548331507A="NATIVE_ARRAY_INTERNALS";
char*s112_614A="gc";
char*s719_185146A="(T0*o)";
char*s116_1419097826A="),c,(int16_t*)s,sc,lsv,lsi);return (T0*)";
char*s110_427937988A="Total Number of Merged \"when\" clauses (cumulated): ";
char*s112_179868158A="Unknown system name in file\n\"";
char*s637_475042348A="internal_exception_number";
char*s441_620A="es";
char*s615_68284A="a1->c";
char*s632_6775A="))\173""\n";
char*s615_5395051A="(void**)";
char*s116_625A="\173""\n";
char*s116_5395053A="(void*)0";
char*s34_627A="if";
char*s632_693716559A="error1(\"Invalid ::= assignment (inserted type).\",";
char*s125_354654986A="Environment variable $\173""";
char*s33_51915068A="is_normal";
char*s119_1661847054A="\" come from the same original feature via multiple \"inherit\" paths.\nBelow, you get the feature evolution step by step. Note that in the end (type ";
char*s104_85511833A="Right hand side expression of ::= assignment expected here.";
char*s630_1367878466A="se_manifest";
char*s116_811016135A=">\",0,0,\"\",1\175"";\n";
char*s116_635A="\175""\n";
char*s33_636A="io";
char*s100_1861287086A="not_computed";
char*s479_449661A="struct";
char*s34_640A="is";
char*s632_2251910A="switch(";
char*s627_5395074A="(void)0;";
char*s110_1174466439A="during inlining of dynamic dispatch";
char*s116_651A="p[";
char*s34_1690381566A="invariant_check";
char*s718_12955A="]);\n";
char*s719_19622345A="(&(u->CA_";
char*s33_1744399653A="type_attribute_generating_type";
char*s637_6810A="))\174""(";
char*s107_660A="ms";
char*s278_661A="no";
char*s109_97543221A="Recompute RUN_TIME_SETs..";
char*s627_4570857A="/*:RF1*/";
char*s632_1175100011A=" /* has_empty */ if (";
char*s33_669A="or";
char*s637_670A="\176""(";
char*s34_670A="os";
char*s573_671A="\175"".";
char*s30_525197655A="\" specified for the -is_output_error_warning_on flag.\n";
char*s615_43730A="*se_i";
char*s408_925886099A=" (this is not BOOLEAN).";
char*s637_351281A="a1ptr=";
char*s114_674A="sc";
char*s103_1135641353A=" is not writable.";
char*s837_6830A=" e;\n";
char*s650_378711602A="Keyword \"ensure then\" replaced with \"ensure\" (There is no inherited ensure assertion here).";
char*s112_1087245292A="#: config file corrupted!";
char*s91_685A="ti";
char*s112_686A="rt";
char*s112_689A="vc";
char*s116_1713607783A="if (expression != NULL) error2(expression,/*unknown-position*/0);\n";
char*s615_6845A="&CA_";
char*s719_1824264277A="void once_function_mark(void)";
char*s572_905827712A="manifest_string_mark";
char*s835_699A="\173""T";
char*s612_619166512A=";\n#define M";
char*s615_228498053A="se_dump_stack ds=\173""NULL,NULL,0,NULL,NULL,NULL\175"";\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s284_875060418A="You cannot inherit \"";
char*s637_1375807179A="Unknown WEAK_REFERENCE built-in: ";
char*s33_1115958189A="open_argument_indices";
char*s33_1206543966A="object_attribute";
char*s627_4570907A="/*:RF3*/";
char*s29_1325879523A=": missing loadpath file path after -loadpath flag.\n";
char*s103_316863332A="No parent after \"inherit\" keyword (an empty list is not allowed here).";
char*s650_1197649626A="Precursor call is allowed only when the enclosing routine is redefined.";
char*s543_1899804731A="adapting features";
char*s615_10937200A="return (";
char*s116_6877A=");/*";
char*s114_13028A="UNIX";
char*s33_80694A="floor";
char*s579_1290234494A="int se_cmpT";
char*s491_1767084619A="Please consider writing an explicit open argument list for your agent creation.";
char*s106_1385667261A=".\nIts retained value will be the last read.\n";
char*s33_849712179A="print_run_time_stack";
char*s627_4570932A="/*:RF4*/";
char*s287_740A="\173""\175""";
char*s544_1114764925A="\\LIBERTY.CFG";
char*s632_744A="\174""\174""";
char*s833_854811368A="o->bdw_generation=g;\175""\n";
char*s114_1772235A="Windows";
char*s615_750A="\175""\175""";
char*s632_1261705A="=NULL;\n";
char*s696_1601130656A="Duplicate directory";
char*s110_1460051321A="Unsafe covariant redefinition of argument number ";
char*s278_527202963A="The \"debug\" assertion level is deprecated. Please use \"all\" and debug statements.";
char*s116_1195084695A="ds.fd=&root;\nds.current=((void*)(&";
char*s409_613384625A="Overflow of infix \"+\" with INTEGER_32 operands. (Adding ";
char*s567_2007779419A="/*reusing tmp";
char*s112_643573734A="If Liberty Eiffel is correctly installed, you should find\nmore information in the file \"";
char*s484_589832448A="Must not use the \";\" (semicolon) separator for manifest ";
char*s719_40031469A="RSOC_SIZE";
char*s837_10937240A="return((";
char*s627_4570957A="/*:RF5*/";
char*s638_68406039A="\n#if BYTE_ORDER == BIG_ENDIAN\n";
char*s543_1280946519A="collecting features";
char*s837_5161461A="(fsoc*c)";
char*s632_644847010A=";\nbreak;\n\175""\n";
char*s33_567319806A="to_integer_16";
char*s632_1124563501A="))\173""switch(((T0*)";
char*s117_6926A=",...";
char*s114_51699930A="lcc-win32";
char*s403_7867907A="Invalid ";
char*s33_1597390874A="Character_bits";
char*s33_567319812A="to_integer_32";
char*s116_7720290A="Function";
char*s627_4570982A="/*:RF6*/";
char*s121_899910547A="se_print_run_time_stack(),exit(1)";
char*s837_2092663259A="goto begin;\n";
char*s637_6946A=",0))";
char*s116_1994813154A="];\nse_profile_t sorted_all_profile[";
char*s33_567319829A="to_integer_64";
char*s430_282823780A="Invalid creation procedure. A \"once\" procedure is not allowed as a creation procedure.";
char*s637_1824713404A="deep_memcmp(";
char*s33_9676326A="capacity";
char*s614_926003101A="if(*o==NULL)\173""\n   fprintf(file, \"void\");\n   return;\175""\n";
char*s615_80771A="u->R=";
char*s278_1091711046A="\" (and there may be more). Search started from ";
char*s637_6965A=")<<(";
char*s627_4571007A="/*:RF7*/";
char*s611_1710532409A="/*BUG:NA@runtime!*/";
char*s33_1671553525A="WEAK_REFERENCE";
char*s116_1981256377A="Assignment test (\"\?:=\") function";
char*s112_10937305A="return;\n";
char*s615_173055A="*)u2;\n";
char*s479_55156846A="signature";
char*s543_958892525A="Total time spent ";
char*s103_52979396A="loop body";
char*s506_1083118122A="Type mark \"like <argument>\" must not reference another \"like <argument>\" type mark. (One level of indirection is always possible and always better ;-)";
char*s632_400650A="else\173""\n";
char*s632_86950A="rawci";
char*s34_400652A="elseif";
char*s637_427390771A=")==FP_SUBNORMAL";
char*s278_1707020207A="The \"use\" clause is not yet implemented.";
char*s627_4571032A="/*:RF8*/";
char*s615_345908476A="ds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\nset_dump_stack_top(&ds);/*link*/\n";
char*s637_6995A=")==(";
char*s97_142319A="\" in \"";
char*s34_11251026A="undefine";
char*s430_170383550A="Manifest generic creation not yet implemented for expanded types (";
char*s640_7006A=" _r=";
char*s112_373286592A="\".\nCurrently handled system names:\n";
char*s103_1275558331A="A routine must be ended with \"end\".";
char*s627_4571057A="/*:RF9*/";
char*s103_888875725A="Missing \";\" added.";
char*s837_1648235130A="->header.state_type=FSO_USED_CHUNK;\nn=";
char*s33_1498845794A="NATIVE_ARRAY[CHARACTER]";
char*s477_1331532446A="module_name";
char*s406_1769582063A=" Expression ";
char*s637_7025A=")>>(";
char*s833_719514099A="bdw_na_assignT";
char*s837_1288623074A=")(r+1));\n\175""\nreturn((T";
char*s494_672729595A="Invalid generic constraint cycle.";
char*s839_730579755A="=(void*)0;\n";
char*s278_1130154866A="Bad Environment variable.\n(Closing \"\175""\" not found.)";
char*s409_923532A=" minus ";
char*s1006_7037A=" at ";
char*s110_1814748872A="\" from ACE file. (Parsing \"";
char*s344_345225764A="Different arguments types.";
char*s632_1291760099A=";\nbreak;\n\175""\nbreak;\n";
char*s33_80854A="flush";
char*s33_13194A="TYPE";
char*s281_1820580025A="Probably infinite or too long generic derivation of this type mark (see next warnings to find the cause of the problem... and good luck).";
char*s637_1689502217A="Bad prototype for C struture get external.";
char*s627_185428A="/*RF1:";
char*s630_686612424A="(/*OUTCL:LOCAL*/*";
char*s34_10193105A="expanded";
char*s32_831708366A="Feature `copy\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s125_1972884945A="The old \"SmallEiffel\" variable is not valid anymore. Please use Liberty Eiffel.\n";
char*s33_10377643A="is_equal";
char*s627_185438A="/*RF3:";
char*s112_703496930A="\"[General] sys\" key is missing.";
char*s839_1295032451A=".store_chunk=NULL;\n";
char*s110_604558099A="Loaded Classe";
char*s627_185443A="/*RF4:";
char*s669_501491947A=" is expanded. (The whole type of the agent your are trying to launch is ";
char*s627_185448A="/*RF5:";
char*s110_1786429697A=" cannot be a root class since it is a generic class.";
char*s409_1552156565A=" which is out of range 0..15 because target type is INTEGER_16.";
char*s627_185453A="/*RF6:";
char*s34_1975394A="cluster";
char*s33_1594034A="ROUTINE";
char*s103_75996531A="Discarded empty convert clause";
char*s33_2246041A="storage";
char*s627_185458A="/*RF7:";
char*s837_1012357115A="(unsigned int size)";
char*s116_1065055A="*s=M7;\n";
char*s110_1497652563A="\': anonymous feature not found";
char*s110_24235872A="2011-2014";
char*s718_323156020A="int bdw_delayed_finalize";
char*s627_185463A="/*RF8:";
char*s277_51017327A="Bad external signature (missing \")\" delimiter.";
char*s116_934A="\"\n\"";
char*s377_1809213019A="ref-status: ";
char*s459_1284372793A="A function cannot be an assigner.";
char*s471_1204053035A="c_inline_c(";
char*s34_1839765037A="Cyclic anchored definition.";
char*s627_185468A="/*RF9:";
char*s112_830570470A="-cc specified more than once; last is used.\n";
char*s579_481249030A=") != (o2->_";
char*s752_495673125A=") is not smaller than upper bound (";
char*s119_1752297822A="A frozen feature must not be undefined. What is frozen _is_ frozen.";
char*s116_1642367158A=", sizeof(se_profile_t), profile_comparator);\n";
char*s116_273431355A="return R;\n";
char*s278_708319A="\" and \"";
char*s125_7106A=" day";
char*s718_15009395A="\"\n#endif\n";
char*s837_915251302A=";\nif((o!=NULL)";
char*s433_171706123A=" which is the generic constraint.";
char*s112_50863580A="exit(0);\n";
char*s471_1204053060A="c_inline_h(";
char*s544_1747846A="\\SE.CFG";
char*s632_7118A="-1)\?";
char*s33_1607595572A="to_character";
char*s650_557767498A=" in order to use it as a unique parent qualifier.";
char*s34_1992063831A="ensure_check";
char*s505_1962243783A="Bad anchor. Unknown feature name.";
char*s719_207160501A="#ifndef FIXED_STACK_BOTTOM\nint valid_stack_bottom = stack_bottom != NULL;\n#endif\n";
char*s640_124454155A=";\n*exp=1;\n";
char*s484_1496963692A="Wrong usage of \";\" (semicolon) separator in manifest notation. Each bunch-size must be a multiple of ";
char*s632_54714119A="sedb(&ds,";
char*s637_87090A="pow((";
char*s116_1586448448A="uint16_t lsv";
char*s837_77282146A=".space_used+=size;\n";
char*s637_185515A="(T6)((";
char*s450_540477054A=", this type mark is not a TUPLE. (This is actually ";
char*s86_1761241425A="Adding Cecil file: ";
char*s120_992A="   ";
char*s116_1500500537A=" live TYPEs:\n";
char*s103_1587734026A="Void cannot be the left-hand side of the binary \"\\\\\" operator.";
char*s833_903312259A="return wr->o;\n";
char*s833_167080A="*/));\n";
char*s837_160930A="))-1)\175""";
char*s103_1703575813A="Bad character constant. Closing \"\'\" expected.";
char*s640_160937A="(*C)->";
char*s278_89867121A="\" section.";
char*s409_205616643A="Overflow of infix \"-\" with INTEGER_32 operands. (";
char*s116_514187710A="#ifdef __cplusplus\nextern \"C\" \173""\n#endif\n";
char*s454_1615634978A="Unable to find the default creation procedure for expanded type ";
char*s103_2080029331A="Slash \"/\" character expected after decimal value in CHARACTER constant.";
char*s103_266191698A="The keyword \'creation\' is now replaced by \'create\'. Please update your code.";
char*s112_851047233A="\nThe type of your operating system was automatically  computed. Please verify.\n";
char*s116_1346694814A="if (sedb_status != SEDB_EXIT_MODE) ";
char*s110_1365578385A="Starting simplify";
char*s103_1090616383A="Unable to find a class definition in \"";
char*s116_308580A="NULL;\n";
char*s680_247541875A="copy index";
char*s459_1436450217A="A string constant cannot be an assigner.";
char*s110_713806135A=" (For this call, the target ";
char*s353_646901709A="Call on a Void target.";
char*s103_1581435442A="Bad external clause (manifest string expected).";
char*s469_743946038A=" is expanded. The generic argument of WEAK_REFERENCE must not be expanded. (It does not makes sense to do so.)";
char*s837_1413869902A="gc_update_weak_ref_item_polymorph((Tgc*)&(o1->object));\n";
char*s694_1043A=" (+";
char*s459_69279758A="A unique constant cannot be an assigner.";
char*s112_17494489A="compile_to_c: \"";
char*s695_1047A=" + ";
char*s637_397220332A="memcpy(&R,C,sizeof(R";
char*s288_7207A=" in ";
char*s34_10876026A="redefine";
char*s116_437780A="se_msi";
char*s837_1473891377A="\173""\173""FSOC_SIZE,FSO_STORE_CHUNK,\n(void(*)(mch*,void*))";
char*s103_1380562254A="Boolean expression expected (until).";
char*s650_1092806174A=" The final export list is ";
char*s417_1719402393A=".............................................";
char*s109_23085765A=".(done).\n";
char*s719_1102979933A="gc_is_off=0;\n";
char*s837_1927410765A="=old_gc_free;\nc->next=fsocfl;\nfsocfl=c;\nc->header.state_type=FSO_FREE_CHUNK;\n\175""\n\175""\n";
char*s837_1574324912A="dead=0;\175""\nelse\173""\n";
char*s35_87180A="relax";
char*s97_439490016A="\" does not belong to a creation clause of ";
char*s110_385188989A="Before collect cycle";
char*s103_1934613587A="Simple identifier expected just after a dot. Nothing else but a simple feature name is meaningful just after a dot.";
char*s116_965818786A="No support found in directory sys/runtime for \"";
char*s630_7220A=")CA_";
char*s482_68732A="This ";
char*s278_208962844A="*** Looking for ";
char*s103_2091587115A="Void is not a valid target (i.e. just after a dot).";
char*s116_4620481A="(T0*)(g[";
char*s487_7232A=" is ";
char*s632_7235A=");\175""\n";
char*s459_1305581590A="An attribute cannot be an assigner.";
char*s409_156630152A=" which is out of INTEGER_64 range.)";
char*s30_1090A="\".\n";
char*s719_1102979958A="gc_is_off=1;\n";
char*s544_1027113524A="USERPROFILE";
char*s632_1348915394A="DynamicDispatch";
char*s116_1901755A="ac_req(";
char*s630_580292587A="/*SFN*/(C->";
char*s465_99702656A=" Feature `";
char*s110_1839715989A="The feature called has no formal argument while the actual argument list has ";
char*s611_302501127A="typedef union _se_agent se_agent;\ntypedef struct _se_agent0 se_agent0;\n";
char*s459_1630520481A="The type of this constant feature should be REAL.";
char*s116_197932A=";\n*C=M";
char*s812_1101A="\").";
char*s468_1554555636A="Cannot change exportation status of ";
char*s103_879341913A="No more \"reference\" keyword allowed. The obsolete \"reference FOO\" notation is no longer accepted. Just use the REFERENCE class instead.";
char*s409_1277330071A="Violated assertion (target value is ";
char*s116_893005A="\"\\n\"),\n";
char*s837_2136427942A="............ unique local buffer ...................";
char*s484_1034900711A="Cannot pass Void into formal argument which is of type ";
char*s441_1112A="\". ";
char*s103_1617443474A="No sign allowed before an hexadecimal constant value.";
char*s116_588411932A="void se_atexit(void)";
char*s459_1051699101A="A constant cannot be an assigner.";
char*s527_1330923746A="\175"". See the next error message.";
char*s97_1121A="\".)";
char*s371_327012886A=" but there is _no_ when clause selected. (Also note that there is no else part for this inspect statment, hence this error message.)";
char*s103_1717397235A="Corresponding closing \')\' expected here.";
char*s103_1003875089A="No more \"expanded\" keyword allowed here. The obsolete \"expanded FOO\" notation is no longer accepted.";
char*s35_2141685A="no_main";
char*s630_1446625A="INT8_C(";
char*s353_1759986771A="This feature is only exported to ";
char*s116_4620546A="(T0*)(t[";
char*s116_1055242101A="/*[INIT CLOSURE LOCALS*/\n";
char*s837_7296A=" na=";
char*s541_927498134A="run-time-set-count: ";
char*s719_10322525A="\175""\nelse\173""\n";
char*s419_1099750743A="Feature found is not writable (i.e. not an attribute).";
char*s286_1133285999A="Cannot find the default class ";
char*s833_1524126691A=" bdw_mallocT";
char*s33_1157A="#//";
char*s336_1981041429A="CODE_ACCUMULATOR code_stack";
char*s116_273443870A="se_atexit(";
char*s609_7317A=" of ";
char*s116_1350760769A="assertion_depth++;\n\175""\n";
char*s110_1535001676A="Details regarding Monomorphic calls:\n";
char*s719_419443A="na_env";
char*s473_1867518592A="Expression of the loop variant must be of INTEGER type. (The actual ";
char*s112_1964046235A="\"[General] short\" key is missing.";
char*s409_905382A=" gives ";
char*s116_1142598643A="local_profile.profile=inv_profile+";
char*s833_1858599648A="void*bdw_weakref_new(int n)";
char*s278_305465997A="Quoted identifiers are deprecated. Please remove quotes here.";
char*s33_1944903A="ceiling";
char*s686_235492225A="Attributes cannot have a rescue compound.";
char*s33_55040341A="put_16_be";
char*s544_28418819A="/etc/serc";
char*s34_10648581A="obsolete";
char*s388_1552710436A="Internal error inside WHEN_ITEM_1 (compiler error).";
char*s103_1819737650A="Must use exactly 4 hexadecimal digits for INTEGER_16.";
char*s110_1206593669A="Monomorphic Procedure/Function Call";
char*s17_1210A=".\n\n";
char*s35_2246326A="verbose";
char*s112_1215A="\'.\n";
char*s278_767646015A="\" while the second is in the cluster \"";
char*s281_1641573945A="The following path was misdetected as an inheritance cycle";
char*s116_1319581398A="se_dump_stack ds=\173""NULL,NULL,0,NULL,NULL,NULL,0\175"";\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s33_9529116A="add_last";
char*s630_11300605A="unsigned";
char*s637_52075585A=" cannot be converted to a memory address.)";
char*s125_1430004157A=" used in file \"";
char*s637_1671074150A="((uint32_t)(";
char*s409_1324951230A="Overflow of infix \"+\" with INTEGER_64 operands. (Adding ";
char*s32_1897129554A="Feature `is_equal\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s288_188916891A=" . The validation context is used to compute all anchored type marks.)";
char*s103_155929078A="Incorrect TUPLE (type expected).";
char*s110_646243744A="Symplify interrupted (infinite inlining ... or infinite recursion detected.).";
char*s630_1232A="\'*/";
char*s33_276937706A="slice_copy";
char*s833_1180476551A=",NULL,NULL,NULL);\n";
char*s33_1235A="#<<";
char*s103_911265735A="Missing the \"is\" keyword\?";
char*s630_1240A="(((";
char*s837_407207A="fsoc H";
char*s430_1700082283A="Invalid creation procedure. A function is not allowed as a creation procedure.";
char*s637_520388145A="((int64_t)(";
char*s33_55040391A="put_16_le";
char*s719_1246A="())";
char*s637_704592146A="Invalid usage of feature `to_pointer\' of class ANY. (The target which is of type ";
char*s33_1247A="#>>";
char*s637_837784A=");\n*((T";
char*s615_7400A="*CL_";
char*s468_1377394679A=" does not have feature ";
char*s103_445001496A="This is not a feature name, but a class name.";
char*s387_1088174660A="(The corresponding feature definition is in the next error message.)";
char*s719_52555395A="->header.flag)==FSOH_UNMARKED)\173""\n";
char*s30_513843490A=") is used.\n";
char*s33_55040401A="put_16_ne";
char*s116_499425548A="NULL/*Unused Target*/";
char*s288_4479182A=" column ";
char*s615_1485929081A="int (*eq)(se_agent*,se_agent*);\n";
char*s718_1208340604A="bdw_mallocT";
char*s33_2067995A="implies";
char*s637_870841390A="<<16)\174""((uint32_t)";
char*s116_1919660703A="];\nse_profile_t sorted_agent_switch_profile[";
char*s110_1265A=").\n";
char*s116_1271B=")))";
char*s116_1271A=" R=";
char*s97_74133124A="\" is not a creation procedure of this class).";
char*s838_1274A=")),";
char*s116_148900A="!=0)\173""\n";
char*s567_38182A="/*tmp";
char*s615_182255408A="Deferred \173""";
char*s638_1431664982A=">>24)&0xFF));\n#else\n";
char*s638_1280A=")+(";
char*s717_1281A="(0)";
char*s116_1284A="((T";
char*s630_1285A="),(";
char*s718_1286A="(1)";
char*s638_1291A="))=";
char*s112_932412928A="                ";
char*s666_1083579905A=" while building type ";
char*s116_81256A="evobt";
char*s116_1295B="*)(";
char*s116_1295A="*/\n";
char*s632_25900A=" && (";
char*s630_1298A=", &";
char*s441_1642232185A="Cannot find include \"";
char*s459_1952642401A="The type of this constant feature should be BOOLEAN.";
char*s637_1302A=")/*";
char*s632_685204250A=": switch(*(";
char*s628_7454A="\'\\0\'";
char*s627_1312A=")->";
char*s719_14757563A="\011""struct:\173""";
char*s335_855586967A="Cannot use agents type marks or TUPLE type marks inside cecil files (Liberty Eiffel limitation, sorry). To work around, just use an extra Eiffel routine/object to perform agent or TUPLE manipulation in pure Eiffel.";
char*s34_1988096A="feature";
char*s615_7475A=" se_";
char*s33_747962924A="type_item_is_expanded";
char*s116_32080A=")));\n";
char*s543_902076231A="Type-system safety check not performed in this mode\n(use the -safety_check flag).\n";
char*s116_1326A="*/)";
char*s347_10414970A="item_xxx";
char*s372_1686701A="Result.";
char*s34_945182441A="Environment";
char*s116_1330A=");\n";
char*s837_26635163A=")new_na(&";
char*s33_1245671098A="set_object_attribute";
char*s112_1335A=",-\n";
char*s412_13637A="The ";
char*s833_1542419950A="if(bdw_na_assign_innerT";
char*s103_2097430832A="Underscore notation _ not supported inside fractional part.";
char*s104_140920753A="You must use an even number of hexadecimal digits to denote a sequence of CHARACTERs.";
char*s615_37202594A="Feature \"";
char*s484_412142950A="Only static type can be used for this form of creation.";
char*s430_1304837581A="First argument of `manifest_put\' must be an INTEGER.";
char*s34_87466A="retry";
char*s116_411134193A="........ local buffer ........";
char*s284_413151726A=" because type ";
char*s281_1136866084A="\n      inserted as ";
char*s640_1068122514A="void* se_introspecT";
char*s719_2077255577A="fprintf(SE_GCINFO,\"C-stack=%d \",gc_stack_size());\nfprintf(SE_GCINFO,\"main-table=%d/%d \",gcmt_used,gcmt_max);\nfprintf(SE_GCINFO,\"fsoc:%d(\",fsoc_count);\nfprintf(SE_GCINFO,\"free=%d \",fsocfl_count());\nfprintf(SE_GCINFO,\"ceil=%d) \",fsoc_count_ceil);\nfprintf(SE_GCINFO,\"rsoc:%d(\",rsoc_count);\nfprintf(SE_GCINFO,\"ceil=%d)\\n\",rsoc_count_ceil);\nfprintf(SE_GCINFO,\"GC called %d time(s)\\n\",collector_counter);\nfprintf(SE_GCINFO,\"--------------------\\n\");\n";
char*s637_116864219A="local buffer...";
char*s430_1081673178A="First argument of `manifest_make\' must be an INTEGER.";
char*s486_869266852A="Cannot rename feature `c_inline_c\' because this name is used as a keyword to handle the corresponding \"built_in\" feature of ANY.";
char*s344_590983311A="While checking this call in ";
char*s120_1382A="-- ";
char*s375_762122588A=" Error detected while checking this code in the ";
char*s278_139303084A="c_compiler_options";
char*s615_2028521226A="se_dump_stack ds;\n";
char*s286_362867332A="). Cannot go on: please try removing your .id file or calling \"se clean\". If that fails, please send an e-mail at liberty-eiffel@gnu.org";
char*s104_996106634A="Invalid unicode notation (see also http://www.unicode.org as well as feature \173""UNICODE_STRING\175"".valid_unicode).";
char*s103_1910692676A="Routine body expected.";
char*s103_1466196812A="Error while reading real number.";
char*s833_1043020315A=";\nreturn R;\n";
char*s116_1618833880A="fd.assertion_flag=1;\n\175""\n";
char*s650_1846931416A=" is not a valid ancestor for this method.";
char*s278_86060043A="Just finished parsing of \"";
char*s1006_1807195960A=" does not provide any .h or .c file, nor a cecil.se file!";
char*s567_7557A=" tmp";
char*s410_1127350535A="Void must not be the right-hand side of an assignment test (always True).";
char*s287_87520A="\173""ANY\175""";
char*s572_1407A=")=M";
char*s719_1994331A="gc_free";
char*s718_1582973561A="bdw_weakref_setlink((bdw_Twr*)(";
char*s409_1705796732A="Overflow of infix \"*\" with INTEGER_8 operands. (";
char*s835_1414A=" gc";
char*s104_181806522A="Unexpected new line in manifest string.";
char*s116_1417A="/* ";
char*s632_32175A=")) \173""\n";
char*s640_32176A="(*C).";
char*s650_39109479A=" is different from the one explicitly listed here.";
char*s103_342864313A="An anchored type cannot be used to indicate exportation status in a client list.";
char*s414_1732344459A=" and the default creation procedure (see `default_create\' in class ANY) is not allowed. You must use one of the available creation procedure here.";
char*s103_2110077371A="Must use exactly 8 hexadecimal digits for INTEGER_32.";
char*s615_1426A="*C)";
char*s33_87541A="print";
char*s33_1427A="#\\\\";
char*s125_210310269A="Removing \"";
char*s123_489233515A="agent_launcher";
char*s371_1459510708A=" is of type ";
char*s833_1114679499A=" bdw_malloc_innerT";
char*s719_1028650A="(u->CL_";
char*s414_1382321814A="Cannot assign newly created object of type ";
char*s638_29107967A="*((int32_t*)(";
char*s116_1540494783A="]=((void(*)(FILE*,void*))se_prinT";
char*s112_1438A=".00";
char*s632_1241777620A="if (NULL==(";
char*s116_2087300232A="void*(*se_introspecT[";
char*s637_1124779458A="if(R)R=((C->_";
char*s30_941571923A="output_error_warning_on";
char*s695_1452A=" \174"" ";
char*s358_1440516445A="Invalid type for the target of this function call.";
char*s126_150325744A="can_assign_to";
char*s505_90494969A=" is a procedure. Anchored type is not valid.";
char*s718_308117350A="GC_enable();\n";
char*s278_1689176777A="external_c_plus_plus_files";
char*s116_1924772383A="/*Aliased storage area or unicode storage.*/\n";
char*s719_1246790712A="gc_mark(u->";
char*s477_486705491A="Unexpected trailing character";
char*s719_530955790A="GC support: generating functions.\n";
char*s835_81437A="fsoc*";
char*s116_1476A=")R)";
char*s638_813409A="))=*((T";
char*s443_1478A="0.0";
char*s116_188283590A="T0*se_ums(";
char*s627_1481A="/*`";
char*s632_1307328870A="/*until*/if(";
char*s344_934695142A="Different result types.";
char*s116_1273572186A="se_local_profile_t local_profile, master_profile;\n";
char*s30_579450289A=": the new name of the \"-trace\" flag is now \"-sedb\".\n";
char*s103_54634669A="precursor";
char*s614_340114884A="7(file,(EIF_STRING*)";
char*s116_1493A="/*l";
char*s33_1375414302A="type_generating_type";
char*s103_1744209811A="Bad use of predefined type NATIVE_ARRAY.";
char*s719_1770234694A="(!gc_is_off)";
char*s116_13801A="]=p[";
char*s116_586511651A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_agent_profile+i);\n\175""\n";
char*s703_511703191A="Cannot rename ";
char*s837_479982486A="!=NULL)\173""\nn=";
char*s116_1404852998A="sedb_breakpoint(&ds,";
char*s403_35382059A="\?=  assignment (an assignment attempt).";
char*s103_49203356A="attribute";
char*s116_2142659303A="se_profile_t inv_profile";
char*s409_2480364A="Overflow for opposite of Minimum_integer_16.";
char*s403_354065377A=" (\"::=\" is not necessary).";
char*s119_582925635A="Can\'t join these two attribute definitions. Because an attribute cannot be undefined (using an undefine clause), you may consider to modify parents themselves. May be.";
char*s103_2047201942A="Substitute with \",\".";
char*s103_1909979286A="Feature name expected here.";
char*s125_1680762272A="\" not found.\n";
char*s103_1642195503A="The !! notation is really old and ugly, it should not be used anymore. Please update your code and use the `create\' keyword.";
char*s33_880412606A="generating_type";
char*s34_2234341A="variant";
char*s278_1709309070A="Unable to load class \"";
char*s112_1102814319A="System is \"";
char*s637_1530A="->_";
char*s833_7682A="*R=M";
char*s103_833080669A="End of text expected.";
char*s637_1679636650A="((real32_t)(";
char*s479_413651A="inline";
char*s837_129037214A="(fsoc*c,gc";
char*s33_279656751A="std_output";
char*s409_2480394A="Overflow for opposite of Minimum_integer_32.";
char*s103_962885232A="Expression ";
char*s637_4178071A="*/)):0))";
char*s33_859431564A="type_attribute_generator";
char*s116_490869799A="_external_cpp";
char*s103_791727511A="Bad generic list. Expected \',\' or \']\', but found \'";
char*s116_1164920984A="se_profile_t profile";
char*s103_2099054905A="Correct the previous error";
char*s669_643795973A="Incompatible actual argument for agent call. Cannot pass ";
char*s719_1111954737A="void gc_mark_";
char*s34_1957581A="default";
char*s278_1553744164A="external_object_files";
char*s116_1565A="&ds";
char*s637_511943145A="),(double)(";
char*s103_2037548A="Bad create instruction (type expected).";
char*s615_491029751A="/*agent is_equal*/int ";
char*s837_1111960899A="void gc_sweep";
char*s116_1471782099A="switch (expression->id) \173""\n";
char*s103_955584028A="Expression expected after the \"elseif\" keyword.";
char*s34_407540A="frozen";
char*s33_438300A="second";
char*s351_242535516A="Invalid type for the target of this procedure call.";
char*s717_161521A="))->o)";
char*s632_283285900A="while(1)\173""\n";
char*s116_1661632742A="]=atexit_profile;\n";
char*s719_2006740748A="\173""int i=o->id;\n";
char*s33_761722990A="mark_native_arrays";
char*s484_1319735562A="Cannot use anchored type for this form of creation.";
char*s103_1208507031A="Obsolete manifest string expected.";
char*s615_1185483839A="ds.locals=NULL;\n";
char*s125_3556890A="\" file.\n";
char*s104_1038536453A="Extra blank or tab character removed in multi-line manifest string.";
char*s614_1191155066A="(FILE* file,T";
char*s112_2011772281A="Unknown C mode: ";
char*s33_185934049A="NATURAL_16";
char*s718_1992734941A="GC_enable();\neiffel_root_object=NULL;\nGC_gcollect();\nhandle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s112_1626A="/Fe";
char*s409_2480479A="Overflow for opposite of Minimum_integer_64.";
char*s33_185934055A="NATURAL_32";
char*s30_7779A=".ACE";
char*s103_2055333675A="Slash \"/\" or decimal digit expected (inside CHARACTER constant).";
char*s116_1607940692A="se_profile_t agent_switch_profile";
char*s116_860532685A="handle(SE_HANDLE_NORMAL_EXIT, NULL);\n";
char*s112_2139128753A="The environment variable \"";
char*s719_1783951564A="if(gc_info_nb_agent)\n   fprintf(SE_GCINFO,\n   \"%d\\tagent(s) created. (store_left=%d).\\n\",\n   gc_info_nb_agent,store_left_agent);\n";
char*s116_1639A=";\nr";
char*s34_1532344910A="cpp_compiler_type";
char*s33_619776399A="Integer_bits";
char*s34_479921113A="c_compiler_type";
char*s477_522818189A="default_value";
char*s812_1644A=": \"";
char*s33_185934072A="NATURAL_64";
char*s638_32400A="));\n\175""";
char*s615_1923813010A="\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.current=";
char*s614_1646A="*o)";
char*s468_2141380032A="Any given feature name should appear at most once in one export clause for each parent clause. Feature ";
char*s103_1254996328A="Cannot use hexadecimal notation for this type.";
char*s837_687744958A="o=(void*)o->_";
char*s116_1650A=";\n\175""";
char*s632_1650A=")\173""\n";
char*s837_1651A="*p)";
char*s430_265238926A="Feature `manifest_put\' must have at least two argument and the first one must be an INTEGER argument.";
char*s112_7809A=".BAT";
char*s632_180037A=" else ";
char*s609_386149138A="pending_c_function_counter_tag";
char*s103_401981819A="..........................................................";
char*s116_1164208A="#ifdef _BASE_H\n#define _HAD_BASE_H\n#endif\n";
char*s573_1046299075A=" (from -cecil \"";
char*s719_1676A="*u)";
char*s33_1326673961A="object_size";
char*s718_112977096A="(GC_gc_no)";
char*s637_32435A=")))\174""(";
char*s837_44739A="=((gc";
char*s35_1994621A="gc_info";
char*s103_1289042164A="Void cannot be the left-hand side of the binary \"//\" operator.";
char*s637_32456A=")+.5)";
char*s116_1946737844A="Order of evaluation for pre-computed once functions:\n";
char*s116_14005A="[];\n";
char*s116_192841706A="NULL, NULL";
char*s377_1348774A="AT_EXIT";
char*s409_1337425939A=" which is out of range 0 ..63 because target type is INTEGER_64.";
char*s119_1875884480A="The local definition in ";
char*s544_142089811A="/etc/issue";
char*s434_1110386385A="You have to use another name for this formal generic argument. The common usage is to add an extra trailing underscore character (see for example COLLECTION, ARRAY or DICTIONARY).";
char*s116_7869A="&ds,";
char*s718_636642526A="(!GC_dont_gc)";
char*s288_2082988666A=" (The validation context is ";
char*s112_7878A=".CMD";
char*s632_1727A=":/*";
char*s419_183516812A="Attribute ";
char*s637_1586596820A="<<8)\174""((uint16_t)";
char*s638_29126717A="*((int16_t*)(";
char*s34_14036A="True";
char*s33_55926626A="std_input";
char*s116_48520827A="cecilcrea";
char*s632_1060489498A="requireresult=";
char*s612_161665A=" NULL\n";
char*s430_1857191624A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_semicolon_check\').";
char*s121_1797674551A="internal_exception_handler(Incorrect_inspect_value);\n";
char*s112_1744A=".cc";
char*s632_1115076A="=((T0*)";
char*s632_180128A=" else\173""";
char*s103_941240074A="Keyword \"end\" expected at the end of check clause.";
char*s278_608446371A="You have to fix the problem in your ACE file. Valid assertion level tags are: \"no\", \"require\", \"ensure\", \"invariant\", \"loop\", \"check\", \"all\", and \"debug\".";
char*s483_1753A="0e0";
char*s484_112048371A=" creation.";
char*s116_1852104762A=" C;\nint i=0;\nva_list pa;\nva_start(pa,argc);\nC=";
char*s119_22612837A=" in type ";
char*s116_1765A="=((";
char*s414_176104896A=" ... << ... >> \175"" manifest creation notation.";
char*s380_1712194128A="\' is out of INTEGER_8 range.";
char*s104_256559978A="Useless keyword deleted.";
char*s414_1458557644A="Creation clause exists for type ";
char*s97_1052333303A=" (compare usage and definition below).";
char*s103_1296817101A="). Instruction or keyword \"";
char*s112_1775A=".id";
char*s29_1128710280A="Liberty Eiffel does not (yet) support precompiled headers for\nthis C compiler. Please drop an e-mail liberty-eiffel@gnu.org%N";
char*s103_376006259A="Missing manifest STRING for `c_inline_c\'.";
char*s116_1364588829A=" se_manifest";
char*s379_7506001A="Current.";
char*s116_36778611A="local_profile.profile=profile+";
char*s103_970900228A="\" while waiting for some local variable name. Cannot use \"";
char*s612_565063403A="/* C Header Pass 2: */\n";
char*s459_2108232434A="The type of this constant feature should be STRING.";
char*s116_4049151A="((T0*)C)";
char*s837_1523807481A="*o1,*o2;\no1=((gc";
char*s499_920757291A="The value of ";
char*s403_1801A="::=";
char*s718_539192311A="void*bdw_markna;int bdw_generation;";
char*s103_1917483795A="Error while reading manifest number.";
char*s650_1658151484A=" misses some clients of the conforming parent(s) for ";
char*s116_1630601156A="during C code generation (backend)";
char*s110_89019087A="\" in type ";
char*s34_2185421A="require";
char*s34_251171752A="flat_check";
char*s103_1778077539A="Void cannot be the left-hand side of the binary \"-\" operator.";
char*s33_312005144A="type_can_be_assigned_to_attribute";
char*s103_1665385073A="The base type is no longer used. Class FUNCTION now has only two formal generic arguments. Just remove this unused type mark.";
char*s357_1771711260A="Symplify interrupted (infinite inlining\?) in CALL_0.\n";
char*s29_1464431905A="Usage: compile_to_c [options] <RootClass> <RootProcedure> ...\n   or: compile_to_c [options] <ACEfileName>.ace\n\nFor information about and examples of ACE files, have a look\nin the SmartEiffel/tutorial/ace directory.\n\nMost of the following options are not available when using\nan ACE file.\n\nOption summary:\n\nInformation:\n  -help               Display this help information\n  -version            Display Liberty Eiffel version information\n  -verbose            Display detailed information about what the compiler is\n                       doing\n\nWarning and Error levels:\n  -style_warning      Do print warnings about style violations\n  -no_warning         Don\'t print any warnings\n  -relax              Performs less checks by considering less dead code, hence\n                       using less memory and less compilation time. Useful to\n                       prototype or to deliver safe code. (Useful too for very\n                       small computers.)\n\nOptimization and debugging levels (specify at most one; default is"
" -all_check):\n  -boost              Enable all optimizations,\n                       but disable all run-time checks\n  -no_check           Enable Void target and system-level checking\n  -require_check      Enable precondition checking (implies -no_check)\n  -ensure_check       Enable postcondition checking (implies -require_check)\n  -invariant_check    Enable class invariant checking (implies -ensure_check)\n  -loop_check         Enable loop variant and invariant checking\n                       (implies -invariant_check)\n  -all_check          Enable \'check\' blocks (implies -loop_check)\n  -debug              Enable \'debug\' blocks\n  -flat_check         Each assertion will be executed in no_check mode\n                      Use with any mode from require_check to all_check\n\nClass lookup:\n  -loadpath <file>    Specify an extra loadpath file to read\n\nC compilation and run-time system:\n  -cc <command>       Specify the C compiler to use\n  -c_mode <C mode>    Specify a C mode to use. This option is incompatible\n        "
"               with -cc\n  -cecil <file>       Take CECIL information from <file>\n                       (may be used more than once)\n  -o <file>           Put the executable program into <file>\n  -no_main            Don\'t include a main() in the generated executable\n  -no_gc              Disable garbage collection\n  -bdw_gc             Use Boehm-Demers-Weiser conservative GC\n  -gc_info            Enable status messages from the garbage collector\n  -no_strip           Don\'t run \'strip\' on the generated executable\n  -no_split           Generate only one C file\n  -split <split mode> Selects the split mode\n                       Either \'no\', \'legacy\', or \'by_type\'\n  -sedb               Enable sedb, the Liberty Eiffel debugger\n  -profile            Generates profile on Eiffel calls at program exit\n  -manifest_string_trace\n                      Enable the trace support to track non-once\n                      manifest string creation\n  -no_rescue          Don\'t compile rescue sections\n\nMiscellaneous:\n  -high_memory_c"
"ompiler\n                      Allow the compile_to_c to use more memory; if you\n                      have enough physical memory, compilation should\n                      be faster (note: generated C code is not affected)\n";
char*s544_1826A=".se";
char*s126_75639A="_from";
char*s484_1832A="<< ";
char*s637_1651828280A="/* same_dynamic_type */\n";
char*s344_1813679543A="In the redefinition context (i.e in ";
char*s637_1214258443A="0;\nerror0(\"Invalid is_deep_equal.\",NULL)";
char*s637_167916A="((uint";
char*s637_1840A="<<(";
char*s637_108351709A="),sizeof(T";
char*s719_869136A="*)newCL";
char*s33_94407393A="collection_off";
char*s33_14150A="Void";
char*s837_32605A="*)(&(";
char*s103_50040236A="else part";
char*s719_1697044300A="equivalent memory structure";
char*s116_1154403080A="print_profile(profile_file, &atexit_profile);\n";
char*s477_1468725331A="Required key \"";
char*s116_426087775A="#ifndef _HAD_BASE_H\nextern void*eiffel_root_object;\n\ntypedef T3*T9;\n#endif\n/* Available Eiffel routines via -cecil:\n*/\n";
char*s116_57150800A="atexit(se_atexit);\n";
char*s103_1021024803A="Manifest string expected for \"obsolete\" clause.";
char*s837_47598300A="o);\n\175""\n\175""\n\175""";
char*s281_1188332009A="This call should be some constant feature call (i.e. a statically computable value). (See the definition found in the next error message.)";
char*s103_603076667A="Writable entity expected here.";
char*s638_534333098A="<<8)&0xFF0000)\174""(((uint32_t)";
char*s837_692075493A="*)o)->header.flag==FSOH_UNMARKED))";
char*s116_107312226A="*sizeof(se_profile_t));\nqsort(sorted_agent_switch_profile, ";
char*s459_90390825A="Cannot use type ";
char*s116_267478119A="if(se_rci(caller,C))";
char*s35_2191641A="profile";
char*s614_565069653A="/* C Header Pass 4: */\n";
char*s638_2001063662A="\173""/*slice_copy*/\nint a3tmp=";
char*s35_822199910A="style_warning";
char*s103_2047202317A="Substitute with \";\".";
char*s637_32650A="))>>(";
char*s613_2057228449A="\173""Tid id;T0*o;\175"";\n";
char*s116_438660461A="Cannot produce C code.";
char*s103_502181838A="Missing \"\175""\" to terminate manifest generic creation.";
char*s103_307717976A="Error while reading a number. Missing \"\175""\" \?";
char*s110_327902A="TUPLE ";
char*s637_1900A=">>(";
char*s637_10089540A="floorf((";
char*s103_1938643327A="This call has a result value (and you must use it).";
char*s116_1580612071A="se_profile_t runinit_profile";
char*s579_1747685533A="typedef void*T";
char*s33_735034101A="storage_lower";
char*s103_376006384A="Missing manifest STRING for `c_inline_h\'.";
char*s459_573004463A="A character constant cannot be an assigner.";
char*s33_50778415A="exception";
char*s615_505232755A="/*agent creation*/T0*";
char*s630_36126743A="INT32_MIN";
char*s116_7918258A="SE_MAXID";
char*s835_413927315A="(x) (((se_agent0*)(x))->gc_mark_agent_mold((se_agent*)(x)))\n\n";
char*s719_172408303A="(/*calloc*/(T";
char*s719_1994852A="gc_mark";
char*s33_1530432238A="valid_generating_type_for_internals";
char*s637_887295984A="\n#if BYTE_ORDER == LITTLE_ENDIAN\n(";
char*s103_2061122069A="Error while reading a real. Missing separator after the value \?";
char*s103_945201499A="\'. May be, you just miss to add the \"is\" keyword\?";
char*s103_1933A="C++";
char*s573_992810240A="The type for a creation procedure cannot be INTERNALS.\n";
char*s33_88048A="put_0";
char*s116_950675891A="local_profile.profile=&runinit_profile;\n";
char*s33_88049A="put_1";
char*s572_942808765A="void manifest_string_mark";
char*s103_246527867A="Incorrect hexadecimal notation. Wrong number of hexadecimal digits (";
char*s112_69601A="a.exe";
char*s33_55041091A="put_32_be";
char*s103_4492176A="........";
char*s615_2111741A="locals[";
char*s837_27909038A="if(NULL==gc_find_chunk(o))\nreturn; /* external NA */\n";
char*s33_36200588A="INTERNALS";
char*s573_724183788A="The type for a creation procedure cannot be deferred.\n";
char*s112_683870135A="cc/warning=disable=(embedcomment,longextern) ";
char*s33_261093457A="make_blank";
char*s357_337470426A="Missing anonymous feature for this call";
char*s484_909851733A="Irregular number of items in bunches. The previous bunch is smaller.";
char*s33_1286698901A="element_sizeof";
char*s103_1505459217A="Keyword \"end\" added to terminate inherit/insert parent.";
char*s103_1421116705A="Slash \"/\" character expected after hexadecimal value in CHARACTER constant.";
char*s637_9794360A="deeptwin";
char*s112_1115301A="-x none";
char*s125_124992A="      ";
char*s615_2072064738A="struct rescue_context rc;\n";
char*s33_1680885744A="default_rescue";
char*s112_5525574A="-x \"c++\"";
char*s718_1933391A="bdw_ms[";
char*s718_1949186219A="/*mark_item*/";
char*s116_11086084A="sizeof(T";
char*s615_4996600A="*a1=(se_";
char*s103_676728857A="Error in manifest constant or \"\?:=\" type test \?";
char*s34_451011A="unique";
char*s33_55041141A="put_32_le";
char*s119_1127406485A="An attribute cannot be undefined.";
char*s110_2029530601A="Polymorphic Proceduire/Function Call";
char*s116_1492394528A=";while (i-->0) \173""\nsumup_profile(profile_file, sorted_all_profile+i);\n\175""\n";
char*s33_55041151A="put_32_ne";
char*s637_19199275A="!=NULL)\173""\n";
char*s125_1711985232A="Cannot write file \"";
char*s614_2039095413A="0(file,(T0**)";
char*s630_807791A="))->id)";
char*s103_1284361566A="Character \'%\"\' inserted after \"infix\".";
char*s110_1378502623A="Before simplify cycle";
char*s406_729510616A=" with expression ";
char*s632_28032126A="=((void*)";
char*s484_1646704683A="Unexpected \";\" (semicolon) separator in manifest generic expression. Less items found in this bunch than in the previous one.";
char*s116_1965252672A="]=((void*(*)(void*,char*,int*,int*))se_introspecT";
char*s630_161951A="((T0*)";
char*s281_1281353746A="\n      inherited as ";
char*s116_772432310A="local_profile.profile=agent_profile+";
char*s281_169314461A="No feature found for this call.";
char*s337_971287994A="Precondition";
char*s33_586229245A="type_is_expanded";
char*s637_484454800A="\" argument in external C inline definition.";
char*s640_1150927957A="*C,char*attr,int*id,int*exp)";
char*s837_917774306A="*obj_ptr=(gc";
char*s33_1395184171A="same_dynamic_type";
char*s637_10089690A="floorl((";
char*s116_1307483215A="(&ds,&local_profile,C);\n";
char*s110_891552598A=" cannot be a root class since it is a deferred class.";
char*s116_1724182721A="local_profile.profile=&prof;\n";
char*s637_476433922A="deep_twin_from(";
char*s110_1145029170A="Internal compiler error (set_agent_creation_error_trap).";
char*s371_1970431863A="inspectDynamicDispatchExpression";
char*s104_446380143A="Unexpected comma (deleted).";
char*s116_826425832A="se_dump_stack*caller";
char*s630_21020045A="((void*)(";
char*s637_9954400A="if(!R)\173""\n";
char*s35_2028737205A="flymake_mode";
char*s112_186217457A="... unique once buffer ...";
char*s637_162010A="));\n\175""\n";
char*s116_1656195746A=" main(int argc,char*argv[])";
char*s110_1483967746A="Polymorphic Distribution of \"inspect\" Statements. Measurement\ndone ";
char*s403_1747372019A=" The left-hand side expression must conform to the right-hand side. The expression ";
char*s630_162019A="((T3)\'";
char*s637_162020A="((T3)(";
char*s615_2095A="CA_";
char*s640_5279655A="*id=-1;\n";
char*s410_1993565801A=" can be normally assigned into the left-hand side which is of type ";
char*s116_506210947A="se_general_trace_switch=1;\n";
char*s33_1300046706A="last_result";
char*s33_2104A="ANY";
char*s638_32860A="));\175""\n";
char*s638_2110A=";\175""\n";
char*s116_32869A="(&ds,";
char*s103_2001191A="current";
char*s615_1032053803A="se_dump_stack ds;\nds.fd=&fd;\nds.current=NULL;\nds.p=(caller->p);\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s833_788978585A="if(o->bdw_markna==NULL)\173""\nT0**markna;\nGC_disable();\nbdw_in_assign=1;\nmarkna=se_malloc(sizeof(T0*));\nGC_REGISTER_FINALIZER_NO_ORDER(markna,(GC_finalization_proc)bdw_na_markT";
char*s484_1427483140A="Missing argument before << ... >> item list.";
char*s833_546112503A="void bdw_run_finalizers(void)";
char*s336_977955761A="SEDB object";
char*s34_408086A="export";
char*s116_531983658A="local_profile=global_profile;\n";
char*s543_1806821466A="specializing and checking";
char*s34_251916328A="cpp_strip_path";
char*s103_1176245553A="Anchor expected. An anchor could be `Current\', a feature name or an argument name.";
char*s97_1781104140A="Deferred class should not have creation clause (VGCP.1).";
char*s114_57487A="Amiga";
char*s116_451157A="unlink";
char*s637_8291A="(int";
char*s614_205124A="(file,";
char*s483_2009909053A="...........................................................";
char*s637_162070A="((T5)(";
char*s34_69805A="Tools";
char*s627_2150A="CL_";
char*s640_1113554587A="void*R=NULL;\n";
char*s116_10944785A="se_msi1(";
char*s116_389672A="char*p";
char*s116_389675A="char*s";
char*s572_147115629A="=/*alloc*/((T0*)(";
char*s837_1927425A="begin:\n";
char*s838_14464A="\\n\",";
char*s377_202031759A="STD_OUTPUT";
char*s103_2051403723A="Added \"end\" to finish this \"if\" statement.";
char*s632_162095A="((T6)(";
char*s717_2138778683A="se_malloc(sizeof(T";
char*s281_32926A=", ...";
char*s125_461074983A="The old \"SmallEiffelDirectory\" variable is not valid anymore. Please use SmartEiffelDirectory or,\nbetter still, don\'t use it at all.\n";
char*s409_900982204A="Overflow of infix \"+\" with INTEGER_16 operands. (Adding ";
char*s114_2178A="DOS";
char*s34_401994A="flavor";
char*s833_1744880961A=")se_calloc(*n, sizeof(T";
char*s33_2035472654A="type_attribute_count";
char*s833_42739336A="(&n);\nif(GC_should_invoke_finalizers())bdw_run_finalizers();\nreturn R;\n";
char*s104_2131871127A="Same identifier appears twice (local/closure).";
char*s1006_482960256A=">. The plugin seems to depend on itself! Ignored.";
char*s112_69851A="a.out";
char*s543_1243691337A="getting started";
char*s116_1826935309A="memcpy(sorted_inv_profile, inv_profile, ";
char*s34_2032026A="exclude";
char*s637_1726920051A="se_deep_equal_start();\n";
char*s34_264667428A="assertion_flat_check";
char*s116_351488799A="/*unknown position*/";
char*s103_4750778A=" warning";
char*s116_383570A="agents";
char*s833_1005223232A="void bdw_na_markT";
char*s637_1240185282A="Bad prototype for C struture set external.";
char*s34_820292A="****** ";
char*s119_1585514726A=", features \"";
char*s116_1637927398A="se_local_profile_t*parent_profile";
char*s278_698011541A="Cluster tree:\n";
char*s397_529996976A="Conflict between local/feature name (VRLE).";
char*s119_1297180456A=" because there is a local definition in this class. Redefine has been automatically added. Please check.";
char*s33_1447702A="INTEGER";
char*s112_1255802680A="emxbind -qs";
char*s527_922867504A="This obsolete manifest ARRAY creation is no longer supported. See our \"SmartEiffel/tutorial/manifest_notation.e\" in order to use the new notation.";
char*s34_88336A="short";
char*s103_599810839A="There is no need for the \"expanded\" keyword in an \"insert\" clause.This keyword will be ignored.";
char*s614_1112927266A="void se_prinT";
char*s33_840111968A="collection_on";
char*s484_115013643A="Actually, for class ";
char*s637_234933541A="_t)-((uint";
char*s32_1181006553A="Feature `default_rescue\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s103_1023251859A="Replaced misspelled \"False\".";
char*s753_2114672999A="Using range inside inspect of type STRING is not possible.";
char*s409_442652821A=" which is out of range -31..31 because target type is INTEGER_31.";
char*s110_601041072A="class-path: \"";
char*s430_797085749A=". An expanded type must have one unique creation procedure with no argument: the creation procedure used for automatic initialization.";
char*s33_1297432701A="is_infinity";
char*s837_5839580A=".store;\n";
char*s33_2067759348A="from_pointer";
char*s615_832670A="(*afp)(";
char*s640_8436A="*id=";
char*s441_408035024A=" is hiding the definition in ";
char*s650_1679625106A="The final client list for ";
char*s335_864187036A="Loading cecil entries:\n";
char*s719_1155996628A="/*mark_item*/\175""";
char*s33_1209184326A="object_invariant";
char*s103_700613496A=" is not a valid feature name to start a new feature definition. Parser lost. Sorry. Check before and after that point.";
char*s637_45355A="=*C;\n";
char*s640_1245850444A="\173""\nstatic T0*_r=NULL;\n_r=";
char*s119_1041926341A="The feature ";
char*s615_2301A="R&=";
char*s103_1689577436A="Expression expected after \"elseif\" keyword.";
char*s33_1604515261A="to_internals";
char*s637_1096165867A="is_deep_equal(";
char*s103_860582570A="\" cannot be a valid feature name or a valid local name (only lower case letters are allowed here). Furthermore \"";
char*s544_2003309199A="/etc/xdg/liberty-eiffel";
char*s637_245384155A="clear_all(";
char*s116_1816632501A="se_local_profile_t local_profile;\n";
char*s119_1811139659A=" type.\n\nFirst \"insert\" path (from parent to child):\n   ";
char*s33_728963476A="type_item_generating_type";
char*s627_156095A="\'*/CA_";
char*s33_9647090A="and then";
char*s719_8475A="(se_";
char*s837_945011211A="=(((void*)obj_ptr)<=((void*)item));\nobj_ptr = (T0*)(((char*)obj_ptr) + obj_size);\nif (swept != (((fso_header*)obj_ptr)->flag==FSOH_UNMARKED)) /* **** TODO: was FSOH_UNMARKED\?\?\?\? (incoherent with comment below) */\n/* (already swept) xor marked */\nitem->o=NULL;\n\175""\n";
char*s103_28789007A="Actually, a creation list must not be empty. You must have at least the `default_create\' procedure inherited from ANY. The `default_create\' indicates that one can also create an object with no creation procedure. The `default_create\' has been added here automatically.";
char*s103_1874765620A="A missing client clause is interpreted as \173""ANY\175"". It is better to be explicit.";
char*s114_395994A="distcc";
char*s637_8485A="(vc(";
char*s111_546635553A="SMART_EIFFEL_SHORT_VERSION";
char*s637_1553763390A=")==(a1ptr->_";
char*s116_20552830A="(&ds,C);\n";
char*s649_1664721281A="........... unique buffer ...............";
char*s103_1752914319A="Instruction expected here. False alone is not an instruction.";
char*s103_2020913390A="Added missing \"then\" keyword.";
char*s34_414461A="insert";
char*s719_8499A=")new";
char*s615_1426099398A=".............................";
char*s103_156243902A="Void cannot be the target of prefix operator \"";
char*s629_1476205446A="fcstrangeisnotunlock";
char*s632_1936367907A="/*inspect]*/\n";
char*s278_1955866577A="external_lib_path";
char*s33_10938831A="se_fault";
char*s649_1025503229A=" using range tmp0 .. tmp";
char*s116_273715710A="#ifdef SIGINT\n                                                    signal(SIGINT,se_signal_handler);\n#endif\n#ifdef SIGTERM\n                                                    signal(SIGTERM,se_signal_handler);\n#endif\n";
char*s455_914877497A="Same feature name appears twice.";
char*s837_1653483427A="typedef struct Sgc \173""Tid id;T0*o;\175"" Tgc;\n";
char*s637_244793715A="deep_twin(";
char*s373_1360462097A="reference: ";
char*s790_1121854A="/bin/sh";
char*s344_2084982239A=" context, it appears to be a call to an obsolete feature:\n";
char*s33_175767198A="EXCEPTIONS";
char*s650_1238684603A="The client list computed from the \"export\" clauses";
char*s112_45436A=".make";
char*s837_737599544A="=o1;\n\175""\n\175""\n\175""\nelse\173""\nint dead=1;\ngc";
char*s116_419316052A="/*Force definition of non-live NATIVE_ARRAY[CHARACTER] for manifest strings*/\ntypedef T3* T9;\n";
char*s116_2382A="T0*";
char*s116_732574181A=";\nwhile (i < argc ) \173""\n";
char*s97_1452647150A="Forbidden creation call (i.e. exportation rules violated). Creation is only allowed from ";
char*s373_41841490A="FIXED_STRING";
char*s112_217674A=".h.gch";
char*s116_149822297A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_agent_switch_profile+i);\n\175""\n";
char*s609_1359151955A="internal_c_local_tag";
char*s609_8545A=":*/\n";
char*s646_2394A="T11";
char*s615_126319331A="rescue_context_top = rc.next;handle(SE_HANDLE_EXCEPTION_CLEAR,NULL);\n";
char*s116_1965511388A="/*INIT CLOSURE LOCALS]*/\n";
char*s116_2395A="R=(";
char*s646_2395A="T12";
char*s719_1418601377A="(/*malloc_closure*/(T";
char*s103_1478844272A="Removed that non-significant digit in integral part or real constant.";
char*s103_1223700793A="Inside a function, a Precursor call must be a function call (not a procedure call).";
char*s103_529554293A="Removed unexpected blank space(s) just before this dot (assume you really want to call a function using the previous manifest expression as the target).";
char*s288_63912A="Line ";
char*s103_2117988535A="Void is not a valid BOOLEAN expression (just after keyword \"elseif\").";
char*s110_2114217978A="Monomorphic Function Call";
char*s719_1327517381A="#ifndef FIXED_STACK_BOTTOM\nif(!valid_stack_bottom) stack_bottom = NULL;\n#endif\n";
char*s632_2065182209A="if(!requireresult)\173""\n";
char*s116_1530032908A="fprintf(profile_file, \"\\n-------------------------------------------------------------------------------\\n\");\ni=";
char*s406_1222747401A=". (This would always yield to a ";
char*s110_768828206A="Looking for ";
char*s278_2070822678A="The \"adapt\" clause is not yet implemented.";
char*s34_76226A="adapt";
char*s103_439136A="select";
char*s116_2417A="T7*";
char*s441_146113272A="The definition of ";
char*s97_2123229206A=" is obsolete:\n";
char*s278_763815152A="\nYou are in command line mode (i.e. no ACE file is used).\nThe load path can be changed using a file called\nloadpath.se in the current working directory.\nUsually, this loadpath.se file is a simple list of directories.\nIt is also possible to use system variables or include files. See\nthe documentation for the finder command for more information.\n";
char*s278_957054969A="-debug_check is deprecated. Please use -debug and another -*_check assertion level. This defaults to -all_check.";
char*s490_180503525A=".......................";
char*s114_2440A="OS2";
char*s278_556698697A=": error: No <Root-Class> in command line.\n";
char*s112_6159594A="C mode \"";
char*s833_82948679A=")bdw_malloc_innerT";
char*s613_199280A=",NULL\175""";
char*s718_645592960A="s=(T7*)bdw_mallocT7(1);\n";
char*s125_1974940930A="\" variable used";
char*s637_8779932A="Unknown ";
char*s637_168532A="*)R)=M";
char*s544_1646495986A="Configuration chain (the lower the more specific):";
char*s640_1956008156A="\175"" else \173"" *id=0; \175""\n";
char*s104_274238642A="Deleted extra comma.";
char*s33_2090604340A="full_collect";
char*s33_591414963A="standard_copy";
char*s117_1753572602A="Infinite inlining loop (bad recursion \?\?). ";
char*s103_614881029A="Syntax error while trying to parse a conversion clause. Expected either \'(\' or \':\'";
char*s611_11381817A="typedef ";
char*s632_48939825A="default:\n";
char*s104_332623945A="Bad creation/create (procedure name expected).";
char*s409_282345691A=" which is out of range -7..7 because target type is INTEGER_8.";
char*s572_1119207694A="&gc_local_profile";
char*s719_118716790A="fprintf(SE_GCINFO,\"==== Last GC before exit ====\\n\");\ngc_start();\n";
char*s632_48939847A="default: ";
char*s103_554066118A="\" is not valid identifier. For a better readability Liberty Eiffel _is_ case sensitive. Hence \"";
char*s103_1439398002A="A Precursor type mark annotation must not be anchored.";
char*s477_1917908900A="feature_name";
char*s103_1193216533A="A type mark is not a valid item for a manifest array. Keep in mind that Liberty Eiffel is case-sensitive and that ";
char*s632_279959115A="\173""\nse_dump_stack *caller=&ds;\n\173""\nse_dump_stack ds=\173""NULL,NULL,caller->p,caller,NULL,NULL\175"";\n";
char*s103_277837020A="Missing items in manifest creation \"<< ... >>\" list. The last bunch should have ";
char*s33_2504A="SET";
char*s106_1656731300A=" in the section [";
char*s719_49917876A="if(NULL!=";
char*s544_193194A="/.serc";
char*s114_207986277A="OpenVMS_CC";
char*s103_180894A=" error";
char*s833_2075405A="na=o->_";
char*s831_125876584A="GC_call_with_alloc_lock((GC_fn_type)bdw_na_assignT";
char*s291_1477688005A=": unsupported option \"";
char*s337_1777506207A="Check_instruction";
char*s34_402346A="ensure";
char*s637_33291A="((int";
char*s125_2537A="No ";
char*s103_761631659A="Cannot use an uppercase letter inside such an identifier. Yes, this rule is strict, but it is better for all of us to be able to distinguish at a glance a CLASS_NAME from another name. Furthermore, it would be really too bad for example to use `IsEmpty\' or `isEmpty\' at one place while all other places are using `is_empty\'. Finally, this strict constraint will help us to improve error messages of the compiler.";
char*s380_2126200255A="................................";
char*s121_584218374A="setup_signal_handler();\n";
char*s116_2545A="\n*/\n";
char*s615_1575353618A="static se_frame_descriptor fd=\173""\"Agent launcher\",0,0,\"\",1\175"";\n";
char*s833_886939850A="**markna,void*_)";
char*s579_33316A="* o2)";
char*s33_1223768616A="NATURAL_GENERAL";
char*s835_2082029949A="\173""0,NULL,NULL,NULL,(void(*)(T0*))";
char*s699_2565A="[1-";
char*s103_1909918820A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure to the previous `False\' constant as target).";
char*s650_1711825865A="Multiple Precursor found (must use Precursor \173""...\175"" ancestor selection).";
char*s33_744845610A="valid_generating_type_for_native_array_internals";
char*s719_1637706318A="GC support: adding root functions.\n";
char*s409_1670460393A="Overflow of infix \"-\" with INTEGER_16 operands. (";
char*s544_64080A="Linux";
char*s637_2571A="]))";
char*s116_10028705A="s,e,c);\n";
char*s637_1079001A="(void*)";
char*s615_1489891655A=" features).\n";
char*s406_1182157125A="The declaration type of ";
char*s637_37173080A="R,a1-1);\n";
char*s579_3920780A="(&(o1->_";
char*s114_76405A="bcc32";
char*s119_305596576A=") there are two versions of the same initial feature with two different names. To  fix this, either use an \"insert\" link in place of one of the \"inherit\" links or rename the feature to get the same name in ";
char*s116_1361175839A="init_profile(profile+";
char*s278_22915075A=" items):\n";
char*s116_218061703A="*/\nse_signal_handler(14/*System_level_type_error*/);\n";
char*s112_98806116A=" Data=Auto";
char*s34_82570A="infix";
char*s719_411283072A="/*Ordinary once functions:*/\n";
char*s103_1731250773A="Empty generic list (deleted).";
char*s32_1194182360A="Feature `default_create\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s103_1564737054A=" after the $ operator. ";
char*s30_8771A=".ace";
char*s104_894954671A="In extended form of manifest string. Bad character after \'%\'.";
char*s573_950159899A="Error while loading features of cecil path file \"";
char*s103_2992013A="Unknown external language specification.";
char*s116_2630A="];\n";
char*s34_114085235A="# End of parallelizable section";
char*s112_1247935972A="\" environment variable\nwith the absolute path of your own hand-made SmartEiffel\nconfiguration file.\n";
char*s116_1308400309A="#define SE_EXCEPTIONS 1\n";
char*s638_1773508175A="<<24\174""(((uint32_t)";
char*s112_8801A=".bat";
char*s637_524787520A="((uint8_t)(";
char*s112_530877013A=" StripDebug";
char*s459_789877170A="Unique feature must have INTEGER type.";
char*s103_1098712729A="Manifest value not compatible with this type.";
char*s637_1116064705A="(T6)!memcmp(C,&a1,sizeof(T";
char*s638_1053613605A=";\nmemcpy(&((";
char*s459_783418632A=". Bad constant-attribute definition.";
char*s572_2670A="]=(";
char*s116_33425A=")->id";
char*s375_292944046A=" Bad assignment.";
char*s837_1069766146A=".store_left;\n";
char*s33_88795A="third";
char*s812_480414235A="Unknown loadpath in ";
char*s110_1572647306A="The feature called has ";
char*s839_585110409A=".store->header.size=";
char*s837_8836A="*wr)";
char*s116_1082664800A="start_print_profile(profile_file);\n";
char*s796_1309286095A="XDG_CONFIG_HOME";
char*s122_138929174A="\" seems to be empty.";
char*s637_1263916320A="fpclassify(";
char*s30_1010347497A="Flag -is_output_error_warning_on must be used only once.\nYour command was:\n";
char*s34_2063276A="include";
char*s33_201970776A="force_to_integer_64";
char*s34_396356A="create";
char*s637_1023363018A=")=*C;\nse_deep_twin_register(((T0*)C),";
char*s477_1089314041A="An external \"plug_in\" must be described with an alias clause. (Have a look in our standard library or in our tutorial for examples.)";
char*s33_201970793A="force_to_integer_32";
char*s281_2089269822A="The huge generic derivation related to the previous warning is: ";
char*s33_756809447A="Minimum_real";
char*s627_23647157A="/*empty*/";
char*s35_234165132A="manifest_string_trace";
char*s33_201970799A="force_to_integer_16";
char*s611_15019A="_t T";
char*s34_479922190A="c_compiler_path";
char*s719_2050807628A="c_struct_signature";
char*s637_15020A="_t)(";
char*s116_33475A="((se_";
char*s468_1172758533A="There should be at most one export clause with the \"all\" keyword in each parent clause. The client lists will be merged, but please fix the export clauses.";
char*s650_1912840703A="Keyword \"ensure\" replaced with \"ensure then\" because there is an inherited ensure assertion.";
char*s116_1934139A="caller,";
char*s344_1646268668A=" These two inherited features have the same name in type `";
char*s116_8880A=",lsi";
char*s112_8884A="-x c";
char*s637_8885A=")\174""\174""(";
char*s543_520647979A="The system is type safe.\n";
char*s406_112006296A=" context.)";
char*s112_8889A=".com";
char*s116_941548611A="memcpy(sorted_all_profile+";
char*s719_1637595774A="(eiffel_root_object);\nmanifest_string_mark1();\nonce_function_mark();\n";
char*s32_8897A=".cpp";
char*s103_45224899A="Keyword \"until\" expected (in a loop).";
char*s111_1359484467A="(C) #(1) - #(2)";
char*s116_162838175A="se_dump_stack*caller,";
char*s33_30191860A="type_attribute_is_expanded";
char*s116_2753A="]=\173""";
char*s278_1251030042A="End of text expected (invalid ACE file).";
char*s638_851596A=" a1tmp=";
char*s116_900404594A="/* CECIL creation */\n\173""\n";
char*s29_1525604536A="Only the flags -verbose, -version, -help and -relax are allowed in ACE\nfile mode.\n";
char*s33_1673345408A="open_argument_count";
char*s33_954385774A="Pointer_bits";
char*s288_10926944A="prefix \"";
char*s433_1666936074A=" must insert ";
char*s833_1004947005A="g=o->_generation;\n";
char*s116_1089314127A="#ifdef SIGQUIT\n                                                 signal(SIGQUIT,se_signal_handler);\n#endif\n#ifdef SIGILL\n                                                 signal(SIGILL,se_signal_handler);\n#endif\n#ifdef SIGABRT\n                                                 signal(SIGABRT,se_signal_handler);\n#endif\n#ifdef SIGFPE\n                                                 signal(SIGFPE,se_signal_handler);\n#endif\n#ifdef SIGSEGV\n                                                 signal(SIGSEGV,se_signal_handler);\n#endif\n#ifdef SIGBUS\n                                                 signal(SIGBUS,se_signal_handler);\n#endif\n#ifdef SIGSYS\n                                                 signal(SIGSYS,se_signal_handler);\n#endif\n#ifdef SIGTRAP\n                                                 signal(SIGTRAP,se_signal_handler);\n#endif\n#ifdef SIGXCPU\n                                                 signal(SIGXCPU,se_signal_handler);\n#endif\n#ifdef SIGXFSZ\n                                                 signal(SIGXFSZ,"
"se_signal_handler);\n#endif\n";
char*s103_1007106012A="Local name ";
char*s409_2004103151A="Overflow of infix \"+\" with INTEGER_8 operands. (Adding ";
char*s97_672350142A="\nassertion-level: ";
char*s718_1517878904A="GC_gcollect();\nif(GC_should_invoke_finalizers())bdw_run_finalizers();\n";
char*s473_946986142A=" type is not allowed as a variant type.)";
char*s837_236525A="==1)\173""\n";
char*s33_827429162A="type_item_generator";
char*s718_1215237414A="#ifndef GC_DEBUG\n#define GC_DEBUG 1\n#endif\n";
char*s719_444775459A="\173""int i=SE_MAXID-1;\nwhile(i>=0)\173""\nif(t[i]!=NULL)gc_mark7(t[i]);\ni--;\175""\n\175""\n";
char*s336_311661671A="No SEDB objects added.\n";
char*s277_758913190A="Correct part: \"";
char*s833_1020256883A=")bdw_weakref_new(*n);\n*R=M";
char*s33_253393261A="for_object";
char*s116_1040899642A="C Compiler options used: ";
char*s277_319940936A=".... local unique buffer ....";
char*s34_1509818A="General";
char*s112_8976A=".exe";
char*s104_1581369567A="Decimal CHARACTER code out of range.";
char*s103_2137524537A="Inside an \"inspect\" statement for type STRING, the slice notation \"..\" is not allowed.";
char*s719_1246644455A="gc_info();\n";
char*s116_1136523103A="union _se_agent\173""T0 s0;se_agent0 u0;\n";
char*s114_2833A="g++";
char*s430_1529695024A="Invalid manifest equipment (must be greater than 1).";
char*s344_556920526A=" is not a valid redefinition for ";
char*s441_1026844627A="\" (check your ACE file).";
char*s719_567426438A="u->gc_mark_agent_mold=gc_mark_";
char*s112_8991A="/fe=";
char*s637_2217200A="sizeof(";
char*s409_1143055473A=" which is out of range 0..31 because target type is INTEGER_31.";
char*s112_1331737400A="Local Loadpath";
char*s491_76659A="agenT";
char*s116_985140858A="])(void*,char*,int*,int*)";
char*s278_961330339A="Cannot open \"";
char*s638_177459204A="\n#if BYTE_ORDER == LITTLE_ENDIAN\n";
char*s419_936707889A=" not found in type ";
char*s119_612334905A="A frozen feature must not be redefined. What is frozen _is_ frozen.";
char*s112_1431838787A="\" environment\nvariable whatever the kind of your operating system is.\nIf you prefer that way, set the \"";
char*s837_52067A="=c;\n*";
char*s412_1721243342A=" type cannot be used here. Actually this is only a compiler implementation facility.";
char*s103_1207880883A=" Unable to parse definition of `";
char*s116_400297641A="se_local_profile_t*parent_profile,";
char*s637_4204001A="((void*)";
char*s377_2870A="_P_";
char*s116_1746979137A=",expression,/*unknown-position*/0);\n";
char*s116_1591358844A="if(assertion_depth)\173""\nassertion_depth--;\n";
char*s33_52347889A="mark_item";
char*s33_76691A="agent";
char*s110_1574136045A="Finished optimization (";
char*s335_36115402A="All type marks used in a cecil file have to be static (no anchors).";
char*s389_527180488A=" of this Unicode manifest string. ";
char*s116_2883A="i++";
char*s103_1910823336A="\" has been automatically replaced with \"";
char*s837_618166083A="++;\n\175""\n\175""\nn->header.flag=FSOH_UNMARKED;\n";
char*s33_1095772782A="collector_counter";
char*s112_218174A="-s -d1";
char*s637_907447617A=";\nif(o1==o2)\173""\175""\nelse if(NULL==o1)\173""R=0;\175""\nelse if(NULL==o2)\173""R=0;\175""\nelse \173""R=";
char*s116_786180653A="se_frame_descriptor irfd=\173""\"<runtime init>\",0,0,\"\",1\175"";\nse_dump_stack ds = \173""NULL,NULL,0,NULL,NULL,0\175"";\nds.fd=&irfd;\n";
char*s833_1871081731A=";\nif(na)for(i=0;i<c;i++)\173""\ne=na[i];if(e)na[i]=(T0*)HIDE_POINTER(e);\175""\n";
char*s474_1057882626A="Expression of until must be of BOOLEAN type. (The actual ";
char*s285_15195A="_ix_";
char*s33_869539012A="sedb_breakpoint";
char*s615_1728089446A="se_frame_descriptor se_ifd";
char*s637_1671063525A="((uint64_t)(";
char*s86_522142839A="Collecting Cecil features.\n";
char*s833_15205A="o);\n";
char*s116_54734511A="se_prinT[";
char*s650_1691484858A="The export clause is ignored, the redefinition \"feature\" client list will be used instead.";
char*s637_520377520A="((int32_t)(";
char*s33_1574640467A="trace_switch";
char*s112_9073A=".lib";
char*s637_39831A=",NULL";
char*s609_1971245A="closed_";
char*s337_580435889A="Postcondition";
char*s33_48958735A="deep_twin";
char*s103_727272566A="Entity `Current\' is not writable. Cannot use `Current\' for the left-hand side of an assignment.";
char*s106_1377150320A="\'. Maybe the program name is incorrect, or process execution is not yet supported on this platform.";
char*s33_170256464A="FAST_ARRAY";
char*s103_1953566687A="The type mark must be specified just after the \"Precursor\" keyword.";
char*s650_81368369A="The client list computed from the \"export\" clauses is narrower than the one from";
char*s291_624587783A="string_command_line";
char*s124_2947A="fBC";
char*s34_8054609A="Loadpath";
char*s112_9107A=".lnk";
char*s630_101328382A="(/*OUTCA*/";
char*s459_947318471A=" to define a constant.";
char*s719_1230018439A="gc_mark(u->CA_";
char*s112_9121A=".obj";
char*s377_181352A=" from ";
char*s719_497096041A="gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));\n#ifdef FIXED_STACK_BOTTOM\nif (!stack_bottom) stack_bottom=((void**)(void*)(&argc));\n#endif\n";
char*s1006_387651299A=">, module_name <";
char*s637_2118444283A="R=(C->id==a1->id);\nif(R)\173""\n";
char*s116_9130A="=0;\n";
char*s799_1182938696A="a_file_name";
char*s112_2109537640A="...This is a local once buffer...";
char*s32_2057783129A="Feature `deep_twin\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s615_759184012A="rc.next = rescue_context_top;\nrescue_context_top = &rc;\n";
char*s116_374291339A="char* se_atT[";
char*s116_712350300A="init_profile(&atexit_profile, \"<atexit>\");\n";
char*s112_415107A="lcclnk";
char*s103_1775667520A="In an object-oriented language, the receiver of a call is always associated to some existing object (i.e. `Current\' is never Void). Hence, such a weird comparison is not allowed.";
char*s719_679909928A="gc_mark(*(u->CL_";
char*s637_2996A="_t)";
char*s837_998144220A=".store=((rsoh*)(((char*)(";
char*s116_1582839830A="qsort(sorted_all_profile, ";
char*s33_180965424A="INTEGER_16";
char*s377_732402575A=" (magic count = ";
char*s33_180965430A="INTEGER_32";
char*s718_1110320023A="void* bdw_ms[";
char*s377_44462444A="c-type: T";
char*s116_1540564023A="r7from_external_sized_copy(";
char*s116_1281004126A="eiffel_root_object=((T";
char*s116_1450568746A="/* Void call detected in back-end (function called: \173""";
char*s103_188494264A="else of inspect";
char*s116_1982839385A=");\n\175""\nva_end(pa);\nreturn ((T0*)C);\n";
char*s33_11001014A="set_item";
char*s33_180965447A="INTEGER_64";
char*s103_167445550A="Inside a procedure, a Precursor call must be a procedure call (not a function call).";
char*s33_10945665A="print_on";
char*s116_3040A="ci(";
char*s572_1757386798A="se_frame_descriptor gcd=\173""\"Garbage Collector at work.\\n\"\n\"dispose called (during sweep phase)\",0,0,\"\",1\175"";\nse_dump_stack ds = \173""NULL,NULL,0,NULL,NULL\175"";\nds.fd=&gcd;\nds.caller=se_dst;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s104_1708886163A="Invalid free operator (the last character must be a member of this +-*/\\=<>@#\174""& character list.).";
char*s288_1661812564A="Internal Error";
char*s278_2028436769A="The \"case_insensitive\" option is no longer supported.";
char*s116_15351A="base";
char*s650_214672950A="The \"feature\" clause declares a client list that";
char*s33_2174354A="realloc";
char*s615_1111279623A="void**locals[";
char*s650_1961403182A=". This type should be marked as deferred.";
char*s640_2117730851A="**)C)+atoi(attr));\n";
char*s285_15370A="_px_";
char*s119_69115705A="FEATURE_STAMPs total number = ";
char*s112_9220A=".res";
char*s114_3069A="ccc";
char*s284_1492303331A=" is not generic.";
char*s112_9222A=".scf";
char*s103_723705127A="Dot expected here because a manifest-string alone is not an instruction.";
char*s119_1008693261A="Assigner feature is not a command in type ";
char*s278_3073A="all";
char*s33_3075A="and";
char*s103_1922694958A="Replaced misspelled \"Void\".";
char*s278_817932306A=" without point of view!\n";
char*s119_840703310A="\n\nSecond \"inherit\" path (from parent to child):\n   ";
char*s34_3085A="bin";
char*s630_101328511A="(/*OUTCA:`";
char*s34_51843716A="invariant";
char*s116_1145546877A="...........................";
char*s403_1896547075A="assignment attempt (\"\?=\").";
char*s477_1014770470A=":\" not found";
char*s112_3094A="dcc";
char*s615_1125599189A="return((T0*)u);\n";
char*s30_546820847A=". Bad flag ";
char*s114_1663868A="OpenVMS";
char*s35_89216A="split";
char*s640_138425A="\")) \173""\n";
char*s837_15405A="o->_";
char*s475_384465A="basic_";
char*s104_1923039443A="Underscore in number must group exactly 3 digits.";
char*s719_1197879602A="gc_dispose_before_exit();\n";
char*s33_1856946950A="Minimum_character_code";
char*s33_39154229A="PROCEDURE";
char*s125_3115A="s.\n";
char*s103_370754643A="Bad external alias clause.";
char*s103_188014584A="Replaced misspelled \"Current\".";
char*s110_1066764899A="Void target Procedure/Function Call";
char*s837_33875A=");\n\173""\n";
char*s103_1502870799A="Bad empty character constant.";
char*s116_1737592965A="*/: return 1;\n";
char*s103_144939139A=" cannot be used just after agent keyword (it does not denote a feature call).";
char*s103_1409701608A="No more class BIT since release 2.1. Just use bit operations from  INTEGER_8, INTEGER_16, INTEGER_32, INTEGER or INTEGER_64.";
char*s103_1550836304A="Keyword \"class\" expected.";
char*s353_1186844731A="Bad target type. The expected type is ";
char*s380_30745830A="\' is out of INTEGER_32 range.";
char*s430_1134247532A="Found two possible default creation procedures for expanded type ";
char*s116_375072661A="char**se_argv";
char*s833_1278999019A="GC_invoke_finalizers();\nhandle(SE_HANDLE_EXIT_GC,NULL);\175""\n";
char*s756_849265556A=". Please check unicode charts.";
char*s110_298390A="Done.\n";
char*s103_734506354A="Opening \"<<\" of manifest generic creation expected.";
char*s112_721564652A=" NoVersion NoIcons";
char*s33_15448A="call";
char*s385_3147A="cpp";
char*s615_26975282A="(void*)&C";
char*s103_822318035A="Replaced misspelled \"Result\".";
char*s116_756717624A="Procedure without Current";
char*s33_207673214A="force_to_real_64";
char*s103_1926379486A="Ignored extra \",\".";
char*s649_1901947715A="/*[INTERNAL_C_LOCAL list*/\n";
char*s615_26975293A="(void**)&";
char*s488_1329824754A="Using `Void\' as an item of a manifest TUPLE is not good practice because `Void\' has no accurate type. You can work around by using an extra non-initialized local variable of some accurate type. Another work around is to use an explicit creation of the TUPLE. As an example `create \173""TUPLE[STRING,ANY]\175"".make_2(Void,Void)\' can be used to create a TUPLE[STRING,ANY] with default values.";
char*s278_2040665077A="Invalid collect value: must be either yes, no, or \"bdw\"";
char*s116_1811657197A="se_frame_descriptor fd=\173""\"<atexit wrapper>\",0,0,\"\",1\175"";\nse_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=NULL;\nds.exception_origin=NULL;\nds.locals=NULL;\nds.depth=0;\n";
char*s114_3169A="gcc";
char*s33_207673231A="force_to_real_32";
char*s632_3175A="if(";
char*s35_2248290A="version";
char*s34_3175A="end";
char*s637_653639191A="The `deep_twin\'/`is_deep_equal\' problem comes from this attribute.";
char*s119_938738041A="It is useless to undefine this deferred method.";
char*s837_884381655A="*)o)->header.flag=FSOH_MARKED;\n";
char*s719_3181A="elt";
char*s717_146599966A="*)se_malloc(sizeof(void*)))";
char*s719_156962A="(&(u->";
char*s700_46245A=".secd";
char*s104_1452518781A="Expected \"]\" (to finish generic argument list).";
char*s110_689013605A="Expanded Target Function Call";
char*s278_1389956963A="Please, also note that you can use the \"ace_check\" command\nto view all informations stored into your ACE file.\n";
char*s116_36460172A="Defining ";
char*s33_7095298A="FUNCTION";
char*s479_3196A="get";
char*s116_323348966A="se_general_trace_switch=(";
char*s116_2101369329A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_profile+i);\n\175""\n";
char*s33_280482649A="Boolean_bits";
char*s638_3209A="\173""\nT";
char*s637_802840A="))))\174""((";
char*s637_1679626025A="((real64_t)(";
char*s615_3212A="u->";
char*s488_2088401A="make_..";
char*s632_602573626A="\173""int requireresult=1;\n";
char*s347_97896378A=" into formal type ";
char*s110_633144097A="The current directory ";
char*s112_9366A=".txt";
char*s103_1898638542A="Expression expected (\"inspect ... \").";
char*s103_1460213717A="End of manifest array expected.";
char*s104_92397395A="Closing \"\175""\" expected.";
char*s637_1278500877A="((T0*)se_string(";
char*s630_7224500A="INT16_C(";
char*s637_15533A="ceil";
char*s103_1452100558A="No more DOUBLE type mark (update your code). This DOUBLE type mark is automatically replaced with REAL which is actually equivalent to REAL_64. Also consider to use REAL_32 or REAL_80 when you prefer. Also consider command pretty to replace automatically all DOUBLE with REAL.";
char*s103_850458948A="Expression expected after the \"if\" keyword.";
char*s33_421505A="method";
char*s371_336696676A="\") this expression is the ";
char*s752_2068836731A="Overlapping slices. (Wrong inspect statement.)";
char*s103_1389575653A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure using the previous CHARACTER constant as the target).";
char*s484_1088102843A="..........................";
char*s632_4179775A=")->id)\173""\n";
char*s119_2035830473A="\nFEATURE_STAMPs with rename  = ";
char*s103_638895319A="Missing \')\' to end `c_inline_h\' call.";
char*s630_40427625A="UINT16_C(";
char*s337_770157670A="Loop_variant";
char*s832_80501401A="Internal problem while searching for \"mark_item\".";
char*s418_835850355A=".....         local unique buffer          .....";
char*s110_498062040A="#(1)\nOriginal SmartEiffel code:\nCopyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE\nCopyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE\nD.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER, F.MERIZEN\n    http://smarteiffel.loria.fr\n";
char*s543_651043570A="specializing one type";
char*s615_1610470399A="\" is deferred in type ";
char*s837_834589410A="*)o)->header.flag==FSOH_UNMARKED)\173""\n";
char*s615_46337A="=(u->";
char*s278_1811847991A="Non empty unquoted name expected here.";
char*s116_660780608A="void se_prinT9(FILE* file, T9*o)";
char*s33_7704337A="PLATFORM";
char*s116_15589A="argc";
char*s637_1206509635A="o1,o2);\175""\n\175""\n";
char*s112_3291A="int";
char*s112_1346168095A="Unable to find the compiler type of \"";
char*s116_46350A="=1;\173""\n";
char*s33_33120277A="CHARACTER";
char*s719_38305571A="unsigned int rsoc_count_ceil";
char*s112_3294A="lcc";
char*s110_1255397791A="Will generate live type: ";
char*s116_616198177A="switch(((se_agent0*)a)->creation_mold_id)\173""\n";
char*s837_40205A="(o);\n";
char*s110_1928938448A=" formal generic arguments while the maximum allowed is ";
char*s344_70962A="Type ";
char*s116_960414291A="Agent call wrapper";
char*s34_1072344038A="SmartEiffel";
char*s103_1725672511A="Type mark expected after a colon mark inside a local variable list.";
char*s116_2115332211A="\175""\nreturn 0;\n";
char*s124_287218105A=".... unique buffer ....";
char*s103_2008366323A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous CHARACTER constant as the target).";
char*s110_1896793334A="\". This is not possible as this class is basically used by Liberty Eiffel internals. Please pick another name.";
char*s637_83277A="isinf";
char*s837_1316551052A="Unexpected closure on weak_ref\?!";
char*s281_1897894366A="Expanded classes can be inserted only.";
char*s478_1810101146A="Bad external \"C++\" definition.\nexternal \"";
char*s112_3320A="man";
char*s409_276773717A=" which is out of range -15..15 because target type is INTEGER_16.";
char*s472_1050501857A="` in class ";
char*s637_104084395A="((int8_t)(";
char*s573_13424808A="\011""create \173""";
char*s630_15629A="ddt1";
char*s347_83290A="item_";
char*s478_34086A="*)a1)";
char*s638_105695965A=")+a3tmp,((";
char*s650_58505493A="The Precursor routine is a deferred routine.";
char*s103_147793411A="Void is not a valid BOOLEAN expression (just after keyword \"if\").";
char*s34_1223234252A="debug_check";
char*s459_221949868A=" Actually, feature ";
char*s377_3337A="no ";
char*s833_835204573A="void*result=GC_MALLOC_ATOMIC(n*sizeof(bdw_Twr));\nse_check_malloc(result, \"No more memory (GC_MALLOC_ATOMIC failed).\\n\");\nreturn result;\n";
char*s103_1297544492A="\" is not valid keyword.\"";
char*s116_1125599439A="return((T0*)s);\n";
char*s719_259021955A="s=new7();\n";
char*s579_1500847347A="R = R \174""\174"" ((o1->_";
char*s112_150382995A="\"[General] bin\" key is missing.";
char*s286_360205908A="Too many live types (the maximum is ";
char*s380_1731781A="Value `";
char*s103_760340765A="Syntax error while trying to parse the header of routine `";
char*s756_1398420907A=" Missing character number ";
char*s638_129654140A=";\nmemcpy((";
char*s753_89481A="state";
char*s116_511465169A="Compiling routines for ";
char*s371_240593583A="\" (i.e. when the type of Current is \"";
char*s371_611824887A="In the context \"";
char*s615_3374A="new";
char*s484_192265186A="Cannot pass ";
char*s637_83345A="isnan";
char*s30_1102047298A="\" is not allowed when an ACE file (";
char*s103_1109293176A="Void cannot be used after unary \"+\" operator.";
char*s110_292482A="Class ";
char*s33_698215697A="Maximum_real";
char*s110_763853019A="\".\nToo long TUPLE (the TUPLE you want has ";
char*s632_23451005A="/*i*/=0;\n";
char*s116_3393A="lsv";
char*s103_883016350A="Missing \",\" added.";
char*s414_739187517A="Creation call on formal generic type (";
char*s33_89510A="stdin";
char*s33_1297876698A="is_not_null";
char*s116_42279221A="Procedure";
char*s103_1390190909A="An expanded class cannot inherit from other classes, it can only have an \"insert\" clause (replaced).";
char*s632_2024156039A="/*[manifest INSPECT*/\n";
char*s638_1062582514A=")-a3tmp+1)*sizeof(T";
char*s278_1977886A="collect";
char*s34_3415A="old";
char*s669_22122412A=" because ";
char*s114_15721A="dice";
char*s33_3421A="not";
char*s116_5164112A=", agent_profile, ";
char*s637_1338608648A="R=se_deep_twin_search((void*)C);\nif(NULL==R)\173""\n";
char*s833_1808489692A="(void*obj,void*_)";
char*s116_3430A="\175"";\n";
char*s103_2053250287A="\')\' expected to end arguments list.";
char*s632_169510A="++;\n\175""\n";
char*s116_1855175789A="se_profile_t atexit_profile";
char*s112_759424351A=" is not supported as a C++ compiler. I will continue, but expect some problems.\n";
char*s103_2060176323A="Expression expected.";
char*s479_83406A="macro";
char*s33_15751A="code";
char*s107_1449185201A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
char*s110_3451A="\175"".`";
char*s116_2123070311A=", agent_switch_profile, ";
char*s837_1242450095A="if (size<=(";
char*s103_239621812A="Bad create expression (\'\175""\' expected).";
char*s116_3457A="orp";
char*s284_1534075159A=" does not have ";
char*s406_362752532A="Invalid comparison of expression ";
char*s351_1742784741A="Feature found is not a procedure.";
char*s371_1485100899A="..... unique buffer 2 .....";
char*s103_95110222A="Added missing \")\"";
char*s33_3460A="\174""<<";
char*s719_1203674198A="#ifndef FIXED_STACK_BOTTOM\nif(!valid_stack_bottom) stack_bottom = (void**)(void*)&valid_stack_bottom;\n#endif\n";
char*s112_1067454155A="Reading loadpath files\n";
char*s837_46525A=">1)\173""\n";
char*s33_3472A="\174"">>";
char*s112_270309168A="Currently handled compiler names:\n";
char*s33_3474A="pow";
char*s116_3475A="se_";
char*s116_2038260346A="else fprintf(SE_ERR, \"Cannot open profile.se for writing.\\n\");\n\175""\n";
char*s1006_10220290A="function";
char*s630_3485A="vc(";
char*s112_592781506A="Local Cluster";
char*s637_1821634438A="(((se_agent*)C)->u0.eq==((se_agent*)a1)->u0.eq)&&(((se_agent*)C)->u0.eq((se_agent*)C,(se_agent*)a1))";
char*s627_22854451A="/*:RF2*/)";
char*s116_120095614A=";while (i-->0) \173""\nprint_profile(profile_file, sorted_inv_profile+i);\n\175""\n";
char*s33_1418282620A="INTEGER_GENERAL";
char*s615_20240284A="),&(a2->c";
char*s114_3494A="tcc";
char*s116_325655889A="#define SE_SEDB 1\n";
char*s479_3496A="set";
char*s377_1317154036A="live id-field: ";
char*s410_176211197A=" which is of type ";
char*s371_1984383762A="For inspect statement, the expression type can be only INTEGER, CHARACTER, STRING, or FIXED_STRING. (Actually ";
char*s33_3501A="put";
char*s116_1572014572A=";\nwhile (i < imax) \173""\n";
char*s103_46597328A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a function using the previous `True\' constant as target).";
char*s103_1631593164A="Void cannot be the left-hand side of the binary \"*\" operator.";
char*s837_1173325215A="void gc_update_weak_ref_item";
char*s121_253892190A="exceptions";
char*s486_1387816739A="Cannot rename feature `c_inline_h\' because this name is used as a keyword to handle the corresponding \"built_in\" feature of ANY.";
char*s838_136857117A=",(unsigned long)(";
char*s614_1199805276A="fprintf(file,\"\\n\\t[ \");\n";
char*s410_256961544A="The left-hand side of an assignment attempt must not be expanded. (Actually, the left-hand side is of type ";
char*s119_1129671576A="Assigned feature is not a query in type";
char*s91_3520A="ti_";
char*s112_15828A="cpml";
char*s837_1058430701A="o1->header.next=gc_free";
char*s116_1728206941A="((/*UT*/(void)(";
char*s33_15831A="copy";
char*s459_1606367935A="Using a static constant expression just after the \"is\" keyword is suitable only for a constant attribute definition. The constant found (i.e. ";
char*s33_1947246A="bit_set";
char*s29_1767481079A="precompile_header";
char*s110_1225577982A="Reference Target Monomorphic Procedure Call";
char*s103_1522646678A="Missing \'(\' after `c_inline_c\'.";
char*s33_1947251A="bit_put";
char*s719_1713875121A="GC support: generating header.\n";
char*s34_77350A="alias";
char*s103_1931146896A="Bad procedure definition.";
char*s433_1379248421A="Formal generic name appears twice in formal generic list (VCFG.2).";
char*s103_201048978A=" cannot be used just after agent keyword. The type of the target must be given. Consider using the curly braces notation, e.g. `\173""TARGET_TYPE\175""\'.";
char*s794_789213750A=" (kept)\nRedundant definition ";
char*s838_692716864A=".space_used);\n";
char*s630_4622950A="/*NAI*/(";
char*s640_646768902A=";\n\173""\nstatic ";
char*s103_1167481808A=" digits). You must use exactely 2, 4, 8 or 16 digits only. A 2 digits value denote an INTEGER_8, a 4 digits value denote an INTEGER_16, a 8 digits value denote an INTEGER_32, and, finally, a 16 digits value denote an INTEGER_64. (See examples in file \"SmartEiffel/tutorial/hexadecimal.e\".)";
char*s697_1499315956A="No split enabled.\n";
char*s91_1462938943A="NATIVE_ARRAY[NATIVE_ARRAY[...]] is not currently supported by the introspection system.";
char*s567_3557A="tmp";
char*s116_1965730A="break;\n";
char*s104_176469602A="In extended form of manifest string. Bad character before \'%\'.";
char*s278_2100317873A="Unquoted filenames are deprecated. Please add quotes here.";
char*s103_3567A="top";
char*s615_9720A="=CA_";
char*s832_936093505A="native_array_collector_tag";
char*s754_858562A=" _NULL ";
char*s630_23186700A="/*NVND*/(";
char*s717_28273584A=",sizeof(T";
char*s116_357794960A="T0* se_manifest";
char*s103_161325869A="Empty manifest array is not a valid notation. If you want to create an empty ARRAY, just use an ordinary creation call of class ARRAY.";
char*s637_304601115A="signal_exception_number";
char*s719_9980517A="gc_sweep";
char*s34_3595A="sys";
char*s837_1645106999A=",\n(void(*)(mch*))";
char*s478_852437A="*)a1)->";
char*s116_77412A="case ";
char*s34_3601A="use";
char*s97_1229059519A="Bad root procedure name (\"";
char*s116_726227573A="*sizeof(se_profile_t));\nqsort(sorted_profile, ";
char*s116_434116584A="*sizeof(se_profile_t));\nqsort(sorted_agent_profile, ";
char*s719_15915A="if((";
char*s103_1061217192A="Classes with an external type must be expanded or deferred.";
char*s717_1193180751A="s=((T7*)se_malloc(sizeof(T7)));\n";
char*s95_1554312113A=".... local buffer ....";
char*s837_239388241A="n->object=";
char*s615_9775A="=CL_";
char*s33_279523519A="to_pointer";
char*s278_551231644A="Multiple ACE files in the command line: \"";
char*s97_620670284A="\nparent-count: ";
char*s543_965507650A="inlining dynamic dispatch";
char*s116_1065652086A="\173""\nFILE *profile_file = fopen(\"profile.se\", \"w\");\nif (profile_file!=NULL) \173""\nint i;\nse_profile_t sorted_profile[";
char*s719_1549077634A="handle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s632_206626A=";\nelse";
char*s278_3645A="yes";
char*s639_54686040A="return ((";
char*s30_1009954795A="\". Must not use Eiffel source file suffix with option \"-o <executable_name>\".";
char*s718_1527912055A="GC_disable();\n";
char*s116_1723513855A="stop_profile(parent_profile, &local_profile);\n";
char*s34_89771A="trace";
char*s719_961294240A="if(!gc_is_off && !garbage_delayed())\173""\n";
char*s110_2106290588A="Exponent of infix \"^\" must be a positive INTEGER. Exponent actual value is \"";
char*s103_1522646803A="Missing \'(\' after `c_inline_h\'.";
char*s33_577213499A="is_not_a_number";
char*s615_1115628985A="handle(SE_HANDLE_EXCEPTION_SET,NULL);if(SETJMP(rc.jb)!=0)\173""/*rescue*/\n";
char*s103_375534514A="Bad creation instruction (type or \'!\' expected).";
char*s33_3669A="xor";
char*s649_1750246116A="Declared INTERNAL_C_LOCAL: ";
char*s614_1199620901A="fprintf(file,\"\\n\\t  \");\n";
char*s33_911175911A="internals_from_generating_type";
char*s632_1631421108A="/*storage*/=((";
char*s1006_28287A="\" at ";
char*s637_755813960A="]), se_argv[";
char*s278_261396584A="The value of the environment variable \"SmartEiffel\" is:\n\"";
char*s33_169371474A="DISPOSABLE";
char*s286_1539722017A=" correct items).\n";
char*s34_16001A="else";
char*s116_395316170A=" */\nif (expression == NULL) return 1;\n";
char*s33_1947419A="bit_xor";
char*s116_1565125654A="];\nse_profile_t sorted_inv_profile[";
char*s456_1087076085A="Double definition of feature ";
char*s414_581709925A=" is not in the creation list of type ";
char*s719_89821A="store";
char*s116_1773201687A="\n#ifdef __cplusplus\n\175""\n#endif\n";
char*s97_1914699291A="Wrong number of generic argument";
char*s119_429361964A="Can\'t join these two concrete features. What\'s called a concrete feature here is a feature which is not deferred. You may consider to undefine one feature. May be.";
char*s103_1453066751A="Must use exactly 16 hexadecimal digits for INTEGER_64.";
char*s116_56845112A="volatile ";
char*s429_1288915017A="... unique buffer ...";
char*s409_1469170081A="Overflow of infix \"*\" with INTEGER_64 operands. (";
char*s812_1635136368A="\" (resolved as \"";
char*s34_937397683A="The $ operator must be followed by the final name of a feature which is not a constant attribute or by the name of some local variable as well.";
char*s344_1524252299A=". Signature of the redefined feature is not valid.";
char*s337_560316788A="No_more_memory";
char*s33_2218105A="rounded";
char*s112_89862A="strip";
char*s286_411001267A=" in any cluster. Don\'t expect the compilation to succeed.\n";
char*s410_1933023161A=".) Invalid assignment test.";
char*s408_1140411454A="The declaration type of this expression is ";
char*s33_203589551A="manifest_initialize";
char*s637_9905A="C->_";
char*s637_34510A="))\174""\174""(";
char*s632_3760A="\175""\175""\n";
char*s97_510352234A="A class cannot be expanded and deferred (VTEC.1).";
char*s403_1128496981A=" can be assigned into ";
char*s103_407741255A="_inline_agent";
char*s116_22971612A="];\nmemcpy(sorted_profile, profile, ";
char*s753_560556710A="\") in the same inspect.";
char*s409_944882A=" times ";
char*s116_1316373138A="/*se_evobt*/";
char*s615_403595A="u->CA_";
char*s637_2030510390A=",C->_capacity);\n";
char*s110_956422775A="Simplify done";
char*s419_1931700734A="Here is the corresponding feature definition (not an attribute).";
char*s570_638047023A="Call on a Void target in the live code (when the type of Current is ";
char*s278_1737556726A=". The first one is in the cluster \"";
char*s33_275488632A="Maximum_double";
char*s278_2044479327A="\nEiffel class file searching is being done according to the ACE file \"";
char*s35_77608A="cecil";
char*s637_9980719A="if(R)R=r";
char*s125_113009969A=" in file \"";
char*s116_122027336A="init_profile(&prof, \"se_msi";
char*s837_40705A=")n);\n";
char*s34_2593373A="cpp_linker_options";
char*s468_907165587A=" appears at least twice. The client lists will be merged, but please fix the export clauses.";
char*s641_2187411A="se_atT[";
char*s1006_1760616840A="Could not load the plugin; one dependancy is not satisfied: location <";
char*s278_1799491166A="\" in any known cluster.";
char*s441_892969089A="   default assertion (";
char*s110_1194472660A="Reference Target Monomorphic Function Call";
char*s103_1943393816A="Argument name ";
char*s478_9808515A="delete((";
char*s794_65332A="] in ";
char*s615_2187432A="return ";
char*s718_357653724A=")GC_call_with_alloc_lock((GC_fn_type)bdw_weakref_getlink,(bdw_Twr*)(";
char*s615_403650A="u->CL_";
char*s754_16139A="il2@";
char*s104_372047073A="Deleted extra separator.";
char*s669_1864907075A="To many actual arguments for agent call. (The agent you are trying to call has no arguments.)";
char*s33_440571A="target";
char*s103_2082787810A="Error while reading a real. Missing \"\175""\" \?";
char*s110_388205767A="Total Number of \"inspect\" used for Dynamic dispatch: ";
char*s33_1604522960A="to_integer_8";
char*s833_888029880A="c=o->_capacity;\n";
char*s288_2064444A="infix \"";
char*s33_2187464A="se_argc";
char*s116_697705640A="sorted_all_profile[";
char*s286_188525860A="Corrupted *.id file (after ";
char*s34_49076540A="assertion";
char*s276_1587749191A="Aliased STRINGs: ";
char*s112_143937264A="-subsystem";
char*s110_1131498768A=" does not belong to any known cluster.";
char*s278_452889A="system";
char*s116_1450791030A="[hc]\" not found).";
char*s839_1411018665A=".store_left=0;\n\175""\n";
char*s430_2134616155A=" is expanded).";
char*s406_333554149A="Such a weird comparison with Void is not allowed because it would be always ";
char*s116_397592212A="\",1\175"";\nse_dump_stack ds;\n";
char*s35_16177A="help";
char*s406_461679483A="Cannot compare an expanded expression with a reference expression.";
char*s33_2187483A="se_argv";
char*s638_1502256459A="]),&a1tmp,sizeof(T";
char*s111_905363427A="2014.dev (Alexander Graham Bell)";
char*s613_11241768A="struct S";
char*s34_59251A="False";
char*s288_1224218969A="The source lines involved by the message are the following:\n\n";
char*s288_1750778A="Warning";
char*s111_2107398012A="\nLiberty Eiffel The GNU Eiffel Compiler, Eiffel tools and libraries\n    release #(1)\n\nCopyright (C), #(2) - #(3)\n    http://www.liberty-eiffel.org\n";
char*s106_745978733A="\' is defined more than once";
char*s837_384078512A="\173""rsoh*h=((rsoh*)o)-1;\nif((h->header.magic_flag)==RSOH_UNMARKED)\173""\nh->header.magic_flag=RSOH_MARKED;\n\173""\n";
char*s110_2045223723A="Cannot collect feature \173""";
char*s669_191115496A=". Its type is ";
char*s116_522691310A="ds.caller=NULL;\nds.exception_origin=NULL;\nds.locals=NULL;\n";
char*s109_1442714837A="Assignment graph: ";
char*s112_1056930268A="You can also have a look at http://liberty-eiffel.blogspot.com/wiki/index.php/";
char*s638_2187545A="se_die(";
char*s103_1687580001A="Void is not a valid expression inside \"when\" part of an inspect statement.";
char*s103_1301660112A="Bad formal arguments list.";
char*s116_1266427187A="if (!prof_init)\173""memset(&prof,0,sizeof(prof));prof_init=1;\175""\n";
char*s493_455005721A="Same type appears more than once.";
char*s116_1136118256A="............ unique buffer ...........";
char*s474_779913846A="Error in until part of loop definition.";
char*s375_389128515A=" Cannot assign Void into ";
char*s650_7440512A="Feature ";
char*s637_77767A="ceilf";
char*s116_2060090728A="fprintf(file, \"NATIVE_ARRAY[CHARACTER]#%p\\n\",(void*)*o);";
char*s278_641030424A="Non empty quoted string expected here.";
char*s637_77773A="ceill";
char*s837_1869083728A="void gc_update_weak_ref_item_polymorph(Tgc* item)";
char*s34_16264A="from";
char*s34_9790205A="deferred";
char*s611_1476287022A="typedef T0 T";
char*s833_646707803A=")se_malloc((*n)*sizeof(T";
char*s103_99041221A="\' instead.";
char*s837_1847665958A="=o1;\n\175""\n\175""\nif(dead)\173""\ngc_free";
char*s630_7225250A="INT32_C(";
char*s630_2187584A="se_cmp1";
char*s630_2187585A="se_cmp2";
char*s34_265093627A="loop_check";
char*s116_1234811086A="memcpy(sorted_all_profile, profile, ";
char*s408_435568604A="\"if\" (or \"elseif\" as well) must be followed by a BOOLEAN expression.";
char*s719_34749A="*)new";
char*s32_635943583A="Feature `is_deep_equal\' not found in class ANY. Really, you should not try to write or modify the ANY class provided with Liberty Eiffel.";
char*s104_175744216A="Added \"(\".";
char*s116_700572143A="init_profile(inv_profile+";
char*s33_1223936132A="deep_memcmp";
char*s630_40428375A="UINT32_C(";
char*s337_1207039342A="Void_attached_to_expanded";
char*s409_511502716A="Cannot divide ";
char*s33_37186806A="NATURAL_8";
char*s812_1847764413A="Cycle detected:\n";
char*s615_2187619A="se_cmpT";
char*s632_809795A="((T0*)(";
char*s377_4488096A=" feature";
char*s615_208313786A="ds.caller=caller;\n";
char*s104_175744241A="Added \")\".";
char*s33_77832A="blank";
char*s278_1667312535A="Cluster path expected after cluster name.";
char*s278_90141A="wedit";
char*s397_1814961148A="Unused local variable.";
char*s459_161769183A=") cannot be used as the definition of the feature ";
char*s373_432936020A="Cannot find Base Class for ";
char*s116_889346373A="global_profile=local_profile;\n";
char*s116_4980205A=",NULL);\n";
char*s103_872019014A=" or the whole expression as well. It\'s up to you to decide now.";
char*s119_7612837A="In type ";
char*s337_41769343A="Os_signal";
char*s278_1984169029A="Cannot find the class \"";
char*s103_1476889913A="Empty list not allowed for manifest generic creation.";
char*s719_2039472678A="stack_bottom=((void**)(void*)(&argc));\n";
char*s573_26108906A="Unknown feature name ";
char*s33_65574A="TUPLE";
char*s33_197002151A="force_to_natural_64";
char*s632_440120430A=")->_storage_lower;\n";
char*s719_533301931A="void(*gc_mark_agent_mold)(se_agent*);\n";
char*s638_388821092A="Class NATIVE_ARRAY has been tampered with. Unknown procedure: ";
char*s103_1160088831A="\" cannot be a valid class name (only upper case letters are allowed in class names). \"";
char*s103_902126A=" first.";
char*s632_2089246593A="if(requireresult)\173""\n";
char*s637_234855416A="_t)(((uint";
char*s33_550709268A="NATIVE_ARRAY_COLLECTOR";
char*s116_253935823A="];\nse_profile_t sorted_agent_profile[";
char*s97_1468715266A=". This creation call is thus not allowed.";
char*s33_197002168A="force_to_natural_32";
char*s103_732932648A="Load class \"";
char*s615_657822788A="ds.fd=&se_ifd";
char*s632_2353775A="\175""else\173""\n";
char*s104_1836169859A="Unexpected character in hexadecimal unicode.";
char*s34_434665A="option";
char*s104_175744316A="Added \",\".";
char*s116_2060613700A="T0*se_string(";
char*s419_626532654A="This feature name is not an expression (no result and not writable).";
char*s33_197002174A="force_to_natural_16";
char*s478_397949195A="\"\n_________";
char*s405_1543474532A="Actually, `Void\' has no accurate type. Keep in mind that `Void\' is just a way to denote the default value for a type or to denote the lack of an object. One can use `Void\' as the left-hand-side of an assignment or to replace some actual argument. (See \"http://liberty-eiffel.blogspot.com/wiki/en/index.php/Void\" for details.) At time being, the type ANY will be used for this occurrence `Void\'. Please update your code with a more accurate expression, may be by adding an extra non-initialized local variable.";
char*s402_647790517A="This variable is used in a closure. Beware, each time the method is called, a lot of memory may be wasted.";
char*s116_2114508771A="int c,char*e)";
char*s278_1805205737A="Files are being searched for in the following list of clusters (";
char*s33_573080478A="raise_exception";
char*s406_2089449608A="An expanded value can be compared only with the same other expanded value. Expression ";
char*s756_1139569132A="Invalid byte in UTF-8 sequence. This character is  number ";
char*s112_1832417772A="Bad use of command `";
char*s638_84085A="\174""(1<<";
char*s103_1732402521A="Instruction expected.";
char*s835_742356016A="typedef struct B";
char*s632_47187A="==0) ";
char*s609_1152812249A="/* Extra external prototype for line ";
char*s119_1248054333A="Add undefine or redefine to all inherited version of feature ";
char*s33_53339A="ARRAY";
char*s30_1335263213A=": missing file name after -cecil flag.\n";
char*s719_1085305030A="gc_align_mark";
char*s286_838840612A="Previous IDs reloaded (max_id = ";
char*s109_1616517694A="destination-graph-nodes: ";
char*s611_1476281050A="typedef uint";
char*s579_742356033A="typedef struct S";
char*s833_1456062714A=",NULL,NULL,NULL);\no->bdw_markna=(void*)HIDE_POINTER(markna);\n*markna=(T0*)o;\nGC_GENERAL_REGISTER_DISAPPEARING_LINK(&(o->bdw_markna),markna);\nbdw_in_assign=0;\nGC_enable();\nif(bdw_delayed_finalize)\173""\nbdw_delayed_finalize=0;\nreturn NULL;\175""\175""\nreturn o;\n";
char*s33_49076823A="clear_all";
char*s116_1858528797A="\n(fprintf(SE_ERR,\"%s\\n\",";
char*s615_1949908058A="*u=(void*)new_agent(";
char*s116_10940631A="se_evobt";
char*s717_870210728A="fprintf(SE_ERR,\"No GC compiled in, no information available\\n\");\n";
char*s110_218672210A=".............. once unique buffer ......................";
char*s441_397660162A="   exclude ";
char*s30_375350487A=": the \"-case_insensitive\" flag is no longer supported.\n";
char*s112_1361085152A="@linkit.com\ndelete linkit.com;";
char*s719_1403828457A="store_chunk";
char*s482_1610077639A=" open operand expression is out of \"agent\" keyword scope.";
char*s116_16487A="int ";
char*s103_398318341A="\' does not fit on INTEGER_64).";
char*s347_731327330A="Agent calls need a tuple!";
char*s104_595894613A="Unexpected character in decimal ascii code.";
char*s103_1174611449A="Separator expected to end hexadecimal constant.";
char*s753_2027238465A="Only manifest strings are accepted in \"when\" clauses of \"inspect\" (in order to ensure that the STRING won\'t change at runtime). Note that even a constant of type STRING can have its content changed at runtime.";
char*s833_718028873A="int i,c,g;T0*e;T0**na;T";
char*s34_78002A="check";
char*s371_165601417A="CHARACTER ";
char*s756_1927020241A="Invalid unicode value: 0x";
char*s344_1246984134A=") this type mark is resolved as ";
char*s718_1062817045A="GC support (root functions).\n";
char*s116_1617526527A="se_dump_stack ds;\nds.fd=&fd;\nds.p=0;\nds.caller=caller;\nds.exception_origin=NULL;\nds.locals=NULL;\nds.depth=0;\n";
char*s632_16510A="\175""\n\175""\n";
char*s33_1202672333A="with_capacity";
char*s103_897447412A="Cannot use ";
char*s112_19761224A=" Data=Far";
char*s116_1201497496A="*C;\nva_list pa;\nint i=0;\nint imax;\nva_start(pa,argc);\nC=";
char*s812_1959331451A="Empty loadpath: \"";
char*s837_1990989A="if(((gc";
char*s103_521861207A="The convert support is EXPERIMENTAL (work in progress).";
char*s116_5367889A="*eiffel_root_object";
char*s103_586311386A="Bad creation instruction (\'!\' expected).";
char*s615_422487A="locexp";
char*s116_47278A="==0)\173""";
char*s103_1093012317A="Second identifier of a \"rename\" pair expected.";
char*s640_41131A=";\n_r=";
char*s103_1437345301A="Syntax error while trying to parse the beginning of a new feature definition. Feature name expected. Class name ";
char*s1006_2072196164A="The default key \"function\" was not found. Invalid auto_init file.";
char*s33_1744612358A="is_basic_expanded_type";
char*s103_1759774576A="You are probably trying to use the new inherit/insert mechanism. With Liberty Eiffel, this can be achieved thanks to the new \"insert\" clause. The new \"insert\" clause comes just after the traditional \"inherit\" clause with a similar syntax.";
char*s450_1118729658A="When the context of the validation is ";
char*s116_2096892436A="p[0]=\"\?\?\?\";\n";
char*s640_1659544035A=");\nR=&_r;\n\175""\n";
char*s103_4235A=" \011""\000""\n";
char*s110_1610926534A="Void target Procedure Call";
char*s103_1154110220A="Cannot use anchored type mark definition as a valid parent.";
char*s277_956361723A="Remainder: \"";
char*s116_1110850242A="fprintf(profile_file, \"\\n===============================================================================\\n\");\n";
char*s116_1377391529A="Executable is up-to-date (no C compilation, no linking done).\n";
char*s637_884813300A=";\nT0*o2=a1ptr->_";
char*s637_4881995A="->id)==(";
char*s116_1197714671A="(T0* expression)";
char*s632_840791A="((void)";
char*s104_543076045A="Type mark expected.";
char*s719_280766651A="store_left";
char*s106_42698349A="The key \'";
char*s700_928596125A="\" not changed.\n";
char*s116_246893097A="v=ac_lvc(c++,v,";
char*s116_1911279888A=")));\nC[i]=element;\ni++;\n\175""\nva_end(pa);\nreturn C;\n";
char*s403_332834879A="forced assignment (\"::=\").";
char*s377_78082A="dead ";
char*s112_1223801083A="Selecting C++ compiler: ";
char*s410_1907958363A=". (This assignment test is always True.)";
char*s484_94643563A=" is deferred. (Cannot create object.)";
char*s637_17743770A=")\n#endif\n";
char*s116_1964848975A="start_sumup_profile(profile_file);\ni=";
char*s718_871385705A="GC_dump();\n";
char*s103_688657949A="Empty \"when\" clause in \"inspect\" statement.";
char*s34_90408A="until";
char*s837_1314337673A=".store_left))\173""\nrsoh*r=";
char*s104_1242149539A="Right hand side expression of := assignment expected here.";
char*s33_7748406A="REAL_128";
char*s527_840796792A="Empty manifest array not allowed. (If you really need to do it, just replace it with something like:\ncreate \173""ARRAY[ANY]\175"".make(1, 0)";
char*s630_3934795A="(((T0*)(";
char*s719_4308A="\011""id:";
char*s337_198146473A="Class_invariant";
char*s103_126038302A="Writable entity expected here (`Current\' is not writable).";
char*s33_16616A="last";
char*s112_2121681051A="Unknown C++ compiler type \"";
char*s630_36122993A="INT16_MIN";
char*s833_182705A="0*));\n";
char*s409_1718483009A="Overflow for opposite of Minimum_integer_8.";
char*s34_16630A="jobs";
char*s103_494839979A="Empty argument list (deleted).";
char*s106_1784452489A="Could not execute \'";
char*s34_10208843A="external";
char*s34_56255230A="undefined";
char*s112_725963810A="\". Please fix your configuration file or choose another C mode.";
char*s33_16639A="item";
char*s33_78150A="atan2";
char*s103_2016523575A="In compound (";
char*s450_1888871872A="TUPLE type expected for open arguments of agent type. (See also the next fatal error message.)";
char*s34_1730514379A="cpp_compiler_options";
char*s501_1879799154A="Must not use old inside some old expression (VAOL.2).";
char*s632_1553642381A="default: error1(\"Invalid ::= assignment (inserted type).\",";
char*s678_1166590709A="Deferred feature must not have rescue compound.";
char*s837_1396798042A=".store_left-=size;\nif(";
char*s33_705019679A="die_with_code";
char*s33_1339128A="BOOLEAN";
char*s33_451899881A="type_attribute_name";
char*s114_59731A="Elate";
char*s541_2014364610A="run-time-set:\n";
char*s112_39204698A="SCOPTIONS";
char*s112_61342149A="No information available about the system used (check your\nLiberty Eiffel installation).\n";
char*s103_768172015A="Hexadecimal digit expected while reading CHARACTER constant.";
char*s477_1979303915A="\":\" expected";
char*s637_17743865A=")\n#else\n(";
char*s347_416499A="item_1";
char*s104_1226144723A="Variable `Result\' is valid only inside a function.";
char*s347_416500A="item_2";
char*s371_61858840A=" which is not allowed.)";
char*s33_16686A="make";
char*s837_1279738389A="++;\n\175""\nelse\173""\nc=gc_fsoc_get1();\nif(";
char*s365_881547256A="Cannot use here a manifest STRING because the previous one used in this \"inspect\" statement is not a manifest STRING.";
char*s35_385751A="c_mode";
char*s838_666336072A=")\nfprintf(SE_GCINFO,\"%d\\t%lu\\t%d\\t";
char*s838_41300A=";\nif(";
char*s699_355003A="][0-9]";
char*s754_78209A="ddt1@";
char*s833_1037766A="(int n)";
char*s116_561301605A="*/: error2(expression,/*unknown-position*/0);break;\n";
char*s116_988839165A="se_frame_descriptor root=\173""\"<system root>\",1,0,\"";
char*s380_31214580A="\' is out of INTEGER_16 range.";
char*s637_106047655A="),a1ptr->_";
char*s278_2085574777A="external_lib";
char*s112_84381A="mieee";
char*s278_416541A="legacy";
char*s632_4425A="\nif(";
char*s614_1511378937A="fprintf(file,\"#%p\",(void*)*o);\n";
char*s33_90544A="upper";
char*s116_280139425A="uint16_t s";
char*s403_29037A=" ::= ";
char*s718_255799920A="GC_invoke_finalizers();\nhandle(SE_HANDLE_EXIT_GC,NULL);\n";
char*s756_888288799A="Overlong sequence, must be refused by any UTF-8 complient decoder for security reasons.";
char*s34_427898753A="# Beginning of parallelizable section";
char*s632_847125A=");\nif (";
char*s637_111269879A="R=se_deep_equal_search(C,a1);\n";
char*s375_1881300092A="Assignment of a reference type into an expanded type is not allowed. ";
char*s344_2084824380A=" (More explaination below.)";
char*s277_988261007A="Bad external signature (missing opening \"(\" delimiter.";
char*s116_1240218271A="se_argc=argc;\nse_argv=argv;\n";
char*s104_175744666A="Added \":\".";
char*s701_1085938891A="By-type splitter enabled.\n";
char*s544_32450971A="C:\\SE.CFG";
char*s544_311952415A="liberty-eiffel";
char*s630_920950A="/*IC*/(";
char*s34_78263A="debug";
char*s632_958274895A="!=NULL)\173""error1(\"Invalid ::= assignment (inserted type).\",";
char*s638_804085A="&(\176""(1<<";
char*s116_561947515A=" element=((";
char*s34_16761A="like";
char*s752_786403659A="Internal error inside WHEN_ITEM_2 (compiler error).";
char*s103_1559455194A="Expression \"old\" can be used in ensure clause only (VAOL.1).";
char*s116_21391495A=",((void)(";
char*s104_175744691A="Added \";\".";
char*s103_1421961899A="The basic = operator cannot be redefined. (This is a hard-coded builtin that we must trust.)";
char*s358_1479430694A="This call has no result.";
char*s441_597973944A="Could not load class in cluster ";
char*s116_16782A="link";
char*s34_84443A="local";
char*s693_161074567A="<Universe>";
char*s414_182862A=" into ";
char*s110_1914558593A="The root class must not be expanded (sorry, but this is a limitation of the compiler).";
char*s110_1450022771A="Unknown feature `";
char*s615_430519127A="ds.locals=locals;\n";
char*s103_611217054A="Error in constant or manifest creation.";
char*s403_138555764A=" by using an ordinary \":=\" assignment ";
char*s112_1615398571A="..................................";
char*s779_1400894751A="... once unique buffer ..................................";
char*s107_1880881887A="................";
char*s756_263008962A=" bytes sequence.";
char*s33_839855894A="TEXT_FILE_WRITE";
char*s103_1075925125A="Must not use local variable in ensure assertions (VEEN).";
char*s103_488830629A="Void cannot be the left-hand side of infix operator \"";
char*s344_2050169721A="In the parent context (i.e in ";
char*s637_1174230416A="_t)((((uint";
char*s110_1661328107A=". Yours is in the cluster \"";
char*s33_2126626A="or else";
char*s116_179423058A="if(ds.fd->assertion_flag)\173""\nds.fd->assertion_flag=0;\n";
char*s110_42846255A="No such TUPLE definition in file \"";
char*s403_1816745449A="::= assignment (a forced assignment).";
char*s477_56907446A="type_name";
char*s719_614557109A="/*NON_VOID_NO_DISPATCH:*/\n";
char*s477_10559665A="location";
char*s579_1208522276A="typedef int T";
char*s719_1215177661A="\173""int i=SE_MAXID-1;\nwhile(i>=0)\173""\nif(g[i]!=NULL)gc_mark7(g[i]);\ni--;\175""\n\175""\n";
char*s119_576322499A=" cannot be an assigner of the feature ";
char*s409_1592935176A=" which is out of range 0..7 because target type is INTEGER_8.";
char*s33_324411A="STRING";
char*s33_1739790308A="type_generator";
char*s97_15142174A="Bad root class (this class has no creation clause).";
char*s637_195246A="->id))";
char*s579_1502207936A="R = R \174""\174"" se_cmpT";
char*s703_1345295929A="Multiple rename for the same feature is not allowed.";
char*s112_149455415A="Unknown compiler type \"";
char*s637_1605175681A="se_deep_twin_start();\n";
char*s110_22271191A=" argument";
char*s459_375578482A="Value out of INTEGER_8 range.";
char*s615_948421114A=";\nds.current=((void*)&C);\n";
char*s615_35330A=" afp_";
char*s119_784841421A="Unable to solve cyclic anchored types.";
char*s103_107634778A="Because of the usual low priority of prefix minus, `-foo.bar\' is actually equivalent to `-(foo.bar)\'. In order to avoid a possible mistake here, it is mandatory for you to add extra parentheses here. You can wrap ";
char*s409_350193314A="Overflow of infix \"-\" with INTEGER_64 operands. (";
char*s719_269141588A="\173""/*mark_item*/\n";
char*s106_1043946153A="Unexpected text continuation";
char*s112_1515266530A="You must choose either -cc or -c_mode, but you cannot use them both.";
char*s116_1065942137A="print_profile(profile_file, &root_profile);\n";
char*s103_104977558A="Inline agent or expression expected after agent keyword.";
char*s125_1662662954A="SmallEiffelDirectory";
char*s406_401707956A=" is obviously expanded (i.e. the written type mark is \"";
char*s478_16902A="new ";
char*s430_1878889060A="Feature `manifest_make\' must have at least one INTEGER argument.";
char*s116_18131599A="se_dump_stack*,";
char*s544_1185594A="/sys/rc";
char*s837_784300160A=";\no2=o1+c->count_minus_one;\nfor(;o1<=o2;o1++)\173""\nif((o1->header.flag)==FSOH_MARKED)\173""\no1->header.flag=FSOH_UNMARKED;\n";
char*s33_243411981A="bit_rotate";
char*s33_1419919903A="Maximum_character_code";
char*s103_2102385657A="Empty Cecil file (use -verbose flag for details).";
char*s409_211605167A="Overflow of infix \"-\" with INTEGER_8 operands. (";
char*s103_762747069A="\"retry\" cannot be outside of a rescue clause.";
char*s112_466551816A="$ link/exe=";
char*s112_2009849A="generic";
char*s116_1743948446A="==2, \"Recursive once function.\");\n\175""\n";
char*s839_1682659883A=".chunk_list=NULL;\n";
char*s837_1007239A="*b=((gc";
char*s796_630125369A="**** Fatal error: no $#(1) defined!";
char*s103_2028592127A="Removed unexpected blank space(s) just before this dot (assume you really want to call a procedure using the previous manifest expression as the target).";
char*s97_1838187926A="class-name: ";
char*s478_1163823042A="\nSee SmartEiffel/tutorial/external/C++ directory for more information.\n (Internal state = ";
char*s796_17725666A="#(1)/#(2)";
char*s33_1770803725A="from_external_sized_copy";
char*s34_16942A="loop";
char*s753_989731302A="Second occurrence of this value (\"";
char*s403_897982986A=" (\"\?=\" is not necessary).";
char*s110_1783880762A="Collecting done";
char*s833_1038016A="(int*n)";
char*s34_10049231A="generate";
char*s632_206419907A="fd.assertion_flag=1;\nfree_exception_frames();\n";
char*s837_931143030A="=n->header.next;\n\175""\nelse\173""\nif(c==NULL)c=gc_fsoc_get2();\n";
char*s627_810433A="(/*RF2:";
char*s281_1973946666A="TUPLE type expected for open arguments of agent type.";
char*s103_1062177790A="Extra \",\" ignored.";
char*s1006_1994165009A="No support found for this external \"plug_in\" (plugin: \"";
char*s615_46733806A="static se_frame_descriptor fd=\173""";
char*s281_1838870713A=" has two conflicting external types";
char*s632_1008067448A="internal_exception_handler(";
char*s110_485115581A=" (magic_count=";
char*s474_2101296982A=" type is not allowed.)";
char*s837_90782A="void ";
char*s1006_1508488213A=" defined in ";
char*s632_20481355A=") break;\n";
char*s645_90792A="void*";
char*s34_78490A="class";
char*s35_78495A="clean";
char*s112_146157A=" /link";
char*s719_1428771266A="void  gc_info(void)";
char*s347_931579788A="Cannot pass Void as argument (the formal type is expanded).";
char*s1006_1942675017A="Including source ";
char*s637_252669317A="((void*)a1);\n";
char*s33_41849945A="Real_bits";
char*s125_27561173A="Trying to read file \"";
char*s116_1533928773A=".......................................";
char*s812_2007377394A="Unknown loadpath";
char*s104_1658160521A="Expected \"[\" (to start generic argument list).";
char*s637_933501A="(NULL!=";
char*s479_1136691048A="\"set\", \"get\", or \"access\" keyword expected.";
char*s116_1170250908A="(/*UA*/((void)(";
char*s377_35157672A="Adapting ";
char*s103_1436398529A="Keyword \"loop\" expected (in a loop).";
char*s717_1657834530A="Compiling without Garbage Collector!\n";
char*s833_1619999729A="void bdw_weakref_setlink(bdw_Twr*wr,T0*r)";
char*s637_626047338A="((T6)((C->id==a1->id)\?!memcmp(C,a1,sizeof(*C/*";
char*s33_447584A="stderr";
char*s103_1414519430A="Error while reading fractional part of a real value (digit expected after the dot).";
char*s116_1404148845A="parent_profile,";
char*s116_958964069A=" agent wrapper: ";
char*s640_90405963A="*id=(*((T0**)R))->id;\n";
char*s486_439056951A="New name and old name must be different.";
char*s353_767649523A="..... unique target buffer .....";
char*s33_1554777A="POINTER";
char*s17_1216703285A="Some feature is not yet implemented (i.e. feature `not_yet_implemented\' of\nclass ANY has been called somewhere). Just run this code under the debugger\nto know the `not_yet_implemented\' caller.\n\nThe error occured in the type";
char*s457_22861847A=" insert: ";
char*s116_530940601A="\" (i.e. file(s) \"";
char*s116_724500276A="((/*agent*/void*)a)";
char*s482_1723490337A=" open operand cannot be the target of an agent call.";
char*s116_2109816196A="int argc,...)";
char*s33_591417242A="standard_twin";
char*s637_10895A="EIF_";
char*s103_2096474678A="**** Found potentially assignable expression";
char*s1006_1439959996A=">. Strange dependency!";
char*s646_11205716A="uint32_t";
char*s718_1061058398A="(GC_get_heap_size())";
char*s637_10430693A="isnormal";
char*s110_445497083A="Finished inlining of dynamic dispatch.\n";
char*s837_176986A="--;\nn=";
char*s116_997623147A="),\nfprintf(SE_ERR,\"-manifest_string_trace: line ";
char*s615_1623721137A="... once unique buffer ...";
char*s116_2055072316A="(T7*)se_string(";
char*s112_631091213A="\"[General] flavor\" key is missing.";
char*s33_1735712398A="object_as_pointer";
char*s837_73472312A="(&(o1->object));\n";
char*s97_625881326A=" is a generic class (missing actual generic";
char*s34_78591A="boost";
char*s632_379993A="ac_civ";
char*s717_1750560930A="se_malloc(1)";
char*s110_1224226011A="C.ADRIAN, P.REDAELLI, R.MACK";
char*s409_163270777A=" which is out of INTEGER_32 range.)";
char*s380_561523426A="...........";
char*s410_1490189105A=" while expression ";
char*s344_1060258809A="Incompatible number of arguments.";
char*s278_2108992007A="external_c_files";
char*s33_1192911276A="object_memory";
char*s103_631447998A="Must use exactely two hexadecimal digit for a CHARACTER constant.";
char*s34_10990481A="separate";
char*s637_1514442508A="((void*)(&a1));\n";
char*s103_1632732392A="Slash (\"/\") expected (inside CHARACTER constant).";
char*s33_167970159A="TEXT_FILE_READ";
char*s116_1253959973A="Function without Current";
char*s611_565060278A="/* C Header Pass 1: */\n";
char*s637_78629A="ds.p,";
char*s110_1605895597A="\" redefined as \"";
char*s106_126291003A="Bad program.\n(Closing \")\" not found.)";
char*s278_1658492806A="\" file.\nACE file not found.";
char*s33_48856070A="arguments";
char*s33_1622700141A="deep_twin_from";
char*s615_1694771411A="typedef struct _se_";
char*s116_78646A="ds.p=";
char*s284_722230651A=" which is actually already renamed as ";
char*s615_404651A="u->eq=";
char*s630_8087250A="UINT8_C(";
char*s632_119389596A="/*state*/=";
char*s103_1453916708A="Unexpected \";\" to end rename list (deleted).";
char*s103_844703215A="Infix operator name expected.";
char*s116_2237652A="static ";
char*s30_1364794873A="Unable to remove existing the file \"";
char*s410_1256137461A="Invalid assignment test. The left-hand side expression must conforms with the right-hand side. The left-hand side is of type ";
char*s650_1465905014A=" is deferred in type ";
char*s106_618869258A="Inserted \':\'";
char*s29_1852009437A=": missing C mode name after -c_mode flag.\n";
char*s104_174945438A="Error inside multi-line manifest string.";
char*s35_1777434714A="safety_check";
char*s103_501268295A=" to rename a feature. (Feature name expected.)";
char*s632_380065A="ac_ens";
char*s110_313299890A="Cannot load root class ";
char*s614_605650769A=" = \");\nse_prinT";
char*s103_1950357785A="End of TUPLE expression expected.";
char*s103_2077708091A="Unable to find the feature name which is mandatory just after the \"frozen\" keyword.";
char*s675_1760457965A="require else";
char*s116_850522083A="init_profile(&runinit_profile, \"<runinit>\");\n";
char*s112_447734A="wcc386";
char*s116_824324978A="se_introspecT[";
char*s358_793028699A="Feature found is a procedure.";
char*s414_2007408328A=" which is a simple and predefined expanded type.";
char*s34_17176A="none";
char*s406_1090404950A=" result.) (VWEQ)";
char*s337_1492212881A="System_level_type_error";
char*s696_78239462A="Classes path set more than once";
char*s103_2141291014A="Empty formal argument list (deleted).";
char*s650_1548937422A="Keyword \"require else\" replaced with \"require\" (There is no inherited require assertion here).";
char*s34_17206A="note";
char*s125_210141519A="Renaming \"";
char*s34_2065491A="inherit";
char*s613_565066528A="/* C Header Pass 3: */\n";
char*s116_27063164A="init_profile(agent_switch_profile+";
char*s638_1719326284A="\173""/*dumb copy*/";
char*s125_349372A="Total ";
char*s116_106460275A="*)a)->afp(";
char*s544_1722217257A="C:\\LIBERTY.CFG";
char*s33_84881A="low_8";
char*s34_17221A="once";
char*s116_1917882A="agents ";
char*s403_1424594977A="The expression ";
char*s839_576790349A=".store_left>0)\173""\n";
char*s112_129391217A="\" does not contain name of a valid file.\n";
char*s33_2038667775A="like Current";
char*s752_1762204931A="Not a good slice. The lower bound (";
char*s837_1497878015A=";\nif(gc_find_chunk(na)!=NULL)\173""/* non external NA */\n   rsoh*h=((rsoh*)na)-1;\n   if((h->header.magic_flag)==RSOH_UNMARKED)\173""\n      h->header.magic_flag=RSOH_MARKED;\n";
char*s103_2127445170A="Character \'%\"\' inserted after \"prefix\".";
char*s33_50246319A="generator";
char*s278_926093361A="The valid values for split are either \"legacy\" or \"by_type\".";
char*s543_1134353920A="safety checking";
char*s632_1898591066A="creatinstexp";
char*s116_545118879A="Precursor routine";
char*s632_380168A="ac_inv";
char*s103_23410A=" \011""[\000""\n";
char*s116_508495830A=").\",NULL);\n";
char*s837_77562923A="(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;\n";
char*s459_1790874766A="The type of this constant feature should be INTEGER or REAL.";
char*s371_7238542A="INTEGER ";
char*s103_469031018A="Expression expected after \"old\".";
char*s719_453998A="void X";
char*s637_1671077900A="((uint16_t)(";
char*s632_1952787551A="\173""int c=0;int v=0;\n";
char*s837_1739163321A=";o1++)\173""\nif((o1->header.flag)==FSOH_MARKED)\173""\no1->header.flag=FSOH_UNMARKED;\n";
char*s33_447851A="stdout";
char*s281_689575137A="Cyclic inheritance graph: ";
char*s484_29585A=" >> \175""";
char*s579_100561530A="), &(o2->_";
char*s33_2098363273A="is_subnormal";
char*s110_1004555549A="Internal compiler error. Definition of infix \"^\" of INTEGER_GENERAL is not coherent with compiler builtin simplifications.";
char*s33_349117293A="NATIVE_ARRAY";
char*s30_1812938425A="Bad executable name: \"";
char*s104_1861857328A="Deleted extra semi-colon.";
char*s119_1816788953A=". The assigner feature is expected to have exactly one more argument than the assigned feature.";
char*s650_1541882313A=" is inherited more than once.";
char*s544_4992A="    ";
char*s753_2131486419A="inspectManifestStringExpression";
char*s103_179688005A="Expected a non-empty types list.";
char*s103_928941315A="Constraint Class name expected.";
char*s110_1836299930A="Measurements done during inlining of dynamic dispatch:\n";
char*s125_195766720A="Unable to write error(s)/warning(s) redirection output file \"";
char*s103_1680421289A="Void cannot be the left-hand side of the binary \"+\" operator.";
char*s409_165614527A=" which is out of INTEGER_16 range.)";
char*s33_84969A="lower";
char*s615_2142146116A="int R=1;\nse_";
char*s632_380218A="ac_liv";
char*s833_101355036A="if(bdw_in_assign)bdw_delayed_finalize=1;\nelse\173""\nhandle(SE_HANDLE_ENTER_GC,NULL);\n";
char*s409_1057872442A=" which is out of range -63 ..63 because target type is INTEGER_64.";
char*s637_204519611A="if(R)\173""\nT0*o1=C->_";
char*s1006_838816886A="). No description file found.";
char*s119_1998329594A="\" come from the same original feature via multiple \"insert\" paths, but none comes via an \"inherit\" path.\nBelow, you get the feature evolution step by step. Note that in the end (type ";
char*s833_800004081A="T0*bdw_weakref_getlink(bdw_Twr*wr)";
char*s103_75828399A="\" as a local variable name.";
char*s103_1204389280A="You are using a case sensitive language in which all class names must use only upper case letters. This decision was made to make the code more readable and to allow better error messages as well as syntax error recovery. The name \"";
char*s441_1628100917A="Unable to find file for class \"";
char*s104_1578831409A="Expression expected after assignment test \"\?:=\".";
char*s103_1307652273A="Expected a feature name to assign.";
char*s103_1690004585A="Writable entity expected here. Argument ";
char*s833_486352305A="mark_native_arrays(";
char*s430_1627141371A=" not correctly equiped for manifest generic creation (missing definition of feature `manifest_make\').";
char*s35_914215870A="high_memory_compiler";
char*s112_1588150185A="The selected system name is \"";
char*s112_91157A="wlink";
char*s794_1932458562A="\' key in the ini file must be an integer.\n";
char*s472_375013061A="Such an expression cannot be on the left-hand side of an assignment operator. There is no assigner to `";
char*s97_8198176A="TUPLE...";
char*s637_60405A="R=1;\n";
char*s717_1345708525A="\173""/*mark_item*/\175""\n";
char*s459_1875641781A="Value out of INTEGER_16 range.";
char*s837_1831440704A="\175"",NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc";
char*s410_29662A=" \?:= ";
char*s752_1309017823A="The value is already part of previously encountered slice. (Wrong inspect statement.)";
char*s33_1487451A="NATURAL";
char*s278_1453633985A="Unknown assertion level tag.";
char*s116_495363549A="stop_profile(&master_profile, &global_profile);\n";
char*s718_1240206596A="void gc_start(void)";
char*s103_1545228536A="Cannot open Cecil file (use -verbose flag for details).";
char*s403_277033810A=" while the expression ";
char*s103_973007162A="Empty debug key list (deleted).";
char*s112_561720547A="\": unknown C compiler name after -cc flag or in the ACE file.\n";
char*s365_197895058A="Must use here a manifest STRING because the previous one used in this \"inspect\" statement is a manifest STRING.";
char*s110_1889118664A="No Polymorphic Call Site in the Live Code.\n";
char*s615_1387812168A=");\nu->creation_mold_id=";
char*s388_668815628A="The slice includes an already encountered value. (Wrong inspect statement.)";
char*s103_2108887750A="The base type is no longer used. Class ROUTINE now has only one formal argument. Just remove this unused type mark.";
char*s33_240810599A="c_inline_c";
char*s544_165909873A="/etc/liberty-eiffel";
char*s116_2022630A="error0(";
char*s114_11253A="BeOS";
char*s33_240810604A="c_inline_h";
char*s632_2022635A="error1(";
char*s120_128358027A="..................................................";
char*s34_392625A="assign";
char*s615_4999725A="*a2=(se_";
char*s103_199494346A="Keyword \"end\" expected at the end of a class.";
char*s615_706329A="\",1,0,\"";
char*s835_1777096676A="\n#define gc_mark";
char*s669_143852403A=". (The whole type of the agent your are trying to launch is ";
char*s650_831146693A="All ancestors are deferred, hence making this Precursor call not valid.";
char*s33_17422A="\174"">>>";
char*s33_2054549840A="manifest_put";
char*s103_1912621670A="This name cannot be used as a valid class name.";
char*s649_265537649A="/*INTERNAL_C_LOCAL list]*/\n";
char*s632_380343A="ac_req";
char*s669_167300030A=" into formal argument of type ";
char*s719_1384921237A="handle(SE_HANDLE_EXIT_GC,NULL);\n";
char*s103_922446006A="Overflow while reading integer constant. Value `";
char*s103_66884963A="Error while reading an integer constant. Missing \"\175""\" \?";
char*s103_134219969A="Error while reading an hexadecimal value. Missing \"\175""\" \?";
char*s30_53561911A="no_rescue";
char*s116_471553120A="parent_profile=&global_profile;\n";
char*s719_1374304640A="fprintf(SE_GCINFO,\"--------------------\\nNumber\\tTotal\\tStore\\tName\\ncreated\\tsize\\tleft\\n\");\n";
char*s632_504830035A=")) \173""switch(";
char*s387_128333478A="The corresponding feature definition.";
char*s112_262628264A="linkit.com";
char*s632_1888091524A="goto retry_tag;\n";
char*s478_1809088081A="data_member ";
char*s103_1701980726A="Removed unexpected blank space(s) just before this dot (assume you really want to apply a procedure using the previous STRING as target).";
char*s33_337331A="Result";
char*s116_17480A="se_i";
char*s97_1056980719A="Procedure \"";
char*s116_1680956616A="se_profile_t root_profile";
char*s103_2060540980A="Empty formal generic list (deleted).";
char*s640_5313505A="*exp=0;\n";
char*s35_17498A="sedb";
char*s125_1293738877A=" is not set.\n";
char*s103_1046025807A="The old \"select\" option of the \"inherit\" clause is now obsolete. You have to update your code with the new \"insert\" mechanism. With Liberty Eiffel, this can be achieved thanks to the new \"insert\" clause. The new \"insert\" clause comes just after the traditional \"inherit\" clause with a similar syntax.";
char*s33_1483884743A="native_array_internals_from_generating_type";
char*s611_985967445A="; /*NATURAL_";
char*s638_2102695A="memcpy(";
char*s116_17507A="prof";
char*s650_139854341A="Signature of the redefined feature is not valid.";
char*s103_2176510A="plug_in";
char*s103_552734069A="The SCOOP attempt implementation has been abandoned (December 2006). ";
char*s835_1387277146A="object;union \173""void*flag;gc";
char*s110_1556970935A="Unsafe call site (see also next warning).";
char*s719_35966A=" elt=";
char*s640_5313530A="*exp=1;\n";
char*s638_1416678934A=">>8)&0xFF00)\174""(((uint32_t)";
char*s388_492964813A="Second occurrence for this value in the same inspect. (Wrong inspect statement.)";
char*s104_1538234998A="Index value expected (\"indexing ...\").";
char*s34_306165094A="smarteiffel_options";
char*s110_921818688A="Monomorphic Procedure Call";
char*s409_1505530135A="Overflow of infix \"*\" with INTEGER_16 operands. (";
char*s637_46980416A="_t)((uint";
char*s119_870131842A=" (given first) can\'t be accepted because a concrete feature is inherited. What\'s called a concrete feature here is a feature which is not deferred. You may consider to add a redefine or an undefine. May be.";
char*s116_2072467813A="&local_profile";
char*s409_177461A=" by 0.";
char*s110_572614135A=" formal argument";
char*s284_867234734A="Redefinition of ";
char*s837_97510A="\175""\175""\175""\175""\n";
char*s97_445214625A=" is invalid. A deferred class must not be expanded.";
char*s29_386614A="bdw_gc";
char*s278_929353692A="linker_options";
char*s611_1316811340A="/*BUG:WR@runtime!*/";
char*s527_637371887A="Cannot create an ARRAY with only `Void\' items.";
char*s719_558682149A="void*gc_mark_agent_mold;\n";
char*s544_1707891936A="/.liberty-eiffel";
char*s544_11429A="HOME";
char*s110_170061979A="Target Type Prediction Score: ";
char*s719_398948A="gc_lib";
char*s615_5284A="\" (\"";
char*s103_755120513A="Inside a client list, only plain class names are allowed. (Class names must use only uppercase letters.)";
char*s518_890319497A=" which is out of INTEGER_64 range.";
char*s103_2087550139A="Keyword \"end\" added to finish this \"if\" statement.";
char*s615_21632225A="*)u1;\nse_";
char*s719_328118105A="manifest_string_mark1();\n";
char*s837_775406525A="p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));\nfor(;((void*)p)>=((void*)o);p--)\173""\ne=*p;\n";
char*s483_1370872538A="Invalid notation for 0.0.";
char*s833_473982927A="if(g!=o->bdw_generation)\173""\n";
char*s637_520373770A="((int16_t)(";
char*s35_10714216A="no_split";
char*s637_1836091144A="Bad number of arguments of external signature.";
char*s122_300594A="File \"";
char*s33_1740332382A="Minimum_double";
char*s110_1379717706A="Now inlining dynamic dispatch (using inspect instructions)\n";
char*s103_1606714210A="Since february 2006, for SmartEiffel release 2.3, the old legacy NONE type mark is obsolete. Keep in mind that an empty class name list such as \173""\175"" does indicate no exportation at all, hence making NONE useless and probably misleading for newcomers. So, just remove this NONE class name now. Please update your code now.";
char*s33_1644425991A="manifest_semicolon_check";
char*s650_1677586033A=". This can lead to catcalls!";
char*s615_4434071A=" called.";
char*s632_4766225A=" while (";
char*s414_1119905623A="`manifest_create\' is not an ordinary creation procedure. Please use the \173""";
char*s833_1509872874A="*o=*markna;\nGC_disable();\n";
char*s34_75797981A=" has no compiler-defined `deep_twin\' or `is_deep_equal\' because the corresponding allocated size is not part of the NATIVE_ARRAY object. The client class of this NATIVE_ARRAY type is supposed to use a `capacity\' attribute which contains the corresponding number of allocated items (see STRING or ARRAY for example).";
char*s719_49680837A="if (i <= ";
char*s104_744085684A="Right hand side expression of \?= assignment expected here.";
char*s116_1173628471A="]=runinit_profile;\n";
char*s567_146251545A=".unlock*/\n";
char*s33_267647687A="standard_is_equal";
char*s116_825893997A="/* Allocate an Eiffel STRING given its size and native storage */\n";
char*s479_380590A="access";
char*s833_1832086881A="(o)==NULL&&GC_should_invoke_finalizers())bdw_run_finalizers();\n";
char*s406_988692517A="\"). You can use the Void comparison only when other type mark is a reference type or, if it is an expanded type, it must be an anchor or some formal generic argument. Fix this error first.";
char*s386_5382A=" -- ";
char*s650_2025498932A=") of the concrete feature (inherited from type ";
char*s472_789350917A=" by a call to \173""";
char*s103_96053257A="No parent after \"insert\" keyword (an empty list is not allowed here).";
char*s278_17696A="root";
char*s103_1066804080A="Missing \":\" before the type mark\?";
char*s103_1062283098A="Only simple and statically computable expression are allowed here (inside \"when\" of \"inspect\" statement).";
char*s110_109671582A=" while there is no actual argument list in the call.";
char*s288_1831619428A="Too many errors.\n";
char*s335_1262756502A="Parsing Cecil file: ";
char*s719_444175272A="#define SE_GC_LIB 1\n";
char*s34_17715A="then";
char*s278_880804011A="Keyword \"root\" expected. Invalid ACE file.";
char*s640_300665A="R=(*((";
char*s104_2004339522A="Added missing brackets to enclose the previous \"once\" manifest STRING.";
char*s344_1001314405A="Incompatible signatures. (One has argument(s) but not the other.)";
char*s284_92467250A="Cannot redefine ";
char*s288_878860A="------\n";
char*s637_537910373A="se_deep_twin_trats()\n";
char*s103_112999293A="Instruction expected here. True alone is not an instruction.";
char*s572_30034A="&(((T";
char*s103_568400887A="`indexing\' is an obsolete keyword, please use `note\' instead.";
char*s116_1968768303A="master_profile.profile=NULL;\n";
char*s103_783329131A="Total time spent in parser: ";
char*s615_180709512A="return u->R;\n";
char*s103_1984637890A=" is not a feature name.";
char*s119_1605047378A=" type.\n\nFirst \"inherit\" path (from parent to child):\n   ";
char*s116_1435285930A="Define initialize stuff.\n";
char*s103_79251A="false";
char*s103_756929053A="Must use exactly 2 hexadecimal digits for INTEGER_8.";
char*s103_142936234A=" cannot be used as a feature name to start a new feature definition. Parser lost. Sorry. Check before and after that point.";
char*s650_21306364A="This Precursor call is ambiguous because the type ";
char*s116_738771309A="void initialize_eiffel_runtime(int argc,char*argv[])";
char*s110_295542551A="Polymorphic Function Call";
char*s615_386819A="caller";
char*s375_22401251A=" context.";
char*s104_348041349A="Error in inspect.";
char*s116_401124480A=" run classes :\n";
char*s344_1149307517A="Bad redefinition. An attribute must be redefined as an attribute only (VDRD.6).";
char*s430_1837585965A="Creation procedure not found.";
char*s719_1642168697A="void(*gc_mark_agent_mold)(se_";
char*s387_305790140A="This is not an INTEGER expression.";
char*s615_242108838A=" (1 feature).\n";
char*s615_56760755A="void*eq;\n";
char*s615_60837A="R=C->";
char*s615_1367040625A="retry_tag:\n";
char*s33_1979951A="dispose";
char*s487_1965077754A="Such an \"inspect\" statement is for type STRING or FIXED_STRING. (The type of ";
char*s116_471707221A="*sizeof(se_profile_t));\nqsort(sorted_inv_profile, ";
char*s465_1809998749A="\' not found.";
char*s114_17794A="vbcc";
char*s33_386854A="calloc";
char*s116_1844536619A="se_local_profile_t*,";
char*s614_1151663379A="fprintf(file,\"%llu\",(long long unsigned int)((uint64_t) *o));";
char*s103_776600004A="Explicit creation/create type mark should not be anchored.";
char*s835_1126647264A="*next;\175"" header;\175"";\n";
char*s385_2014931627A="External feature must not have rescue compound.";
char*s103_150329797A="Error while reading hexadecimal value.";
char*s116_802495724A="\");\nstart_profile(parent_profile, &local_profile);\n";
char*s125_1723571071A="................................................................";
char*s116_719604853A="=((T0*)eiffel_root_object);\n";
char*s114_39617954A="Macintosh";
char*s112_25704393A="/LIBPATH:";
char*s573_5515A="\").\n";
char*s103_397329363A="Inheritance option not at a correct place. The correct order is: \"rename... export... undefine... redefine...\".";
char*s116_1881374985A="memcpy(sorted_agent_profile, agent_profile, ";
char*s116_713312393A=", inv_profile, ";
char*s103_676769302A="Syntax error while trying to parse the beginning of a new feature definition. Expression ";
char*s33_79341A="count";
char*s615_882065083A=";\nstruct _se_";
char*s116_862271166A="ds.fd->assertion_flag=1;\n\175""\n";
char*s288_60894A="Error";
char*s33_48672249A="bit_clear";
char*s116_23988287A="#include ";
char*s116_1682814572A="manifest_put(";
char*s33_572288431A="to_natural_16";
char*s110_1019367716A=" (For this call, the target is the implicit non written `Current\' which is of type ";
char*s543_1381550903A="simplifying";
char*s796_2078852867A="#(1)/.config";
char*s33_572288437A="to_natural_32";
char*s719_189437896A="unsigned int fsoc_count_ceil";
char*s719_1891487260A="(gc_memory_used())";
char*s110_91926102A=" starting from cluster ";
char*s409_530141799A="Violated require assertion. Argument value is ";
char*s615_560761477A="internal_exception_handler(Routine_failure);\n\175""\n";
char*s103_202933204A=" cannot be an expression. ";
char*s33_572288454A="to_natural_64";
char*s116_1672511676A="global_profile.profile=&root_profile;\n";
char*s718_6943896A="GC_DEBUG";
char*s103_120546715A="Left hand side expression of := assignment must be a feature call.";
char*s110_479236135A="Result type of a once function must not involve formal generic names nor anchored types (VFFD.8).";
char*s614_5580A="\");\n";
char*s110_1865554673A="Live_type_map size=";
char*s103_922212712A="Variant (INTEGER) Expression Expected.";
char*s110_1162901343A="Starting optimization (";
char*s615_674382779A="(void**)&R,";
char*s110_1546692995A=" while the actual argument list has ";
char*s484_1411247976A=". (Actual bunch size is ";
char*s718_1665893228A="Adding Boehm-Demers-Weiser Garbage Collector.\n";
char*s116_1842506892A="se_local_profile_t local_profile;\nstatic se_profile_t prof;\nstatic int prof_init=0;\n";
char*s116_4692662A="#define ";
char*s638_835985A="*/));\175""\n";
char*s838_5498450A="*sizeof(";
char*s833_2070967345A="typedef struct bdw_Swr\173""Tid id;T0*o;\175""bdw_Twr;\n";
char*s632_312808564A=")->_storage + ((";
char*s116_1994596535A="void(*se_prinT[";
char*s643_17916A="uint";
char*s110_5615A="\".)\n";
char*s833_42521A=")obj)";
char*s116_4631170A="/*PCO*/\n";
char*s116_1413407004A="Cecil (C function for external code) :\n";
char*s33_1680926299A="default_create";
char*s34_436196A="rename";
char*s484_1142240176A=" into formal argument which is of type ";
char*s794_602797481A="Redundant key definition found in section [";
char*s112_120239233A="1234567890";
char*s837_28263330A=",size));\n";
char*s33_506823435A="manifest_creation";
char*s35_10554609A="loadpath";
char*s278_816126476A="Unused obsolete flag -wedit / option wedit.";
char*s103_1869854287A="Unexpected bracket after a comma.";
char*s103_2009918711A="Error inside feature name definition. Unable to find the synonymous name which must be just after the previous colon mark \",\".";
char*s699_861846863A="Legacy splitter enabled.\n";
char*s33_39002989A="PREDICATE";
char*s543_456083848A="The system is not type safe (read previous warnings carefully).";
char*s29_85614A="no_gc";
char*s632_521905705A=")->_count;\n";
char*s837_291421585A="size=(size*sizeof(";
char*s116_1586354711A="uint32_t lsi";
char*s459_865125357A="A \"unique\" definition is actually a constant attribute definition.";
char*s718_1166044581A="GC_java_finalization=1;\nGC_finalize_on_demand=1;\nGC_finalizer_notifier=bdw_run_finalizers;\nGC_INIT();\nGC_stackbottom=(char*)(void*)&argc;\n";
char*s103_971408488A="Right hand side expression of ";
char*s491_1773984820A=" Replace your code with:\n\n      agent ";
char*s110_866669263A="Handling include of \"";
char*s478_1961687A="delete ";
char*s121_51895507A="error1(\"Invalid inspect (nothing selected).\",";
char*s125_1635864124A="SmartEiffelDirectory";
char*s837_1815688614A="*)(&(c->first_object)));\nif(c->header.state_type==FSO_STORE_CHUNK)\173""\nfor(;o1<";
char*s103_210812758A="\" does not contain class \"";
char*s403_1250079569A="The left-hand side of ";
char*s650_1722095007A="Signature (adapted in the type ";
char*s430_1333985363A="Feature `manifest_make\' must be a procedure.";
char*s116_2041682A="extern ";
char*s353_786054293A="Forbidden call (i.e. exportation rules violated) when the type of Current is ";
char*s615_988243818A="\173""Tid id;\nint creation_mold_id;\n";
char*s33_1937220099A="is_deep_equal";
char*s837_567878339A="*/))+sizeof(rsoh);\nsize=((size+(sizeof(double)-1))&\176""(sizeof(double)-1));\n";
char*s615_5720A="\",1\175""";
char*s837_598811726A=".store_left>sizeof(rsoh))\173""\nr->header.size=size;\n";
char*s111_1461366457A="Version of command \"#(1)\" is:";
char*s756_1613492996A="Invalid byte as first character of UTF-8 sequence.";
char*s103_18036A="true";
char*s33_247239028A="collecting";
char*s718_1942608409A="gc_start();\n";
char*s719_41125176A="gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);\n((gc";
char*s838_1506490209A=")\nfprintf(SE_GCINFO,\"%d\\t%d\\t\\t";
char*s630_1406782500A="/*ND*/(T0*)(";
char*s29_425790270A=": missing split mode after -split flag.\n";
char*s116_2103819988A="int se_strucT";
char*s406_1816888147A=". Comparison not allowed (VWEQ).";
char*s103_1694969179A="Such an expression cannot be on the left-hand side of an assignment operator. A dot can never be used for the left-hand side part of an assignment operator. Valid left-hand side can be Result, some local or the name of an attribute of Current. See also http://SmartEiffel/wiki/en/Syntax_diagrams#Writable.php for details.";
char*s116_1836282258A="se_local_profile_t global_profile";
char*s630_1188262106A="/*$*/((void*)W";
char*s103_825716016A="Name of the current class expected.";
char*s837_1649648619A="o=(&(p->object));\n";
char*s116_273731430A="se_string(";
char*s33_1549680A="REAL_32";
char*s835_130382376A=";\nstruct B";
char*s477_1848584263A="Double definition found for key ";
char*s344_1642968637A="\' but different signatures. According to the join rule, the signatures have to be identical in the final class.";
char*s837_1040644265A="*n;\nfsoc*c;\n";
char*s116_1042003640A="int(*eq)(se_agent*,se_agent*);\n\175"";\n";
char*s375_5787A=" := ";
char*s34_18090A="when";
char*s457_114137597A=" inherit: ";
char*s638_946895A="#endif\n";
char*s403_1721307786A="Void cannot be the right-hand side of a ";
char*s33_1549697A="REAL_64";
char*s116_1352413868A="int32_t c,uint16_t*s,int32_t sc,int16_t*lsv,int32_t*lsi)";
char*s609_11952A="T0**";
char*s33_1549703A="REAL_80";
char*s110_98784712A="\' in type ";
char*s277_1968202785A=" (See next message to locate the error.)";
char*s33_18110A="twin";
char*s116_1063704391A="fprintf(profile_file, \"\\n===============================================================================\\nDetailed profile:\\n\");\n";
char*s615_1566831588A="ds.exception_origin=NULL;\n";
char*s116_1339521386A="fprintf(profile_file, \"===============================================================================\\nSummary:\\n\");\n";
char*s278_374877A="_check";
char*s718_674383009A="(void*)0,0,";
char*s718_1635390646A="GC support (functions).\n";
char*s837_2021999449A="gc_update_weak_ref_item";
char*s650_1849347035A=") is not compatible with the deferred one comming from parent type ";
char*s116_1460025642A="start_profile(&master_profile, &global_profile);\n";
char*s837_484169497A=".store_left=0;\n\175""\n(r->header.magic_flag)=RSOH_UNMARKED;\n((void)memset((r+1),0,r->header.size-sizeof(rsoh)));\nreturn((T";
char*s484_14429929A=" not correctly equiped for manifest generic creation (`manifest_creation\' missing in the creation clause).";
char*s125_809686569A="\".\nCommand aborted.\n";
char*s632_6575105A=";break;\n";
char*s114_18144A="vpcc";
char*s103_18150A="void";
char*s119_290966604A=") there are two versions of the same initial feature with two different names. To  fix this, either use enough \"inherit\" links in place of \"insert\" links to have one \"inherit\" path or rename the feature to get the same name in ";
char*s837_322115272A="*)(wr->o);\nif (obj_ptr != NULL)\173""\nint swept = (((void*)obj_ptr) <= ((void*)wr));\nif (swept != (obj_ptr->header.flag == FSOH_MARKED)) /* **** TODO: was FSOH_UNMARKED\?\?\?\? (incoherent with comment below) */\n/* (already swept) xor marked */\nwr->o = NULL;\n\175""\n";
char*s638_2122389958A="se_print_run_time_stack();\n";
char*s116_1624663341A=")(va_arg(pa,";
char*s103_1320619413A="Added missing \":\" semicolon before this type mark.";
char*s103_442256615A="\" aborted.\n";
char*s630_112304676A="..........";
char*s460_2015374870A="Conflict between argument/feature name (VRFA).";
char*s615_472574902A="(se_agent*u1, se_agent*u2)";
char*s278_1325140408A=": cannot use -sedb with -boost flag.\n";
char*s35_267875778A="no_warning";
char*s479_18186A="type";
char*s837_1985327250A="se_gc_check_id(o,";
char*s837_1196941282A="n->object=M";
char*s33_1176378494A="type_can_be_assigned_to_item";
char*s637_559906822A=" built-in: ";
char*s544_1096544670A="/lang/eiffel/.serc";
char*s125_203714719A="Obsolete \"";
char*s33_55924644A="std_error";
char*s835_2097247A="na_env ";
char*s123_2120987577A="..... unique buffer .....";
char*s403_5912A=" \?= ";
char*s284_1153312264A=" not found in this class.";
char*s116_163413385A="se_profile_t agent_profile";
char*s837_1800342110A="++;\n\175""\nelse if(";
char*s615_1992825354A="\173""\"invariant ";
char*s637_854330615A="\175""\nse_deep_equal_trats()\n";
char*s1006_1067567332A="The plugin ";
char*s33_1673348567A="open_argument_index";
char*s110_5873980A="Unknown infix operator \"";
char*s646_399591A="double";
char*s97_1539816514A=" is not a generic class. (See file \"";
char*s125_44975894A="Writing \"";
char*s34_56927287A="c_linker_path";
char*s637_1709245815A=";\nerror0(\"Invalid deep_twin.\",NULL)";
char*s637_4680700A="!memcmp(";
char*s103_518055462A="Local variable name expected after comma inside local variable list.";
char*s484_84293096A="Wrong number of arguments for manifest generic creation.";
char*s33_1831158645A="INTERNALS_HANDLER";
char*s837_175186427A="*old_gc_free=gc_free";
char*s103_732257893A="\')\' expected in expression.";
char*s632_352968782A=");\nif(NULL!=(";
char*s116_49152444A="ds.caller";
char*s377_18257A="yes ";
char*s410_902517583A="........................";
char*s832_496139469A="Internal problem for \"mark_native_arrays\".";
char*s288_927785894A="Fatal Error";
char*s337_673829558A="Incorrect_inspect_value";
char*s365_1664909434A="Cannot use \'..\' with manifest strings.";
char*s459_529299514A="A boolean constant cannot be an assigner.";
char*s103_1387339410A=" is not writable. Cannot use ";
char*s103_445504446A="\" expected.";
char*s110_1242126608A="Starting type safety check";
char*s35_10714862A="no_strip";
char*s112_1494914262A=" Ignore=93,194,304";
char*s116_5980A=" C;\n";
char*s459_827998241A=" has no result type";
char*s433_983618541A=" Constraint Generic Violation.";
char*s718_341361877A="int bdw_in_assign";
char*s719_1869700848A="*)eiffel_root_object)->header.flag=FSOH_UNMARKED;\n";
char*s110_1568923104A=" must have a feature named `";
char*s114_448859A="wcl386";
char*s33_1553736287A="REAL_EXTENDED";
char*s34_1980461A="convert";
char*s837_744114A="&&(((gc";
char*s103_1575461624A="A feature name cannot be used to indicate exportation status in a client list. Only plain class names are allowed here (class names must use only uppercase letters).";
char*s103_1181926797A="Added \"end\" for inspect instruction.";
char*s638_531809155A=">>8);\n#else\n";
char*s116_8359055A="set_dump_stack_top(";
char*s103_1978106088A="Erreur while reading a number.";
char*s33_9712276A="as_16_ne";
char*s719_172080A="*)o);\n";
char*s640_705408837A="*id=_r->id;R=&_r;break;\ndefault:break;\n\175""\n\175""\n\175""\n";
char*s34_1168210079A="cpp_linker_path";
char*s833_1664195965A="void*bdw_na_assign_innerT";
char*s637_42916A="(uint";
char*s29_24284008A=": missing compiler name after -cc flag.\n";
char*s719_249330648A="gc_info_nb";
char*s284_1145998825A="\" (forbidden or not yet implemented).";
char*s637_842552A="*)R)=*C";
char*s116_431043495A="*sizeof(se_profile_t));\n";
char*s116_490486762A="local_profile.profile=&atexit_profile;\n";
char*s103_727903062A="Bad create expression (\'\173""\' expected).";
char*s112_165012750A="\"[General] os\" key is missing.";
char*s112_2075119688A="#1#2#3#4#5#6#7#8#9#\?.o";
char*s429_306215109A="An assertion must be a BOOLEAN expression.";
char*s103_1583181163A="Void is not a valid inspect expression (just after keyword \"inspect\").";
char*s116_1377208779A=";\nstart_profile(parent_profile, &local_profile);\n";
char*s637_153655A="&(C->_";
char*s110_212031001A="The main procedure must not have arguments.";
char*s103_12184A="NONE";
char*s109_1152235958A=" transitions.\n";
char*s116_1160736641A="Manifest String";
char*s86_1501391323A="Adapting Cecil features.\n";
char*s116_12188A="T7*g";
char*s116_113036818A="local_profile.profile=agent_switch_profile+";
char*s116_12201A="T7*t";
char*s103_34383990A="Error while reading a number.";
char*s104_35386613A="...............................................";
char*s454_498169402A=". An expanded type must have one unique creation procedure with no argument: the creation procedure used for automatic initialization. Please, consider to add explicitely the `default_create\' procedure from ANY or some other existing procedure with no arguments. For expanded class with no creation clause, the `default_create\' procedure is the one used for automatic initialization.";
char*s630_781095A="(\'*/CA_";
char*s103_1593742473A="Closing \">>\" of manifest generic creation expected.";
char*s119_740900172A="Assigned feature not found in type";
char*s103_2018315248A="Parsing Cecil File: \"";
char*s116_1009317511A="Compiling/Sorting ";
char*s103_124311631A="Void cannot be the left-hand side of the binary \"^\" operator.";
char*s527_1359629264A="The old manifest ARRAY notation can only be used when the common type mark for all items of the manifest ARRAY exists, is not ambiguous and is easy to compute! By the way, it is not easy or possible to compute the most general type for the following set of types: \173""";
char*s433_1920465143A="Actual generic derivation ";
char*s693_8777401A="Universe";
char*s116_1838958244A="/*agent*/T0*a";
char*s103_1962710217A="\")\" expected to end debug string list.";
char*s837_1901427808A="T0* obj_ptr = item->o;\nif (obj_ptr != NULL)\173""\nint obj_size=se_strucT[obj_ptr->id];\nint swept";
char*s837_365929075A=".count_minus_one;\nn=";
char*s839_958639438A=".store->header.magic_flag=RSOH_FREE;\n";
char*s719_1328320695A="mark_stack_and_registers();\ngc_sweep();\ncollector_counter++;\n";
char*s112_5578901A="-include";
char*s337_176865800A="Developer_exception";
char*s630_7227375A="INT64_C(";
char*s103_431394186A="Character \'%\"\' inserted.";
char*s615_9589368A="agent_eq";
char*s833_1048179568A="GC_disable();\nif(wr->o)GC_unregister_disappearing_link((void**)&(wr->o));\nwr->o=r;\nif(r)GC_GENERAL_REGISTER_DISAPPEARING_LINK((void**)&(wr->o),(void*)r);\nGC_enable();\n";
char*s35_388005040A="case_insensitive";
char*s112_1319327951A="loadpath.se";
char*s650_374042271A="The \"feature\" clause declares a narrower client list than";
char*s110_3579844A=" (type \"";
char*s34_1747646688A="c_strip_path";
char*s579_51582255A="int R=0;\n";
char*s717_264935842A="))->o)=(T0*)(";
char*s125_141444A="\" as \"";
char*s104_432335312A="Same identifier appears twice (local/formal).";
char*s837_1265395998A=".store))+size));\n\175""\nelse \173""\nr->header.size=size+";
char*s630_40430500A="UINT64_C(";
char*s615_5794220A="=(u->CA_";
char*s278_1598804806A="At this point in the ACE file, you are supposed to say \"yes\", \"no\", or \"all\".";
char*s630_860088160A="(/*OUTCL:OUT*/*CL_";
char*s106_356743A="Bad program.\n(No program name found.)";
char*s116_209121A="(live)";
char*s103_1615234134A="Since february 2006, for SmartEiffel release 2.3, the old legacy NONE type mark is obsolete. Keep in mind that an empty class name list like \173""\175"" do indicate no exportation at all, hence making NONE unuseful and probably misleading for newcomers. So, just remove this NONE class name right now. Please update your code now.";
char*s615_338723264A="This routine is actually deferred is still in the live code set. (You will have a crash at run-time if the dynamic type of Current is ";
char*s459_1573210512A="The type of this constant feature should be CHARACTER.";
char*s116_1790869799A="C++ external definitions.\n";
char*s615_3912034A="(&(a1->c";
char*s671_1257368965A="ensure then";

#ifdef __cplusplus
}
#endif
