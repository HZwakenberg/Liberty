#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3.99 (LibertyEiffel patched bootstrapper)
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe -Os
*/

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1400)       /* VC8+ */
# ifndef _CRT_SECURE_NO_DEPRECATE
#  define _CRT_SECURE_NO_DEPRECATE
# endif
# ifndef _CRT_NONSTDC_NO_DEPRECATE
#  define _CRT_NONSTDC_NO_DEPRECATE
# endif
#endif   /* VC8+ */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1600) /* MSVC older than v10 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1220) /* WATCOM 12.2 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#  include <cygwin/version.h>
#  if defined(CYGWIN_VERSION_DLL_MAJOR) && (CYGWIN_VERSION_DLL_MAJOR<1005)
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#  endif
#elif defined(SASC)
#    error("Too old SAS/C compiler, sorry.");
#elif defined(__SASC__)
#  if (__SASC__ < 750 ) /*  SAS/C before 7.50 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#  endif
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* ARM */
#  if defined(__ARMEL__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(__ARMEB__)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__arm__)
#    error "ARMs are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2) || \
      defined(IBM370) || defined(__MVS__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.

   NOTE: with gcc, -ansi is used for SmartEiffel generated files EXCEPT in
   -no_split mode. ANSI only recognizes the non-sig versions.
*/
#if (defined(_SIGSET_H_types) && !defined(__STRICT_ANSI__))
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_integer_8(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL_32 is #4:
*/
typedef float T4;
typedef T4 real32_t;
#define EIF_REAL_32 T4
#define M4 (0.0)
#define EIF_MINIMUM_REAL_32 (-(FLT_MAX))
#define EIF_MAXIMUM_REAL_32 (FLT_MAX)

/*
  Eiffel type REAL or REAL_64 is #5:
*/
typedef double T5;
typedef T5 real64_t;
#define EIF_REAL T5
#define EIF_REAL_64 T5
#define M5 (0.0)
#define EIF_MINIMUM_REAL_64 (-(DBL_MAX))
#define EIF_MINIMUM_REAL (EIF_MINIMUM_REAL_64)
#define EIF_MAXIMUM_REAL_64 (DBL_MAX)
#define EIF_MAXIMUM_REAL (EIF_MAXIMUM_REAL_64)

/*
  Eiffel type REAL_EXTENDED is #12:
*/
typedef long double T12;
typedef T12 real_extended_t;
#define EIF_REAL_EXTENDED T12
#define EIF_REAL_128 T12
#define M12 (0.0)
#define EIF_MINIMUM_REAL_EXTENDED (-(DBL_MAX))
#define EIF_MAXIMUM_REAL_EXTENDED (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ
#define EIF_ANY EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void* src, size_t size);

/*
   die method.
 */
void se_die(int code);

/*
    Runtime hooks. They allow different runtime modules to be quite independant. In time, they will also allow
    thread-safe operations.

    Currently known modules:
      - boost
      - no_check
      - sedb
      - gc
      - print stack
      - profile
      - plugins

    However, currently only profile uses this method. It will be extended to other modules later.

    The currently defined hooks are described in the enum below (the names should be self-explanatory).
 */
typedef enum {
  SE_HANDLE_EXCEPTION_SET, /* called when an exception handler is set, prior to SETJMP */
  SE_HANDLE_EXCEPTION_CLEAR, /* called when a feature with an exception handler normally returns */
  SE_HANDLE_EXCEPTION_THROWN, /* called when an exception is thrown, prior to the LONGJMP */
  SE_HANDLE_ENTER_GC, /* called when gc_start() begins */
  SE_HANDLE_EXIT_GC, /* called when gc_start() ends */
  SE_HANDLE_ENTER_PRINT_STACK, /* called when se_print_run_time_stack() begins */
  SE_HANDLE_EXIT_PRINT_STACK, /* called when se_print_run_time_stack() ends */
  SE_HANDLE_NO_MORE_MEMORY, /* called by se_alloc() and co */
  SE_HANDLE_SEDB_BREAK, /* called when sedb stops the program */
  SE_HANDLE_SEDB_CONTINUE, /* called when sedb continues the program */
  SE_HANDLE_RUNTIME_ERROR, /* called when a runtime error is raised and not caught by an exception. Cannot be raised in boost mode. */
  SE_HANDLE_DIE_WITH_CODE, /* called when the program is stopped by the die_with_code feature. The data points to the int code. */
  SE_HANDLE_NORMAL_EXIT /* called when the program correctly terminates. The data is null. */
} se_handler_action_t;

extern int handlers_count;
typedef void se_runtime_handler_t(se_handler_action_t action, void*data);
void register_handler(se_runtime_handler_t*handler);
void _handle(se_handler_action_t action, void*data);

#define handle(action,data) do{if(handlers_count>0)_handle(action,data);}while(0)

#endif /* #ifndef _BASE_H */
#define SE_BOOST 1
#define SE_GC_LIB 1
/*
** This file have been created by wrapper-generator.
** Any change will be lost by the next execution of the tool.
*/
#define sizeof_itimerspec (sizeof(struct itimerspec))
#define tm_struct_get_tm_sec(a_structure) (((struct tm*) (a_structure))->tm_sec)

#define tm_struct_set_tm_sec(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_sec = (a_value);}while(0)

#define tm_struct_get_tm_min(a_structure) (((struct tm*) (a_structure))->tm_min)

#define tm_struct_set_tm_min(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_min = (a_value);}while(0)

#define tm_struct_get_tm_hour(a_structure) (((struct tm*) (a_structure))->tm_hour)

#define tm_struct_set_tm_hour(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_hour = (a_value);}while(0)

#define tm_struct_get_tm_mday(a_structure) (((struct tm*) (a_structure))->tm_mday)

#define tm_struct_set_tm_mday(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_mday = (a_value);}while(0)

#define tm_struct_get_tm_mon(a_structure) (((struct tm*) (a_structure))->tm_mon)

#define tm_struct_set_tm_mon(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_mon = (a_value);}while(0)

#define tm_struct_get_tm_year(a_structure) (((struct tm*) (a_structure))->tm_year)

#define tm_struct_set_tm_year(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_year = (a_value);}while(0)

#define tm_struct_get_tm_wday(a_structure) (((struct tm*) (a_structure))->tm_wday)

#define tm_struct_set_tm_wday(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_wday = (a_value);}while(0)

#define tm_struct_get_tm_yday(a_structure) (((struct tm*) (a_structure))->tm_yday)

#define tm_struct_set_tm_yday(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_yday = (a_value);}while(0)

#define tm_struct_get_tm_isdst(a_structure) (((struct tm*) (a_structure))->tm_isdst)

#define tm_struct_set_tm_isdst(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_isdst = (a_value);}while(0)

#define tm_struct_get_tm_gmtoff(a_structure) (((struct tm*) (a_structure))->tm_gmtoff)

#define tm_struct_set_tm_gmtoff(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_gmtoff = (a_value);}while(0)

#define tm_struct_get_tm_zone(a_structure) (((struct tm*) (a_structure))->tm_zone)

#define tm_struct_set_tm_zone(a_structure,a_value) do {(((struct tm*)(a_structure)))->tm_zone = (a_value);}while(0)

#define sizeof_tm (sizeof(struct tm))
#define random_data_struct_get_fptr(a_structure) (((struct random_data*) (a_structure))->fptr)

#define random_data_struct_set_fptr(a_structure,a_value) do {(((struct random_data*)(a_structure)))->fptr = (a_value);}while(0)

#define random_data_struct_get_rptr(a_structure) (((struct random_data*) (a_structure))->rptr)

#define random_data_struct_set_rptr(a_structure,a_value) do {(((struct random_data*)(a_structure)))->rptr = (a_value);}while(0)

#define random_data_struct_get_state(a_structure) (((struct random_data*) (a_structure))->state)

#define random_data_struct_set_state(a_structure,a_value) do {(((struct random_data*)(a_structure)))->state = (a_value);}while(0)

#define random_data_struct_get_rand_type(a_structure) (((struct random_data*) (a_structure))->rand_type)

#define random_data_struct_set_rand_type(a_structure,a_value) do {(((struct random_data*)(a_structure)))->rand_type = (a_value);}while(0)

#define random_data_struct_get_rand_deg(a_structure) (((struct random_data*) (a_structure))->rand_deg)

#define random_data_struct_set_rand_deg(a_structure,a_value) do {(((struct random_data*)(a_structure)))->rand_deg = (a_value);}while(0)

#define random_data_struct_get_rand_sep(a_structure) (((struct random_data*) (a_structure))->rand_sep)

#define random_data_struct_set_rand_sep(a_structure,a_value) do {(((struct random_data*)(a_structure)))->rand_sep = (a_value);}while(0)

#define random_data_struct_get_end_ptr(a_structure) (((struct random_data*) (a_structure))->end_ptr)

#define random_data_struct_set_end_ptr(a_structure,a_value) do {(((struct random_data*)(a_structure)))->end_ptr = (a_value);}while(0)

#define sizeof_random_data (sizeof(struct random_data))
#define div_t_struct_get_quot(a_structure) ((( div_t*) (a_structure))->quot)

#define div_t_struct_set_quot(a_structure,a_value) do {((( div_t*)(a_structure)))->quot = (a_value);}while(0)

#define div_t_struct_get_rem(a_structure) ((( div_t*) (a_structure))->rem)

#define div_t_struct_set_rem(a_structure,a_value) do {((( div_t*)(a_structure)))->rem = (a_value);}while(0)

#define sizeof_div_t (sizeof( div_t))
#define sizeof_obstack (sizeof(struct obstack))
#define sizeof_sigevent (sizeof(struct sigevent))
#define timespec_struct_get_tv_sec(a_structure) (((struct timespec*) (a_structure))->tv_sec)

#define timespec_struct_set_tv_sec(a_structure,a_value) do {(((struct timespec*)(a_structure)))->tv_sec = (a_value);}while(0)

#define timespec_struct_get_tv_nsec(a_structure) (((struct timespec*) (a_structure))->tv_nsec)

#define timespec_struct_set_tv_nsec(a_structure,a_value) do {(((struct timespec*)(a_structure)))->tv_nsec = (a_value);}while(0)

#define sizeof_timespec (sizeof(struct timespec))
#define lldiv_t_struct_get_quot(a_structure) ((( lldiv_t*) (a_structure))->quot)

#define lldiv_t_struct_set_quot(a_structure,a_value) do {((( lldiv_t*)(a_structure)))->quot = (a_value);}while(0)

#define lldiv_t_struct_get_rem(a_structure) ((( lldiv_t*) (a_structure))->rem)

#define lldiv_t_struct_set_rem(a_structure,a_value) do {((( lldiv_t*)(a_structure)))->rem = (a_value);}while(0)

#define sizeof_lldiv_t (sizeof( lldiv_t))
#define ldiv_t_struct_get_quot(a_structure) ((( ldiv_t*) (a_structure))->quot)

#define ldiv_t_struct_set_quot(a_structure,a_value) do {((( ldiv_t*)(a_structure)))->quot = (a_value);}while(0)

#define ldiv_t_struct_get_rem(a_structure) ((( ldiv_t*) (a_structure))->rem)

#define ldiv_t_struct_set_rem(a_structure,a_value) do {((( ldiv_t*)(a_structure)))->rem = (a_value);}while(0)

#define sizeof_ldiv_t (sizeof( ldiv_t))
#define sizeof_drand48_data (sizeof(struct drand48_data))
/*
 * C include file to generate Liberty wrappers for C standard library
 */

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#include <errno.h>

#define text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define io_fclose(p) (fclose((FILE*)(p)))
#define io_flush(p) (fflush((FILE*)(p)))
#define io_getc(f) (getc(((FILE*)(f))))
#define io_putc(b, f) (putc((b),((FILE*)(f))))
#define io_ungetc(b, f) (ungetc((b), (FILE*)(f)))
#define io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_feof(f) (feof(((FILE*)(f))))
#define io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define io_remove(f) (remove(((char*)(f))))
#define io_fseek(f, o) (fseek((FILE*)(f),(o),SEEK_SET))
#define io_ftell(f) ((EIF_INTEGER_64)ftell((FILE*)(f)))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
   extern int read_stdin(EIF_CHARACTER *buffer, int size);
#endif

extern void io_copy(char*source, char*target);
extern int io_file_exists(char*source);
extern int io_same_physical_file(char*path1,char*path2);
/* POSIX include files to be wrapped for Liberty Eiffel */

// This list was taken from Wikipedia (at http://en.wikipedia.org/wiki/C_POSIX_library )

#include <aio.h>
#include <arpa/inet.h>
#include <assert.h>
#include <complex.h>
#include <cpio.h>
// Also in standard C lib: #include <ctype.h>
#include <dirent.h>
// Access to dynamic linking loader (provided by dlfcn.h) is provided by dynamic-linking (sub)cluster
// Also in standard C lib: ##include <errno.h>
#include <fcntl.h>
#include <fenv.h>
// Also in standard C lib: ##include <float.h>
#include <fmtmsg.h>
#include <fnmatch.h>
#include <ftw.h>
#include <glob.h>
#include <grp.h>
#include <iconv.h>
#include <inttypes.h>
#include <iso646.h>
#include <langinfo.h>
#include <libgen.h>
#include <limits.h>
#include <locale.h>
// Also in standard C lib: ##include <math.h>
#include <monetary.h>
#include <mqueue.h>
#include <net/if.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <nl_types.h>
#include <poll.h>
#include <pthread.h>
#include <pwd.h>
#include <regex.h>
#include <sched.h>
#include <search.h>
#include <semaphore.h>
#include <setjmp.h>
#include <signal.h>
#include <spawn.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
// Also in standard C lib: ##include <stdio.h>
// Also in standard C lib: ##include <stdlib.h>
// Also in standard C lib: ##include <string.h>
#include <strings.h>
#include <stropts.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/resource.h>
#include <sys/select.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/un.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <syslog.h>
#include <tar.h>
#include <termios.h>
#include <tgmath.h>
// Also in standard C lib: ##include <time.h>
#include <ulimit.h>
#include <unistd.h>
#include <utime.h>
#include <utmpx.h>
#include <wchar.h>
#include <wctype.h>
#include <wordexp.h>
/*
** This file have been created by wrapper-generator.
** Any change will be lost by the next execution of the tool.
*/
#define in6_pktinfo_struct_get_ipi6_ifindex(a_structure) (((struct in6_pktinfo*) (a_structure))->ipi6_ifindex)

#define in6_pktinfo_struct_set_ipi6_ifindex(a_structure,a_value) do {(((struct in6_pktinfo*)(a_structure)))->ipi6_ifindex = (a_value);}while(0)

#define sizeof_in6_pktinfo (sizeof(struct in6_pktinfo))
#define ip6_mtuinfo_struct_get_ip6m_mtu(a_structure) (((struct ip6_mtuinfo*) (a_structure))->ip6m_mtu)

#define ip6_mtuinfo_struct_set_ip6m_mtu(a_structure,a_value) do {(((struct ip6_mtuinfo*)(a_structure)))->ip6m_mtu = (a_value);}while(0)

#define sizeof_ip6_mtuinfo (sizeof(struct ip6_mtuinfo))
#define ipv6_mreq_struct_get_ipv6mr_interface(a_structure) (((struct ipv6_mreq*) (a_structure))->ipv6mr_interface)

#define ipv6_mreq_struct_set_ipv6mr_interface(a_structure,a_value) do {(((struct ipv6_mreq*)(a_structure)))->ipv6mr_interface = (a_value);}while(0)

#define sizeof_ipv6_mreq (sizeof(struct ipv6_mreq))
#define sizeof_ip_mreq (sizeof(struct ip_mreq))
#define ip_msfilter_struct_get_imsf_fmode(a_structure) (((struct ip_msfilter*) (a_structure))->imsf_fmode)

#define ip_msfilter_struct_set_imsf_fmode(a_structure,a_value) do {(((struct ip_msfilter*)(a_structure)))->imsf_fmode = (a_value);}while(0)

#define ip_msfilter_struct_get_imsf_numsrc(a_structure) (((struct ip_msfilter*) (a_structure))->imsf_numsrc)

#define ip_msfilter_struct_set_imsf_numsrc(a_structure,a_value) do {(((struct ip_msfilter*)(a_structure)))->imsf_numsrc = (a_value);}while(0)

#define ip_msfilter_struct_get_imsf_slist(a_structure) (((struct ip_msfilter*) (a_structure))->imsf_slist)

#define ip_msfilter_struct_set_imsf_slist(a_structure,a_value) do {(((struct ip_msfilter*)(a_structure)))->imsf_slist = (a_value);}while(0)

#define sizeof_ip_msfilter (sizeof(struct ip_msfilter))
#define sizeof_in6_addr (sizeof(struct in6_addr))
#define sockaddr_in6_struct_get_sin6_family(a_structure) (((struct sockaddr_in6*) (a_structure))->sin6_family)

#define sockaddr_in6_struct_set_sin6_family(a_structure,a_value) do {(((struct sockaddr_in6*)(a_structure)))->sin6_family = (a_value);}while(0)

#define sockaddr_in6_struct_get_sin6_port(a_structure) (((struct sockaddr_in6*) (a_structure))->sin6_port)

#define sockaddr_in6_struct_set_sin6_port(a_structure,a_value) do {(((struct sockaddr_in6*)(a_structure)))->sin6_port = (a_value);}while(0)

#define sockaddr_in6_struct_get_sin6_flowinfo(a_structure) (((struct sockaddr_in6*) (a_structure))->sin6_flowinfo)

#define sockaddr_in6_struct_set_sin6_flowinfo(a_structure,a_value) do {(((struct sockaddr_in6*)(a_structure)))->sin6_flowinfo = (a_value);}while(0)

#define sockaddr_in6_struct_get_sin6_scope_id(a_structure) (((struct sockaddr_in6*) (a_structure))->sin6_scope_id)

#define sockaddr_in6_struct_set_sin6_scope_id(a_structure,a_value) do {(((struct sockaddr_in6*)(a_structure)))->sin6_scope_id = (a_value);}while(0)

#define sizeof_sockaddr_in6 (sizeof(struct sockaddr_in6))
#define sizeof_ip_mreq_source (sizeof(struct ip_mreq_source))
#define tcp_md5sig_struct_get_tcpm_keylen(a_structure) (((struct tcp_md5sig*) (a_structure))->tcpm_keylen)

#define tcp_md5sig_struct_set_tcpm_keylen(a_structure,a_value) do {(((struct tcp_md5sig*)(a_structure)))->tcpm_keylen = (a_value);}while(0)

#define tcp_md5sig_struct_get_tcpm_key(a_structure) (((struct tcp_md5sig*) (a_structure))->tcpm_key)

#define tcp_md5sig_struct_set_tcpm_key(a_structure,a_value) do {(((struct tcp_md5sig*)(a_structure)))->tcpm_key = (a_value);}while(0)

#define sizeof_tcp_md5sig (sizeof(struct tcp_md5sig))
#define tcphdr_struct_get_source(a_structure) (((struct tcphdr*) (a_structure))->source)

#define tcphdr_struct_set_source(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->source = (a_value);}while(0)

#define tcphdr_struct_get_dest(a_structure) (((struct tcphdr*) (a_structure))->dest)

#define tcphdr_struct_set_dest(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->dest = (a_value);}while(0)

#define tcphdr_struct_get_seq(a_structure) (((struct tcphdr*) (a_structure))->seq)

#define tcphdr_struct_set_seq(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->seq = (a_value);}while(0)

#define tcphdr_struct_get_ack_seq(a_structure) (((struct tcphdr*) (a_structure))->ack_seq)

#define tcphdr_struct_set_ack_seq(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->ack_seq = (a_value);}while(0)

#define tcphdr_struct_get_res1(a_structure) (((struct tcphdr*) (a_structure))->res1)

#define tcphdr_struct_set_res1(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->res1 = (a_value);}while(0)

#define tcphdr_struct_get_doff(a_structure) (((struct tcphdr*) (a_structure))->doff)

#define tcphdr_struct_set_doff(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->doff = (a_value);}while(0)

#define tcphdr_struct_get_fin(a_structure) (((struct tcphdr*) (a_structure))->fin)

#define tcphdr_struct_set_fin(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->fin = (a_value);}while(0)

#define tcphdr_struct_get_syn(a_structure) (((struct tcphdr*) (a_structure))->syn)

#define tcphdr_struct_set_syn(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->syn = (a_value);}while(0)

#define tcphdr_struct_get_rst(a_structure) (((struct tcphdr*) (a_structure))->rst)

#define tcphdr_struct_set_rst(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->rst = (a_value);}while(0)

#define tcphdr_struct_get_psh(a_structure) (((struct tcphdr*) (a_structure))->psh)

#define tcphdr_struct_set_psh(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->psh = (a_value);}while(0)

#define tcphdr_struct_get_ack(a_structure) (((struct tcphdr*) (a_structure))->ack)

#define tcphdr_struct_set_ack(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->ack = (a_value);}while(0)

#define tcphdr_struct_get_urg(a_structure) (((struct tcphdr*) (a_structure))->urg)

#define tcphdr_struct_set_urg(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->urg = (a_value);}while(0)

#define tcphdr_struct_get_res2(a_structure) (((struct tcphdr*) (a_structure))->res2)

#define tcphdr_struct_set_res2(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->res2 = (a_value);}while(0)

#define tcphdr_struct_get_window(a_structure) (((struct tcphdr*) (a_structure))->window)

#define tcphdr_struct_set_window(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->window = (a_value);}while(0)

#define tcphdr_struct_get_check_field(a_structure) (((struct tcphdr*) (a_structure))->check)

#define tcphdr_struct_set_check_field(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->check = (a_value);}while(0)

#define tcphdr_struct_get_urg_ptr(a_structure) (((struct tcphdr*) (a_structure))->urg_ptr)

#define tcphdr_struct_set_urg_ptr(a_structure,a_value) do {(((struct tcphdr*)(a_structure)))->urg_ptr = (a_value);}while(0)

#define sizeof_tcphdr (sizeof(struct tcphdr))
#define ifconf_struct_get_ifc_len(a_structure) (((struct ifconf*) (a_structure))->ifc_len)

#define ifconf_struct_set_ifc_len(a_structure,a_value) do {(((struct ifconf*)(a_structure)))->ifc_len = (a_value);}while(0)

#define sizeof_ifconf (sizeof(struct ifconf))
#define ifmap_struct_get_mem_start(a_structure) (((struct ifmap*) (a_structure))->mem_start)

#define ifmap_struct_set_mem_start(a_structure,a_value) do {(((struct ifmap*)(a_structure)))->mem_start = (a_value);}while(0)

#define ifmap_struct_get_mem_end(a_structure) (((struct ifmap*) (a_structure))->mem_end)

#define ifmap_struct_set_mem_end(a_structure,a_value) do {(((struct ifmap*)(a_structure)))->mem_end = (a_value);}while(0)

#define ifmap_struct_get_base_addr(a_structure) (((struct ifmap*) (a_structure))->base_addr)

#define ifmap_struct_set_base_addr(a_structure,a_value) do {(((struct ifmap*)(a_structure)))->base_addr = (a_value);}while(0)

#define ifmap_struct_get_irq(a_structure) (((struct ifmap*) (a_structure))->irq)

#define ifmap_struct_set_irq(a_structure,a_value) do {(((struct ifmap*)(a_structure)))->irq = (a_value);}while(0)

#define ifmap_struct_get_dma(a_structure) (((struct ifmap*) (a_structure))->dma)

#define ifmap_struct_set_dma(a_structure,a_value) do {(((struct ifmap*)(a_structure)))->dma = (a_value);}while(0)

#define ifmap_struct_get_port(a_structure) (((struct ifmap*) (a_structure))->port)

#define ifmap_struct_set_port(a_structure,a_value) do {(((struct ifmap*)(a_structure)))->port = (a_value);}while(0)

#define sizeof_ifmap (sizeof(struct ifmap))
#define if_nameindex_struct_get_if_index(a_structure) (((struct if_nameindex*) (a_structure))->if_index)

#define if_nameindex_struct_set_if_index(a_structure,a_value) do {(((struct if_nameindex*)(a_structure)))->if_index = (a_value);}while(0)

#define if_nameindex_struct_get_if_name(a_structure) (((struct if_nameindex*) (a_structure))->if_name)

#define if_nameindex_struct_set_if_name(a_structure,a_value) do {(((struct if_nameindex*)(a_structure)))->if_name = (a_value);}while(0)

#define sizeof_if_nameindex (sizeof(struct if_nameindex))
#define group_filter_struct_get_gf_interface(a_structure) (((struct group_filter*) (a_structure))->gf_interface)

#define group_filter_struct_set_gf_interface(a_structure,a_value) do {(((struct group_filter*)(a_structure)))->gf_interface = (a_value);}while(0)

#define group_filter_struct_get_gf_fmode(a_structure) (((struct group_filter*) (a_structure))->gf_fmode)

#define group_filter_struct_set_gf_fmode(a_structure,a_value) do {(((struct group_filter*)(a_structure)))->gf_fmode = (a_value);}while(0)

#define group_filter_struct_get_gf_numsrc(a_structure) (((struct group_filter*) (a_structure))->gf_numsrc)

#define group_filter_struct_set_gf_numsrc(a_structure,a_value) do {(((struct group_filter*)(a_structure)))->gf_numsrc = (a_value);}while(0)

#define group_filter_struct_get_gf_slist(a_structure) (((struct group_filter*) (a_structure))->gf_slist)

#define group_filter_struct_set_gf_slist(a_structure,a_value) do {(((struct group_filter*)(a_structure)))->gf_slist = (a_value);}while(0)

#define sizeof_group_filter (sizeof(struct group_filter))
#define tcp_info_struct_get_tcpi_state(a_structure) (((struct tcp_info*) (a_structure))->tcpi_state)

#define tcp_info_struct_set_tcpi_state(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_state = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_ca_state(a_structure) (((struct tcp_info*) (a_structure))->tcpi_ca_state)

#define tcp_info_struct_set_tcpi_ca_state(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_ca_state = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_retransmits(a_structure) (((struct tcp_info*) (a_structure))->tcpi_retransmits)

#define tcp_info_struct_set_tcpi_retransmits(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_retransmits = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_probes(a_structure) (((struct tcp_info*) (a_structure))->tcpi_probes)

#define tcp_info_struct_set_tcpi_probes(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_probes = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_backoff(a_structure) (((struct tcp_info*) (a_structure))->tcpi_backoff)

#define tcp_info_struct_set_tcpi_backoff(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_backoff = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_options(a_structure) (((struct tcp_info*) (a_structure))->tcpi_options)

#define tcp_info_struct_set_tcpi_options(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_options = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_snd_wscale(a_structure) (((struct tcp_info*) (a_structure))->tcpi_snd_wscale)

#define tcp_info_struct_set_tcpi_snd_wscale(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_snd_wscale = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rcv_wscale(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rcv_wscale)

#define tcp_info_struct_set_tcpi_rcv_wscale(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rcv_wscale = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rto(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rto)

#define tcp_info_struct_set_tcpi_rto(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rto = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_ato(a_structure) (((struct tcp_info*) (a_structure))->tcpi_ato)

#define tcp_info_struct_set_tcpi_ato(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_ato = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_snd_mss(a_structure) (((struct tcp_info*) (a_structure))->tcpi_snd_mss)

#define tcp_info_struct_set_tcpi_snd_mss(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_snd_mss = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rcv_mss(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rcv_mss)

#define tcp_info_struct_set_tcpi_rcv_mss(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rcv_mss = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_unacked(a_structure) (((struct tcp_info*) (a_structure))->tcpi_unacked)

#define tcp_info_struct_set_tcpi_unacked(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_unacked = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_sacked(a_structure) (((struct tcp_info*) (a_structure))->tcpi_sacked)

#define tcp_info_struct_set_tcpi_sacked(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_sacked = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_lost(a_structure) (((struct tcp_info*) (a_structure))->tcpi_lost)

#define tcp_info_struct_set_tcpi_lost(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_lost = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_retrans(a_structure) (((struct tcp_info*) (a_structure))->tcpi_retrans)

#define tcp_info_struct_set_tcpi_retrans(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_retrans = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_fackets(a_structure) (((struct tcp_info*) (a_structure))->tcpi_fackets)

#define tcp_info_struct_set_tcpi_fackets(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_fackets = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_last_data_sent(a_structure) (((struct tcp_info*) (a_structure))->tcpi_last_data_sent)

#define tcp_info_struct_set_tcpi_last_data_sent(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_last_data_sent = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_last_ack_sent(a_structure) (((struct tcp_info*) (a_structure))->tcpi_last_ack_sent)

#define tcp_info_struct_set_tcpi_last_ack_sent(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_last_ack_sent = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_last_data_recv(a_structure) (((struct tcp_info*) (a_structure))->tcpi_last_data_recv)

#define tcp_info_struct_set_tcpi_last_data_recv(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_last_data_recv = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_last_ack_recv(a_structure) (((struct tcp_info*) (a_structure))->tcpi_last_ack_recv)

#define tcp_info_struct_set_tcpi_last_ack_recv(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_last_ack_recv = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_pmtu(a_structure) (((struct tcp_info*) (a_structure))->tcpi_pmtu)

#define tcp_info_struct_set_tcpi_pmtu(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_pmtu = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rcv_ssthresh(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rcv_ssthresh)

#define tcp_info_struct_set_tcpi_rcv_ssthresh(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rcv_ssthresh = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rtt(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rtt)

#define tcp_info_struct_set_tcpi_rtt(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rtt = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rttvar(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rttvar)

#define tcp_info_struct_set_tcpi_rttvar(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rttvar = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_snd_ssthresh(a_structure) (((struct tcp_info*) (a_structure))->tcpi_snd_ssthresh)

#define tcp_info_struct_set_tcpi_snd_ssthresh(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_snd_ssthresh = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_snd_cwnd(a_structure) (((struct tcp_info*) (a_structure))->tcpi_snd_cwnd)

#define tcp_info_struct_set_tcpi_snd_cwnd(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_snd_cwnd = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_advmss(a_structure) (((struct tcp_info*) (a_structure))->tcpi_advmss)

#define tcp_info_struct_set_tcpi_advmss(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_advmss = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_reordering(a_structure) (((struct tcp_info*) (a_structure))->tcpi_reordering)

#define tcp_info_struct_set_tcpi_reordering(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_reordering = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rcv_rtt(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rcv_rtt)

#define tcp_info_struct_set_tcpi_rcv_rtt(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rcv_rtt = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_rcv_space(a_structure) (((struct tcp_info*) (a_structure))->tcpi_rcv_space)

#define tcp_info_struct_set_tcpi_rcv_space(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_rcv_space = (a_value);}while(0)

#define tcp_info_struct_get_tcpi_total_retrans(a_structure) (((struct tcp_info*) (a_structure))->tcpi_total_retrans)

#define tcp_info_struct_set_tcpi_total_retrans(a_structure,a_value) do {(((struct tcp_info*)(a_structure)))->tcpi_total_retrans = (a_value);}while(0)

#define sizeof_tcp_info (sizeof(struct tcp_info))
#define sockaddr_in_struct_get_sin_family(a_structure) (((struct sockaddr_in*) (a_structure))->sin_family)

#define sockaddr_in_struct_set_sin_family(a_structure,a_value) do {(((struct sockaddr_in*)(a_structure)))->sin_family = (a_value);}while(0)

#define sockaddr_in_struct_get_sin_port(a_structure) (((struct sockaddr_in*) (a_structure))->sin_port)

#define sockaddr_in_struct_set_sin_port(a_structure,a_value) do {(((struct sockaddr_in*)(a_structure)))->sin_port = (a_value);}while(0)

#define sockaddr_in_struct_get_sin_zero(a_structure) (((struct sockaddr_in*) (a_structure))->sin_zero)

#define sockaddr_in_struct_set_sin_zero(a_structure,a_value) do {(((struct sockaddr_in*)(a_structure)))->sin_zero = (a_value);}while(0)

#define sizeof_sockaddr_in (sizeof(struct sockaddr_in))
#define group_req_struct_get_gr_interface(a_structure) (((struct group_req*) (a_structure))->gr_interface)

#define group_req_struct_set_gr_interface(a_structure,a_value) do {(((struct group_req*)(a_structure)))->gr_interface = (a_value);}while(0)

#define sizeof_group_req (sizeof(struct group_req))
#define group_source_req_struct_get_gsr_interface(a_structure) (((struct group_source_req*) (a_structure))->gsr_interface)

#define group_source_req_struct_set_gsr_interface(a_structure,a_value) do {(((struct group_source_req*)(a_structure)))->gsr_interface = (a_value);}while(0)

#define sizeof_group_source_req (sizeof(struct group_source_req))
#define ifaddr_struct_get_ifa_ifp(a_structure) (((struct ifaddr*) (a_structure))->ifa_ifp)

#define ifaddr_struct_set_ifa_ifp(a_structure,a_value) do {(((struct ifaddr*)(a_structure)))->ifa_ifp = (a_value);}while(0)

#define ifaddr_struct_get_ifa_next(a_structure) (((struct ifaddr*) (a_structure))->ifa_next)

#define ifaddr_struct_set_ifa_next(a_structure,a_value) do {(((struct ifaddr*)(a_structure)))->ifa_next = (a_value);}while(0)

#define sizeof_ifaddr (sizeof(struct ifaddr))
#define in_addr_struct_get_s_addr(a_structure) (((struct in_addr*) (a_structure))->s_addr)

#define in_addr_struct_set_s_addr(a_structure,a_value) do {(((struct in_addr*)(a_structure)))->s_addr = (a_value);}while(0)

#define sizeof_in_addr (sizeof(struct in_addr))
#define rpcent_struct_get_r_name(a_structure) (((struct rpcent*) (a_structure))->r_name)

#define rpcent_struct_set_r_name(a_structure,a_value) do {(((struct rpcent*)(a_structure)))->r_name = (a_value);}while(0)

#define rpcent_struct_get_r_aliases(a_structure) (((struct rpcent*) (a_structure))->r_aliases)

#define rpcent_struct_set_r_aliases(a_structure,a_value) do {(((struct rpcent*)(a_structure)))->r_aliases = (a_value);}while(0)

#define rpcent_struct_get_r_number(a_structure) (((struct rpcent*) (a_structure))->r_number)

#define rpcent_struct_set_r_number(a_structure,a_value) do {(((struct rpcent*)(a_structure)))->r_number = (a_value);}while(0)

#define sizeof_rpcent (sizeof(struct rpcent))
#define sizeof_ifreq (sizeof(struct ifreq))
#define sizeof_iface (sizeof(struct iface))
/* C Header Pass 1: */
typedef union _se_agent se_agent;
typedef struct _se_agent0 se_agent0;
typedef struct S204 T204;
typedef struct S115 T115;
typedef struct S7 T7;
typedef int T137;
typedef struct S201 T201;
typedef struct S194 T194;
typedef struct S65 T65;
typedef struct S195 T195;
typedef struct S89 T89;
typedef struct S51 T51;
typedef struct S63 T63;
typedef struct S179 T179;
typedef struct S192 T192;
typedef T0 T189;
typedef struct S25 T25;
/* C Header Pass 2: */
typedef T0**T212;
#define M212 NULL
typedef T0**T211;
#define M211 NULL
typedef T115*T203;
#define M203 NULL
typedef T0**T200;
#define M200 NULL
typedef T0**T193;
#define M193 NULL
typedef T3*T9;
#define M9 NULL
/* C Header Pass 3: */
struct S115{T2 _capacity;T0* _item_memory;};
int se_cmpT115(T115* o1,T115* o2);
/* C Header Pass 4: */
struct S204{T0* _item;};
extern T204 M204;
extern T137 M137;
extern T115 M115;
struct S201{T2 _generation;T203 _storage;T2 _capacity;T2 _upper;};
extern T201 M201;
struct S194{T2 _generation;T200 _storage;T2 _capacity;T2 _upper;};
extern T194 M194;
struct S65{T115 _recycling_item;T0* _strings;int _items_comparator;};
extern T65 M65;
struct S195{T0* _item;};
extern T195 M195;
struct S89{Tid id;T0* _right;T0* _left;};
extern T89 M89;
struct S51{Tid id;};
extern T51 M51;
struct S63{Tid id;T2 _buffer_position;T9 _buffer;T2 _capacity;};
extern T63 M63;
struct S179{T2 _child_process_id;};
extern T179 M179;
struct S192{T2 _generation;T193 _storage;T2 _capacity;T2 _upper;};
extern T192 M192;
struct S7{Tid id;T2 _generation;T9 _storage;T2 _storage_lower;T2 _count;T2 _capacity;T2 _storage_signature_count;T6 _has_storage_signature;};
extern T7 M7;
struct S25{T0* _children;};
extern T25 M25;
extern char*s13_1210;
extern char*s179_1265;
extern char*s179_1327430360;
extern char*s25_603433087;
extern char*s13_14150;
extern char*s25_59640;
extern char*s13_1216703285;
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define SE_BOOST 1
void se_print_run_time_stack (void);
void se_signal_handler(int sig);
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

typedef union u_fso_header fso_header;

union u_fso_header{
  void* flag;
  void* next;/* accurately typed as gcXX* in actual fso headers */
};

union u_rsoh{
  rso_header header;
  double padding;
};

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* Next one when in free list (rsocfl) or in na_env->chunk_list. */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list; /*List of chunks of that type that have a non-null free_list_of_large*/
  void (*gc_mark)(T0*);
  int space_used;
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
/*The generic se_agent0 definition:*/
struct _se_agent0{
Tid id;
Tid creation_mold_id;
void(*afp)(se_agent*);void(*gc_mark_agent_mold)(se_agent*);
int(*eq)(se_agent*,se_agent*);
};
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*INTEGER_32*/void r2unlock_tagged_out(void);
extern T0*oBC13tagged_out_memory_pool;
extern int fBC13tagged_out_memory_pool;
/*INTEGER_32*/T0* r2tagged_out_memory_pool(void);
/*INTEGER_32*/void r2lock_tagged_out(void);
/*INTEGER_32*/T2 r2max(T2 C,T2 a1);
/*INTEGER_32*/void r2out_in_tagged_out_memory(T2 C);
/*INTEGER_32*/T0* r2tagged_out_memory(void);
extern T0*oBC13tagged_out_memory_ref;
/*INTEGER_32*/T0* r2out(T2 C);
extern T0*oBC13tagged_out_memories;
extern int fBC13tagged_out_memories;
/*INTEGER_32*/T0* r2tagged_out_memories(void);
/*INTEGER_32*/void r2append_in(T2 C,T0* a1);
/*INTEGER_32*/T3 r2decimal_digit(T2 C);
/*INTEGER_8*/void r1times(T1 C,T0* a1);
/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/T203 r203realloc(T203 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/void r203copy_from(T203 C,T203 a1,T2 a2);
/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/void r203copy_slice_from(T203 C,T203 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/void r203clear_all(T203 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/T200 r200realloc(T200 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r200copy_from(T200 C,T200 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r200copy_slice_from(T200 C,T200 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[STRING]*/void r200clear(T200 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/void r200clear_all(T200 C,T2 a1);
/*NATIVE_ARRAY[POSIX_PROCESS]*/T193 r193realloc(T193 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193copy_from(T193 C,T193 a1,T2 a2);
/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193copy_slice_from(T193 C,T193 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193clear(T193 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193clear_all(T193 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_slice_from(T9 C,T9 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/void r9move(T9 C,T2 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(T9 C,T2 a1);
/*STRING*/T0* r7_ix_124(T7* C,T0* a1);
/*STRING*/void r7copy(T7* C,T0* a1);
/*STRING*/void r7ensure_capacity(T7* C,T2 a1);
/*STRING*/void r7set_storage_signature(T7* C);
/*STRING*/void r7swap(T7* C,T2 a1,T2 a2);
/*STRING*/void r7put(T7* C,T3 a1,T2 a2);
/*STRING*/void r7insert_character(T7* C,T3 a1,T2 a2);
/*STRING*/T0* r7twin(T7* C);
/*STRING*/void r7extend(T7* C,T3 a1);
/*STRING*/void r7print_on(T7* C,T0* a1);
/*STRING*/void r7clear_count(T7* C);
/*STRING*/void r7make(T7* C,T2 a1);
/*STRING*/void r7next_generation(T7* C);
/*STRING*/T3 r7item(T7* C,T2 a1);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201put(T201* C,T115 a1,T2 a2);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201add_last(T201* C,T115 a1);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/T6 r201is_empty(T201* C);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/T6 r201valid_index(T201* C,T2 a1);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201make(T201* C,T2 a1);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201next_generation(T201* C);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201add(T201* C,T115 a1,T2 a2);
/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201move(T201* C,T2 a1,T2 a2,T2 a3);
/*FAST_ARRAY[POSIX_PROCESS]*/void r192add_last(T192* C,T0* a1);
/*FAST_ARRAY[POSIX_PROCESS]*/void r192next_generation(T192* C);
/*FAST_ARRAY[POSIX_PROCESS]*/void r192with_capacity(T192* C,T2 a1);
/*FAST_ARRAY[POSIX_PROCESS]*/void r192mark_native_arrays(T192* C);
/*WEAK_REFERENCE[STRING]*/void r204set_item(T204* C,T0* a1);
/*STACK[STRING]*/void r194push(T194* C,T0* a1);
/*STACK[STRING]*/void r194pop(T194* C);
/*STACK[STRING]*/T0* r194top(T194* C);
/*STACK[STRING]*/void r194make(T194* C);
/*STACK[STRING]*/void r194next_generation(T194* C);
/*STACK[STRING]*/void r194with_capacity(T194* C,T2 a1);
/*STRING_RECYCLING_ITEM_SORTER*/T6 r137lt(T115 a1,T115 a2);
/*STRING_RECYCLING_ITEM_SORTER*/T2 r137insert_index(T0* a1,T115 a2);
/*STRING_RECYCLING_ITEM_SORTER*/T6 r137lte(T115 a1,T115 a2);
/*STRING_RECYCLING_ITEM*/void r115set_item(T115* C,T0* a1);
/*STRING_RECYCLING_ITEM*/T0* r115item(T115* C);
/*STRING_RECYCLING_POOL*/void r65make(T65* C);
/*STRING_RECYCLING_POOL*/void r65recycle(T65* C,T0* a1);
/*STRING_RECYCLING_POOL*/T0* r65best_fit(T65* C,T2 a1);
/*ROPE*/T0* r89_ix_124(T89* C,T0* a1);
/*ROPE*/T2 r89count(T89* C);
/*ROPE*/void r89from_strings(T89* C,T0* a1,T0* a2);
/*ROPE*/T2 r89split_index(T89* C);
/*ROPE*/void r89print_on(T89* C,T0* a1);
/*ROPE*/T3 r89item(T89* C,T2 a1);
/*STD_ERROR*/void r51put_natively_stored_string(T0* a1);
/*STD_ERROR*/void r51put_string(T51* C,T0* a1);
/*STD_ERROR*/T0* r51as_output_stream(T51* C);
/*STD_ERROR*/void r51put_abstract_string(T0* a1);
/*STD_OUTPUT*/void r63put_natively_stored_string(T63* C,T0* a1);
extern T0*oBC13std_output;
extern int fBC13std_output;
/*STD_OUTPUT*/T0* r63std_output(void);
/*STD_OUTPUT*/void r63flush(T63* C);
/*STD_OUTPUT*/void r63put_string(T63* C,T0* a1);
/*STD_OUTPUT*/T0* r63as_output_stream(T63* C);
/*STD_OUTPUT*/void r63put_abstract_string(T63* C,T0* a1);
/*STD_OUTPUT*/void r63se_atexit(void);
/*STD_OUTPUT*/void r63filtered_flush(T63* C);
/*STD_OUTPUT*/void r63make(T63* C);
/*STD_OUTPUT*/void r63filtered_put_character(T63* C,T3 a1);
/*STD_OUTPUT*/void r63write_buffer(T63* C);
T179*create179start(void);
/*MY_CHILD*/T0* r179std_output(void);
/*MY_CHILD*/void r179start(T179* C);
/*MY_CHILD*/void r179run(void);
extern T0*oBC13std_error;
/*MY_CHILD*/void r179crash(T179* C);
/*MY_CHILD*/void r179not_yet_implemented(T179* C);
typedef struct _se_agenT25f25l8c12 se_agenT25f25l8c12;
struct _se_agenT25f25l8c12{Tid id;
int creation_mold_id;
void(*afp)(se_agenT25f25l8c12*);
void(*gc_mark_agent_mold)(se_agenT25f25l8c12*);
int (*eq)(se_agent*,se_agent*);
T0* closed_C;};
/*agent creation*/T0*agenT25f25l8c12(T0* closed_C);
void gc_mark_agenT25f25l8c12(se_agenT25f25l8c12*u);
/*FORKING*/T0* r25std_output(void);
/*FORKING*/void r25print(T0* a1);
/*FORKING*/void r25add_child(T25* C);
/*FORKING*/void r25make(T25* C);
void agent_launcher_INTEGER_8(/*agent*/T0*a,T1 a1);
union _se_agent{T0 s0;se_agent0 u0;
se_agenT25f25l8c12 uagenT25f25l8c12;
};
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define SE_AGENTS 1
#define EIF_AGENT se_agent*

se_agent* new_agent(Tid id);

#ifdef SE_GC_LIB

  typedef struct B_agent gc_agent;

  struct B_agent {
    se_agent object;
    union {
      void *flag;
      gc_agent *next;
    } header;
  };

  extern gc_agent *store_agent;
  extern gc_agent *gc_free_agent;
  extern int       store_left_agent;
  extern fsoc     *store_chunk_agent;
  extern fsoc      H_agent;
  extern int       gc_info_nb_agent;

  void gc_align_mark_agent(fsoc *c, gc_agent* a);
  void gc_sweep_agent(fsoc *c);

#endif
extern T0*ms13_14150;
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void se_msi1(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
extern na_env na_env212;
extern na_env na_env211;
typedef struct B204 gc204;
struct B204{T204 object;union {void*flag;gc204*next;} header;};
extern gc204*store204;
extern int store_left204;
extern fsoc*store_chunk204;
extern gc204*gc_free204;
extern na_env na_env203;
extern na_env na_env200;
typedef struct B201 gc201;
struct B201{T201 object;union {void*flag;gc201*next;} header;};
extern gc201*store201;
extern int store_left201;
extern fsoc*store_chunk201;
extern gc201*gc_free201;
typedef struct B194 gc194;
struct B194{T194 object;union {void*flag;gc194*next;} header;};
extern gc194*store194;
extern int store_left194;
extern fsoc*store_chunk194;
extern gc194*gc_free194;
typedef struct B65 gc65;
struct B65{T65 object;union {void*flag;gc65*next;} header;};
extern gc65*store65;
extern int store_left65;
extern fsoc*store_chunk65;
extern gc65*gc_free65;
typedef struct B195 gc195;
struct B195{T195 object;union {void*flag;gc195*next;} header;};
extern gc195*store195;
extern int store_left195;
extern fsoc*store_chunk195;
extern gc195*gc_free195;
typedef struct B89 gc89;
struct B89{T89 object;union {void*flag;gc89*next;} header;};
extern gc89*store89;
extern int store_left89;
extern fsoc*store_chunk89;
extern gc89*gc_free89;
typedef struct B51 gc51;
struct B51{T51 object;union {void*flag;gc51*next;} header;};
extern gc51*store51;
extern int store_left51;
extern fsoc*store_chunk51;
extern gc51*gc_free51;
extern na_env na_env193;
typedef struct B63 gc63;
struct B63{T63 object;union {void*flag;gc63*next;} header;};
extern gc63*store63;
extern int store_left63;
extern fsoc*store_chunk63;
extern gc63*gc_free63;
typedef struct B179 gc179;
struct B179{T179 object;union {void*flag;gc179*next;} header;};
extern gc179*store179;
extern int store_left179;
extern fsoc*store_chunk179;
extern gc179*gc_free179;
typedef struct B192 gc192;
struct B192{T192 object;union {void*flag;gc192*next;} header;};
extern gc192*store192;
extern int store_left192;
extern fsoc*store_chunk192;
extern gc192*gc_free192;

#define gc_mark189(x) (((se_agent0*)(x))->gc_mark_agent_mold((se_agent*)(x)))

extern na_env na_env9;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
typedef struct B25 gc25;
struct B25{T25 object;union {void*flag;gc25*next;} header;};
extern gc25*store25;
extern int store_left25;
extern fsoc*store_chunk25;
extern gc25*gc_free25;
void gc_mark212(T212 o);
T212 new212(unsigned int size);
void gc_mark211(T211 o);
T211 new211(unsigned int size);
void gc_sweep204(fsoc*c);
void gc_update_weak_ref_item204(T204* wr);
void gc_mark204(T204*o);
void gc_align_mark204(fsoc*c,gc204*p);
extern fsoc H204;
T204*new204(void);
void gc_mark203(T203 o);
T203 new203(unsigned int size);
void gc_mark200(T200 o);
T200 new200(unsigned int size);
void gc_mark115(T115*o);
void gc_sweep201(fsoc*c);
void gc_mark201(T201*o);
void gc_align_mark201(fsoc*c,gc201*p);
extern fsoc H201;
T201*new201(void);
void gc_sweep194(fsoc*c);
void gc_mark194(T194*o);
void gc_align_mark194(fsoc*c,gc194*p);
extern fsoc H194;
T194*new194(void);
void gc_sweep65(fsoc*c);
void gc_mark65(T65*o);
void gc_align_mark65(fsoc*c,gc65*p);
extern fsoc H65;
T65*new65(void);
void gc_sweep195(fsoc*c);
void gc_mark195(T195*o);
void gc_align_mark195(fsoc*c,gc195*p);
extern fsoc H195;
T195*new195(void);
void gc_sweep89(fsoc*c);
void gc_mark89(T89*o);
void gc_align_mark89(fsoc*c,gc89*p);
extern fsoc H89;
T89*new89(void);
void gc_sweep51(fsoc*c);
void gc_mark51(T51*o);
void gc_align_mark51(fsoc*c,gc51*p);
extern fsoc H51;
T51*new51(void);
void gc_mark193(T193 o);
T193 new193(unsigned int size);
void gc_sweep63(fsoc*c);
void gc_mark63(T63*o);
void gc_align_mark63(fsoc*c,gc63*p);
extern fsoc H63;
T63*new63(void);
void gc_sweep179(fsoc*c);
void gc_mark179(T179*o);
void gc_align_mark179(fsoc*c,gc179*p);
extern fsoc H179;
T179*new179(void);
void gc_sweep192(fsoc*c);
void gc_mark192(T192*o);
void gc_align_mark192(fsoc*c,gc192*p);
extern fsoc H192;
T192*new192(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
void gc_sweep25(fsoc*c);
void gc_mark25(T25*o);
void gc_align_mark25(fsoc*c,gc25*p);
extern fsoc H25;
T25*new25(void);
void Xgc_mark39(T0*o);
extern T25*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 222
extern T7*g[];
extern T7*t[];
extern int se_strucT[];
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
int main(int argc,char*argv[]);

#ifdef __cplusplus
}
#endif
