#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3.99 (LibertyEiffel patched bootstrapper)
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe -Os
*/

#ifdef __cplusplus
}
#endif
#include "forking.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
    /* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
** This file have been created by wrapper-generator.
** Any change will be lost by the next execution of the tool.
*/
#ifndef STANDARD_C_LIBRARY_LIBERTY_PLUGIN
#	define STANDARD_C_LIBRARY_LIBERTY_PLUGIN
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    size_t dummy = fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
/*
** This file have been created by wrapper-generator.
** Any change will be lost by the next execution of the tool.
*/
#ifndef POSIX_LIBERTY_PLUGIN
#	define POSIX_LIBERTY_PLUGIN
#endif

int se_cmpT115(T115* o1,T115* o2){
int R=0;
R = R || ((o1->_capacity) != (o2->_capacity));
R = R || ((o1->_item_memory) != (o2->_item_memory));
return R;
}/*--*/
T204 M204={(void*)0};
T137 M137=0;
T115 M115={0,(void*)0};
T201 M201={0,(void*)0,0,0};
T194 M194={0,(void*)0,0,0};
T65 M65={{0,(void*)0},(void*)0,0};
T195 M195={(void*)0};
T89 M89={89,(void*)0,(void*)0};
T51 M51={51};
T63 M63={63,0,(void*)0,0};
T179 M179={0};
T192 M192={0,(void*)0,0,0};
T7 M7={7,0,(void*)0,0,0,0,0,0};
T25 M25={(void*)0};
/*Aliased storage area or unicode storage.*/
char*s13_1210=".\n\n";
char*s179_1265=").\n";
char*s179_1327430360="Greeting from child process (#";
char*s25_603433087="Father genertaing 5 childred\n";
char*s13_14150="Void";
char*s25_59640="Done\n";
char*s13_1216703285="Some feature is not yet implemented (i.e. feature `not_yet_implemented\' of\nclass ANY has been called somewhere). Just run this code under the debugger\nto know the `not_yet_implemented\' caller.\n\nThe error occured in the type";
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
void se_print_run_time_stack (void) {
  handle(SE_HANDLE_ENTER_PRINT_STACK, NULL);
  fprintf(SE_ERR,"Eiffel program crash at run time.\n");
  fprintf(SE_ERR,"No trace when using option \"-boost\"\n");
  handle(SE_HANDLE_EXIT_PRINT_STACK, NULL);
}

void se_signal_handler(int sig) {
  handle(SE_HANDLE_RUNTIME_ERROR, NULL);
  printf("Received signal %d.\n",sig);
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/

/*
   This file (SmartEiffel/sys/runtime/gc_lib.c) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has been
   selected).
*/
/*
   The `mark_stack_and_registers' C function is called by the Garbage
   Collector (GC) of SmartEiffel. It has to be customized for some systems,
   but also for some C compilers. This file provides some definitions in the
   end and has to be completed for systems which need specific work.

   On some architectures, addresses increase as the stack grows; or,
   conversely, addresses decrease as the stack grows. A C compiler may be
   clever enough to hide some root object inside registers. Unfortunately all
   registers are not always accessible via the C `setjmp' function!

   Thus, in order to be able to use the GC on your architecture/C-compiler,
   you have to provide the correct `mark_stack_and_registers' function.

   What is the `mark_stack_and_registers' function supposed to do?  The
   `mark_stack_and_registers' function is supposed to notify the GC with all
   the possible roots one can find in the C stack and registers by calling the
   `gc_mark' function. A root is an object which must not be collected.  The
   SmartEiffel GC already knows about some root objects like once function
   results or manifest strings. The `mark_stack_and_registers' function has to
   notify the other possible roots. Obviously, one can find in the C stack any
   kind of adresses, but the `gc_mark' function is clever enough to determine
   if the passed pointer is an Eiffel object or not.  When the passed pointer
   reaches some Eiffel object, this object as well as its descendant(s) are
   automatically marked as un-collectable.

   In order to provide the most appropriate `mark_stack_and_registers'
   function, the very first question is to know about the way the C stack is
   managed (addresses of the stack may increase or decrease as the C stack
   grows). The DEFAULT BEHAVIOUR FOR UNKNOWN SYSTEMS is to consider ADDRESSES
   DECREASE AS THE STACK GROWS, as it's the most common case.  The global C
   variable `stack_bottom' is set with some pointer which is supposed to be
   the bottom of the stack (this variable is automatically initialized in the
   C main function).  Note: using the current stack pointer inside
   `mark_stack_and_registers', it is quite obvious to determine if addresses
   increase or not as the C stack grows.  Note2: on some systems, the stack is
   not in contiguous addresses. In such case, `mark_stack_and_registers' has
   to go through all the stack fragments.

   Some roots may be stored only in registers and not in the C stack.  In
   order to reach the registers as well, the first attempt is to use setjmp,
   in the hope that setjmp will save registers in the stack!  Note: this
   technique do not work on processors using windows registers (such as sparc
   processors).

*/

int se_gc_strategy = SE_GC_DEFAULT_MEMORY_STRATEGY;

int collector_counter = 0;

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom=NULL;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

/* Return the index where chunk `c' is (or is to be) in the `gcmt', 
   between `min' and `max' indexes. */
static unsigned int binary_search_in_gcmt(register unsigned int min, 
					  register unsigned int max, 
					  register mch* c){
  register unsigned int mid;
  while (min<max){
    mid=(min+max)>>1;
    if (gcmt[mid]<c)
      min=mid+1;
    else
      max=mid;
  }
  if (gcmt[min]<c)
    return min+1;
  else
    return min;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List)
     in some circumstances.
  */
  rsoc* next; register rsoc *current;
  unsigned int count = rsocfl_count();
  register unsigned int where = gcmt_used;
  register unsigned int how_many;

  if ((count > 50) && (count > (rsoc_count >> 1))) {
    current=rsocfl;
    rsocfl=NULL;
    while (NULL != current) {
      next=current->next;
      if (current->isize == current->header.size) {
	where = binary_search_in_gcmt(0, where-1, (mch*)current);
	how_many = gcmt_used - 1 - where;
	if (how_many > 0)
	  memmove(gcmt+where, gcmt+where+1, how_many*sizeof(mch*));
	free(current); gcmt_used--; rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

int gc_memory_used(void) {
  int i;
  int result = 0;
  mch* mch;
  for (i = gcmt_used; i --> 0; ) {
    mch = gcmt[i];
    switch(mch->state_type) {
    case RSO_USED_CHUNK:
    case FSO_USED_CHUNK:
    case FSO_STORE_CHUNK:
      result += mch->size;
      break;
    default:
      break;
    }
  }
  return result;
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

/* return the mch containing p or NULL if p is not 
 * a valid address or was externally allocated 
 */
mch * gc_find_chunk(void * p){
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if((char*)p<(char*)c+c->size)   /* check for upper bound */
      if (!(FREE_CHUNK(c->state_type))){
	return c;
      }
  }
  return NULL;
}

void gc_mark(void*p) {
  mch * c;
  c = gc_find_chunk(p);
  if(NULL != c) {
    (c->amfp)(c,p);
  }
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10))

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  /* This function is automatically called after each collection
     cycle.
  */
  if (se_gc_strategy == SE_GC_LOW_MEMORY_STRATEGY) {
    fsoc_count_ceil = fsoc_count;
    rsoc_count_ceil = rsoc_count;
    /* Todo: we should also consider to free unused chunks here. */
    return;
  }
  if (se_gc_strategy == SE_GC_HIGH_MEMORY_STRATEGY) {
    fsoc_count_ceil = (256 + fsoc_count) << 2;
    rsoc_count_ceil = (256 + rsoc_count) << 2;
    return;
  }
  /* The SE_GC_DEFAULT_MEMORY_STRATEGY. */
  /* Compute fsoc_count_ceil: */

  /* The lines commented out with --perf-- were killing performance under certain circumstances, *
   * especially with gcc -O3 <FM-15/04/2005>                                                     */

  /* --perf-- if (fsocfl == NULL) { */
  if (fsoc_count >= fsoc_count_ceil) {
    if (fsoc_count_ceil < FSOC_LIMIT) {
      fsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = fsoc_count + (fsoc_count/3);
      if (fsoc_count_ceil < c)
	fsoc_count_ceil = c;
    }
  }
  /* --perf-- }
     else {
     if (fsoc_count_ceil < fsoc_count) {
     fsoc_count_ceil = fsoc_count;
     }
     }
  */
  /* Compute rsoc_count_ceil: */
  /* --perf-- if (rsocfl == NULL) {*/
  if (rsoc_count >= rsoc_count_ceil) {
    if (rsoc_count_ceil < RSOC_LIMIT) {
      rsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = rsoc_count + (rsoc_count / 3);
      if (rsoc_count_ceil < c) {
	rsoc_count_ceil = c;
      }
    }
  }
  /* --perf -- }
     else {
     if (rsoc_count_ceil < rsoc_count) {
     rsoc_count_ceil = rsoc_count;
     }
     }
  */
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the
     new `mch' (Memory Chunk Header).`gcmt_used' is updated.
  */
  unsigned int where=0;
  unsigned how_many;
  if (gcmt_used>0){
    where=binary_search_in_gcmt(0, gcmt_used-1, c);
    if (gcmt_used == gcmt_max) {
      gcmt_max <<= 1;
      gcmt = ((mch**)(se_realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
    }
    how_many = gcmt_used - where;
    if (how_many > 0)    
      memmove(gcmt+where+1, gcmt+where, how_many*sizeof(mch*));
  }
  gcmt[where]=c;
  gcmt_used++;
}

static char*rso_from_store(na_env*nae,unsigned int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	/* No need to register chunks with no free_list_of_large
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	*/
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >=
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0;
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

/* *** To be removed */
#ifdef __TINYC__
static rsoc MRSOC = {
#else
static const rsoc MRSOC = {
#endif
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(unsigned int size) {
  register unsigned int best_size = 0;
  unsigned int acceptable_loss;
  register rsoc *pc, *best_pc, *best_c, *c;
  if (NULL==rsocfl)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  if (SE_GC_DEFAULT_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = (size >> 4);
  else if (SE_GC_LOW_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = 0;
  else /* SE_GC_HIGH_MEMORY_STRATEGY == se_gc_strategy */
    acceptable_loss = (size >> 2);

  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (NULL != best_pc)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  if ((best_size - size) > acceptable_loss){
    do {
      if ((c->header.size >= size) && (c->header.size < best_size)) {
	best_c = c;
	best_pc = pc;
	best_size = c->header.size;
	if ((best_size - size) <= acceptable_loss) break;
      }
      pc=c;
      c=c->next;
    }
    while(NULL!=c);
  }
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,unsigned int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,unsigned int size) {
  rsoc*c=nae->chunk_list;
  unsigned int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if (c->header.size > RSOC_SIZE) {
      if (c->header.size-csize > RSOC_MIN_STORE*4) {
	int csize_left=c->header.size-csize;
	if ((csize_left%sizeof(double))!=0) {
	  csize_left-=(csize_left%sizeof(double));
	  csize=c->header.size-csize_left;
	}
	c->header.size=csize_left;
	c->next=rsocfl;
	rsocfl=c;
	c=(rsoc*)(((char*)c)+csize_left);
	c->isize=0; /* c split from a larger chunk */
	gc_add_into_gcmt((mch*)c);      
	c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
	c->header.swfp=(void(*)(mch*))rsoc_sweep;
      }
      /* since objects bigger than RSOC_SIZE must be the only object in their chunk, we do not want to have
	 some store left after them. Therefore, we do not set csize to c->header.size in an else block
	 here. */
      c->header.size=csize;
    }
    else {
      csize=c->header.size;
    }
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    return rso_from_store(nae,size);
  }
  return NULL;
}

/* size in bytes, including header size */
char*new_na(na_env*nae,unsigned int size) {
  if (size == 0) {
#ifdef SE_BOOST
    handle(SE_HANDLE_RUNTIME_ERROR, NULL);
    se_print_run_time_stack();
    exit(EXIT_FAILURE);
#else
    char msg[512];
    sprintf(msg, "Bad native array size: %d.\n", size);
    error0(msg, NULL);
#endif
  }
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      unsigned int rounded_size= chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    unsigned int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);

  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  }
}

unsigned int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  register unsigned int r=0;
  register rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

unsigned int fsocfl_count(void) {
  register unsigned int r=0;
  register fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;

  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) ||
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not
     yet reached. Otherwise, call the `gc_start()' function and
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a
     new `fsoc' (using the `se_malloc' function). Update various ceils
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    fsoc_count++;
    gc_update_ceils();
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

#if defined(__sparc__) || defined(sparc) || defined(__sparc)
/* For SPARC architecture.
   As this part contains assembly code (asm), you must not use
   the flag -ansi of gcc compiler.
*/

void mark_loop(void) {
  void** max = stack_bottom;
  void** stack_pointer;
  void* stack_top[2]={NULL,NULL};
  stack_pointer = stack_top;
  /* Addresses decrease as the stack grows. */
  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}

void mark_stack_and_registers(void) {
#  if defined(__sparcv9)
  asm(" flushw");
#  else
  asm(" ta      0x3   ! ST_FLUSH_WINDOWS");
#  endif
  mark_loop();
}

#elif defined(__ELATE__) || defined(ELATE)
/* GNU Eiffel's VP (Virtual Processor) garbage collector for Elate.
   (c) 2000 Rudi Chiarito <rudi@amiga.com>

   Thanks to Andy Stout and Kevin Croombs at Tao Group for their
   precious help!

   ChangeLog:
   - 2000-06-12 Rudi Chiarito <rudi@amiga.com>
     * Version 1.0
   - 2001-01-01 Joseph Kiniry <kiniry@acm.org>
     * Integrated with new SE 0.75b
   - 2001-08-10 Rudi Chiarito <rudi@amiga.com>
     * Inlined and optimised range marking
     * Added some more comments
     * Added conditional breakpoint in mark_stack_and_registers
   - 2002-09-21 Rudi Chiarito <rudi@amiga.com>
     * Removed redundant 'ret'
*/

__inline__ void mark_stack_and_registers(void)
{

  void *pointer_to_gc_mark = &gc_mark;

  __asm__ __volatile__
  (
    /*
      WARNING: funky code ahead!
      \t and \n are needed to make the final output easier to read
      while debugging. Hopefully you'll never have to bother with all
      of this.

      Registers:
        p0  pointer to stack block
        p1  pointer to gc_mark()
        p2  scratch pointer
        i0  length of current stack block
        i1  scratch register
    */

#  ifdef __ELATE_SE_DEBUG_GC
   "\tqcall sys/cii/breakpt,(-:-)\n"
#  endif

   "\tsync\n"                          /* spill all the registers */
   "\tsyncreg\n"                       /* to the stack */

   "\tcpy.p %0,p1\n"                   /* pointer to gc_mark() */

   /* pointer to the current stack block */
   "\tcpy.p [gp+PROC_STACK],p0\n"

   /* point to last location in the block, before the descriptor */
   "\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

   /* mark the contents of the current stack block */
   "\twhile p2>=sp\n"
      "\t\tgos p1,(p2 : -)\n"
      "\t\tsub.p 4,p2\n"
   "\tendwhile\n"

   /* now scan other blocks (if any) */

   "\tloop\n"
      "\t\tcpy.p [p0 - STK_SIZE + STK_LINK],p0\n" /* get next block */
      "\t\tbreakif p0=NULL\n"

      /* point to last location in the block, before the descriptor */
      "\t\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

      /* mark this block */
      "\t\twhile p2>=p0\n"

         "\t\t\tgos p1,(p2 : -)\n"
         "\t\t\tsub.p 4,p2\n"
      "\t\tendwhile\n"
   "\tendloop\n"

   : /* no output */
   : "p" (pointer_to_gc_mark)
   : "p0", "p1", "p2", "i0" 
   );
}

#elif defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)

/****************************************************************************
 * Generic code for architectures where addresses increase as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers) + ((sizeof(JMP_BUF)/sizeof(void*))-1);
  /* stack_pointer will traverse the JMP_BUF as well (jmp_buf size is added, 
     otherwise stack_pointer would be below the registers structure). */

#  if !defined(SE_BOOST)
  if (stack_pointer < max) {
    fprintf(stderr, "Wrong stack direction: your stack decrease as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer >= max) {
    gc_mark(*(stack_pointer--));
  }
}
#else

/****************************************************************************
 * Generic code for architectures where addresses decrease as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers);

#  if !defined(SE_BOOST)
  if (stack_pointer > max) {
    fprintf(stderr, "Wrong stack direction: the stack addresses increase as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}
#endif

unsigned int fsoc_count_ceil=80;
unsigned int rsoc_count_ceil=18;

/*INTEGER_32*/void r2unlock_tagged_out(void){
r65recycle((T65*)(r2tagged_out_memory_pool()),(/*RF2*/(((T195*)oBC13tagged_out_memory_ref))->_item/*p*/));
(/*RF2*/(((T195*)oBC13tagged_out_memory_ref))->_item/*p*/)=r194top((T194*)(r2tagged_out_memories()));
r194pop((T194*)(r2tagged_out_memories()));
}/*--*/
T0*oBC13tagged_out_memory_pool=(void*)0;
int fBC13tagged_out_memory_pool=0;

/*INTEGER_32*/T0* r2tagged_out_memory_pool(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13tagged_out_memory_pool==0){fBC13tagged_out_memory_pool=1;{
tmp0/*new*/=((T0*)(new65()));
r65make(((T65*)tmp0/*new*/));
oBC13tagged_out_memory_pool=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13tagged_out_memory_pool;
}/*--*/

/*INTEGER_32*/void r2lock_tagged_out(void){
r194push((T194*)(r2tagged_out_memories()),(/*RF2*/(((T195*)oBC13tagged_out_memory_ref))->_item/*p*/));
(/*RF2*/(((T195*)oBC13tagged_out_memory_ref))->_item/*p*/)=r65best_fit((T65*)(r2tagged_out_memory_pool()),INT32_C(32));
}/*--*/

/*INTEGER_32*/T2 r2max(T2 C,T2 a1){
T2 R=0;
if(((int32_t)(C))>=(a1)){
R=C;
}
else{
R=a1;
}
return R;
}/*--*/

/*INTEGER_32*/void r2out_in_tagged_out_memory(T2 C){
r2append_in(C,(/*RF2*/(((T195*)oBC13tagged_out_memory_ref))->_item/*p*/));
}/*--*/

/*INTEGER_32*/T0* r2tagged_out_memory(void){
T0* R=(void*)0;
R=(/*RF2*/(((T195*)oBC13tagged_out_memory_ref))->_item/*p*/);
return R;
}/*--*/
T0*oBC13tagged_out_memory_ref=(void*)0;

/*INTEGER_32*/T0* r2out(T2 C){
T0* R=(void*)0;
r2lock_tagged_out();
r7clear_count((T7*)(r2tagged_out_memory()));
r2out_in_tagged_out_memory(C);
R=r7twin((T7*)(r2tagged_out_memory()));
r2unlock_tagged_out();
return R;
}/*--*/
T0*oBC13tagged_out_memories=(void*)0;
int fBC13tagged_out_memories=0;

/*INTEGER_32*/T0* r2tagged_out_memories(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13tagged_out_memories==0){fBC13tagged_out_memories=1;{
tmp0/*new*/=((T0*)(new194()));
r194make(((T194*)tmp0/*new*/));
oBC13tagged_out_memories=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13tagged_out_memories;
}/*--*/

/*INTEGER_32*/void r2append_in(T2 C,T0* a1){
T2 _val=0;
T2 _i=0;
T2 _idx=0;
if((C)==(INT8_C(0))){
r7extend(((T7*)a1),((T3)'0'));
}
else{
if(((int32_t)(C))>(INT32_C(0))){
_val=C;
_i=((int32_t)((/*RF2*/(((T7*)a1))->_count/*i7p*/)))+(INT32_C(1));
}
else{
r7extend(((T7*)a1),((T3)'\055'));
_i=((int32_t)((/*RF2*/(((T7*)a1))->_count/*i7p*/)))+(INT32_C(1));
_val=((int32_t)(C))%(INT32_C(10));
if(((int32_t)(_val))<=(INT32_C(0))){
r7extend(((T7*)a1),r2decimal_digit(-(_val)));
_val=-(((int32_t)(C))/(INT32_C(10)));
}
else{
r7extend(((T7*)a1),r2decimal_digit(((int32_t)(-(_val)))+(INT32_C(10))));
_val=((int32_t)(-(((int32_t)(C))/(INT32_C(10)))))-(INT32_C(1));
}
}
while(!((_val)==(INT8_C(0))))
{
r7extend(((T7*)a1),r2decimal_digit(((int32_t)(_val))%(INT32_C(10))));
_val=((int32_t)(_val))/(INT32_C(10));
}
_idx=(/*RF2*/(((T7*)a1))->_count/*i7p*/);
while(!(((int32_t)(_i))>=(_idx)))
{
r7swap(((T7*)a1),_i,_idx);
_idx=((int32_t)(_idx))-(INT32_C(1));
_i=((int32_t)(_i))+(INT32_C(1));
}
}
}/*--*/

/*INTEGER_32*/T3 r2decimal_digit(T2 C){
T3 R=0;
R=((T3)(((int32_t)(C))+(INT32_C(48))));
return R;
}/*--*/

/*INTEGER_8*/void r1times(T1 C,T0* a1){
T1 _i=0;
_i=INT8_C(1);
while(!(((int8_t)(_i))>(C)))
{
agent_launcher_INTEGER_8(a1,_i);
_i=((int8_t)(_i))+(INT8_C(1));
}
}/*--*/

/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/T203 r203realloc(T203 C,T2 a1,T2 a2){
T203 R=(void*)0;
R=new203(a2);
r203copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/void r203copy_from(T203 C,T203 a1,T2 a2){
r203copy_slice_from(C,a1,INT32_C(0),a2);
}/*--*/

/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/void r203copy_slice_from(T203 C,T203 a1,T2 a2,T2 a3){
T2 _i=0;
_i=a3;
while(!(((int32_t)(_i))<(a2)))
{
{
T115 tmp_src=(a1)[_i];
memcpy((C)+(((int32_t)(_i))-(a2)),&(tmp_src),sizeof(T115));
}
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[STRING_RECYCLING_ITEM]*/void r203clear_all(T203 C,T2 a1){
T115 _v={0,(void*)0};
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
{
T115 tmp_src=_v;
memcpy((C)+(_i),&(tmp_src),sizeof(T115));
}
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[STRING]*/T200 r200realloc(T200 C,T2 a1,T2 a2){
T200 R=(void*)0;
R=new200(a2);
r200copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r200copy_from(T200 C,T200 a1,T2 a2){
r200copy_slice_from(C,a1,INT32_C(0),a2);
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r200copy_slice_from(T200 C,T200 a1,T2 a2,T2 a3){
T2 _i=0;
_i=a3;
while(!(((int32_t)(_i))<(a2)))
{
(C)[((int32_t)(_i))-(a2)]=((a1)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r200clear(T200 C,T2 a1,T2 a2){
T0* _v=(void*)0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))>(a2)))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))+(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[STRING]*/void r200clear_all(T200 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[POSIX_PROCESS]*/T193 r193realloc(T193 C,T2 a1,T2 a2){
T193 R=(void*)0;
R=new193(a2);
r193copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193copy_from(T193 C,T193 a1,T2 a2){
r193copy_slice_from(C,a1,INT32_C(0),a2);
}/*--*/

/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193copy_slice_from(T193 C,T193 a1,T2 a2,T2 a3){
T2 _i=0;
_i=a3;
while(!(((int32_t)(_i))<(a2)))
{
(C)[((int32_t)(_i))-(a2)]=((a1)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193clear(T193 C,T2 a1,T2 a2){
T0* _v=(void*)0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))>(a2)))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))+(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[POSIX_PROCESS]*/void r193clear_all(T193 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(T9 C,T2 a1,T2 a2){
T9 R=(void*)0;
R=new9(a2);
r9copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(T9 C,T9 a1,T2 a2){
r9copy_slice_from(C,a1,INT32_C(0),a2);
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9copy_slice_from(T9 C,T9 a1,T2 a2,T2 a3){
T2 _i=0;
_i=a3;
while(!(((int32_t)(_i))<(a2)))
{
(C)[((int32_t)(_i))-(a2)]=((a1)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9move(T9 C,T2 a1,T2 a2,T2 a3){
T2 _i=0;
if((a3)==(INT8_C(0))){
}
else{
if(((int32_t)(a3))<(INT32_C(0))){
_i=a1;
while(!(((int32_t)(_i))>(a2)))
{
(C)[((int32_t)(_i))+(a3)]=((C)[_i]);
_i=((int32_t)(_i))+(INT32_C(1));
}
}
else{
_i=a2;
while(!(((int32_t)(_i))<(a1)))
{
(C)[((int32_t)(_i))+(a3)]=((C)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}
}
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(T9 C,T2 a1){
T3 _v=0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*STRING*/T0* r7_ix_124(T7* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
tmp0/*new*/=((T0*)(new89()));
r89from_strings(((T89*)tmp0/*new*/),(T0*)C,a1);
R=tmp0/*new*/;
/*tmp0.unlock*/
return R;
}/*--*/

/*STRING*/void r7copy(T7* C,T0* a1){
T2 _c=0;
/*SFN*/(C->_storage_lower/*i7p*/)=INT32_C(0);
_c=(/*RF2*/(((T7*)a1))->_count/*i7p*/);
if(((int32_t)(_c))>(INT32_C(0))){
r7ensure_capacity(C,_c);
r9copy_slice_from((/*RF2*/(C)->_storage/*i7p*/),(/*RF2*/(((T7*)a1))->_storage/*i7p*/),(/*RF2*/(((T7*)a1))->_storage_lower/*i7p*/),((int32_t)(((int32_t)((/*RF2*/(((T7*)a1))->_storage_lower/*i7p*/)))+(_c)))-(INT32_C(1)));
}
/*SFN*/(C->_count/*i7p*/)=_c;
}/*--*/

/*STRING*/void r7ensure_capacity(T7* C,T2 a1){
T2 _new_capacity=0;
if(((NULL!=((void*)((/*RF2*/(C)->_storage/*i7p*/)))))==(0)){
_new_capacity=r2max(a1,INT32_C(32));
/*SFN*/(C->_storage/*i7p*/)=new9(((int32_t)(_new_capacity))+((/*RF2*/(C)->_storage_signature_count/*i7p*/)));
/*SFN*/(C->_capacity/*i7p*/)=_new_capacity;
if(((int32_t)((/*RF2*/(C)->_storage_signature_count/*i7p*/)))>(INT32_C(0))){
r7set_storage_signature(C);
}
}
else{
if(((int32_t)((/*RF2*/(C)->_capacity/*i7p*/)))<(a1)){
_new_capacity=r2max(a1,(int32_t)(((uint32_t)((/*RF2*/(C)->_capacity/*i7p*/)))*((uint32_t)(INT32_C(2)))));
/*SFN*/(C->_storage/*i7p*/)=r9realloc((/*RF2*/(C)->_storage/*i7p*/),(/*RF2*/(C)->_capacity/*i7p*/),((int32_t)(_new_capacity))+((/*RF2*/(C)->_storage_signature_count/*i7p*/)));
/*SFN*/(C->_capacity/*i7p*/)=_new_capacity;
if(((int32_t)((/*RF2*/(C)->_storage_signature_count/*i7p*/)))>(INT32_C(0))){
r7set_storage_signature(C);
}
}
}
}/*--*/

/*STRING*/void r7set_storage_signature(T7* C){
((/*RF2*/(C)->_storage/*i7p*/))[(/*RF2*/(C)->_capacity/*i7p*/)]=(((T3)'\000'));
((/*RF2*/(C)->_storage/*i7p*/))[((int32_t)((/*RF2*/(C)->_capacity/*i7p*/)))+(INT32_C(1))]=(((T3)'\003'));
((/*RF2*/(C)->_storage/*i7p*/))[((int32_t)((/*RF2*/(C)->_capacity/*i7p*/)))+(INT32_C(2))]=(((T3)'\011'));
((/*RF2*/(C)->_storage/*i7p*/))[((int32_t)((/*RF2*/(C)->_capacity/*i7p*/)))+(INT32_C(3))]=(((T3)'\033'));
/*SFN*/(C->_has_storage_signature/*i7p*/)=((T6)(1));
}/*--*/

/*STRING*/void r7swap(T7* C,T2 a1,T2 a2){
T3 _tmp=0;
_tmp=r7item(C,a1);
r7put(C,r7item(C,a2),a1);
r7put(C,_tmp,a2);
}/*--*/

/*STRING*/void r7put(T7* C,T3 a1,T2 a2){
((/*RF2*/(C)->_storage/*i7p*/))[((int32_t)(((int32_t)((/*RF2*/(C)->_storage_lower/*i7p*/)))+(a2)))-(INT32_C(1))]=(a1);
}/*--*/

/*STRING*/void r7insert_character(T7* C,T3 a1,T2 a2){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
tmp0/*and then*/=((T6)(((int32_t)((/*RF2*/(C)->_storage_lower/*i7p*/)))>(INT32_C(0))));
if(tmp0/*and then*/){
tmp0/*and then*/=((T6)(((int32_t)(a2))<=((/*RF2*/(C)->_count/*i7p*/))));
}
if(tmp0/*and then*/){
if(((int32_t)(a2))>(INT32_C(1))){
r9move((/*RF2*/(C)->_storage/*i7p*/),(/*RF2*/(C)->_storage_lower/*i7p*/),((int32_t)(((int32_t)((/*RF2*/(C)->_storage_lower/*i7p*/)))+(a2)))-(INT32_C(1)),INT32_C(-1));
}
/*SFN*/(C->_storage_lower/*i7p*/)=((int32_t)((/*RF2*/(C)->_storage_lower/*i7p*/)))-(INT32_C(1));
}
else{
r7ensure_capacity(C,((int32_t)((/*RF2*/(C)->_count/*i7p*/)))+(INT32_C(1)));
if(((int32_t)(a2))<=((/*RF2*/(C)->_count/*i7p*/))){
r9move((/*RF2*/(C)->_storage/*i7p*/),((int32_t)(((int32_t)((/*RF2*/(C)->_storage_lower/*i7p*/)))-(INT32_C(1))))+(a2),((int32_t)(((int32_t)((/*RF2*/(C)->_storage_lower/*i7p*/)))-(INT32_C(1))))+((/*RF2*/(C)->_count/*i7p*/)),INT32_C(1));
}
}
((/*RF2*/(C)->_storage/*i7p*/))[((int32_t)(((int32_t)((/*RF2*/(C)->_storage_lower/*i7p*/)))+(a2)))-(INT32_C(1))]=(a1);
/*SFN*/(C->_count/*i7p*/)=((int32_t)((/*RF2*/(C)->_count/*i7p*/)))+(INT32_C(1));
}/*--*/

/*STRING*/T0* r7twin(T7* C){
T0* R=(void*)0;
R=(void*)new7();
r7copy(((T7*)R),((T0*)C));
return R;
}/*--*/

/*STRING*/void r7extend(T7* C,T3 a1){
r7insert_character(C,a1,((int32_t)((/*RF2*/(C)->_count/*i7p*/)))+(INT32_C(1)));
}/*--*/

/*STRING*/void r7print_on(T7* C,T0* a1){
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 63:
r63put_natively_stored_string(((T63*)a1),(T0*)C);
break;
default:;
r51put_natively_stored_string((T0*)C);
}
/*inspect]*/
}/*--*/

/*STRING*/void r7clear_count(T7* C){
/*SFN*/(C->_count/*i7p*/)=INT32_C(0);
/*SFN*/(C->_storage_lower/*i7p*/)=INT32_C(0);
}/*--*/

/*STRING*/void r7make(T7* C,T2 a1){
/*SFN*/(C->_storage_lower/*i7p*/)=INT32_C(0);
if(((int32_t)(a1))>(INT32_C(0))){
r7ensure_capacity(C,a1);
}
/*SFN*/(C->_count/*i7p*/)=INT32_C(0);
r7next_generation(C);
}/*--*/

/*STRING*/void r7next_generation(T7* C){
/*SFN*/(C->_generation/*i7p*/)=((int32_t)((/*RF2*/(C)->_generation/*i7p*/)))+(INT32_C(1));
}/*--*/

/*STRING*/T3 r7item(T7* C,T2 a1){
T3 R=0;
R=((/*RF2*/(C)->_storage/*i7p*/))[((int32_t)(((int32_t)(a1))-(INT32_C(1))))+((/*RF2*/(C)->_storage_lower/*i7p*/))];
return R;
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201put(T201* C,T115 a1,T2 a2){
{
T115 tmp_src=a1;
memcpy(((/*RF2*/(C)->_storage/*4p*/))+(a2),&(tmp_src),sizeof(T115));
}
r201next_generation(C);
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201add_last(T201* C,T115 a1){
T2 _new_capacity=0;
if(((int32_t)(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1))))<=(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))-(INT32_C(1)))){
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
}
else{
if(((/*RF2*/(C)->_capacity/*4p*/))==(INT8_C(0))){
/*SFN*/(C->_storage/*4p*/)=new203(INT32_C(2));
/*SFN*/(C->_capacity/*4p*/)=INT32_C(2);
/*SFN*/(C->_upper/*4p*/)=INT32_C(0);
}
else{
_new_capacity=((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))*(INT32_C(2));
/*SFN*/(C->_storage/*4p*/)=r203realloc((/*RF2*/(C)->_storage/*4p*/),(/*RF2*/(C)->_capacity/*4p*/),_new_capacity);
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
}
}
{
T115 tmp_src=a1;
memcpy(((/*RF2*/(C)->_storage/*4p*/))+((/*RF2*/(C)->_upper/*4p*/)),&(tmp_src),sizeof(T115));
}
r201next_generation(C);
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/T6 r201is_empty(T201* C){
T6 R=0;
R=((T6)(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))<(INT32_C(0))));
return R;
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/T6 r201valid_index(T201* C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
tmp0/*and then*/=((T6)(((int32_t)(INT32_C(0)))<=(a1)));
if(tmp0/*and then*/){
tmp0/*and then*/=((T6)(((int32_t)(a1))<=((/*RF2*/(C)->_upper/*4p*/))));
}
R=((T6)(tmp0/*and then*/));
return R;
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201make(T201* C,T2 a1){
if(((int32_t)(a1))>((/*RF2*/(C)->_capacity/*4p*/))){
/*SFN*/(C->_storage/*4p*/)=new203(a1);
/*SFN*/(C->_capacity/*4p*/)=a1;
}
else{
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))>(INT32_C(0))){
/*SFN*/(C->_upper/*4p*/)=r2max((/*RF2*/(C)->_upper/*4p*/),((int32_t)(a1))-(INT32_C(1)));
if(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))>=(INT32_C(0))){
r203clear_all((/*RF2*/(C)->_storage/*4p*/),(/*RF2*/(C)->_upper/*4p*/));
}
}
}
/*SFN*/(C->_upper/*4p*/)=((int32_t)(a1))-(INT32_C(1));
r201next_generation(C);
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201next_generation(T201* C){
/*SFN*/(C->_generation/*4p*/)=((int32_t)((/*RF2*/(C)->_generation/*4p*/)))+(INT32_C(1));
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201add(T201* C,T115 a1,T2 a2){
if((a2)==(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1)))){
r201add_last(C,a1);
}
else{
r201add_last(C,a1);
r201move(C,a2,((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-(INT32_C(1)),INT32_C(1));
r201put(C,a1,a2);
}
}/*--*/

/*FAST_ARRAY[STRING_RECYCLING_ITEM]*/void r201move(T201* C,T2 a1,T2 a2,T2 a3){
T115 _default_value={0,(void*)0};
T2 _i=0;
if((a3)==(INT8_C(0))){
}
else{
if(((int32_t)(a3))<(INT32_C(0))){
_i=a1;
while(!(((int32_t)(_i))>(a2)))
{
r201put(C,((/*RF2*/(C)->_storage/*4p*/))[_i],((int32_t)(_i))+(a3));
r201put(C,_default_value,_i);
_i=((int32_t)(_i))+(INT32_C(1));
}
}
else{
_i=a2;
while(!(((int32_t)(_i))<(a1)))
{
r201put(C,((/*RF2*/(C)->_storage/*4p*/))[_i],((int32_t)(_i))+(a3));
r201put(C,_default_value,_i);
_i=((int32_t)(_i))-(INT32_C(1));
}
}
}
}/*--*/

/*FAST_ARRAY[POSIX_PROCESS]*/void r192add_last(T192* C,T0* a1){
T2 _new_capacity=0;
if(((int32_t)(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1))))<=(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))-(INT32_C(1)))){
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
}
else{
if(((/*RF2*/(C)->_capacity/*4p*/))==(INT8_C(0))){
/*SFN*/(C->_storage/*4p*/)=new193(INT32_C(2));
/*SFN*/(C->_capacity/*4p*/)=INT32_C(2);
/*SFN*/(C->_upper/*4p*/)=INT32_C(0);
}
else{
_new_capacity=((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))*(INT32_C(2));
/*SFN*/(C->_storage/*4p*/)=r193realloc((/*RF2*/(C)->_storage/*4p*/),(/*RF2*/(C)->_capacity/*4p*/),_new_capacity);
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
}
}
((/*RF2*/(C)->_storage/*4p*/))[(/*RF2*/(C)->_upper/*4p*/)]=(a1);
r192next_generation(C);
}/*--*/

/*FAST_ARRAY[POSIX_PROCESS]*/void r192next_generation(T192* C){
/*SFN*/(C->_generation/*4p*/)=((int32_t)((/*RF2*/(C)->_generation/*4p*/)))+(INT32_C(1));
}/*--*/

/*FAST_ARRAY[POSIX_PROCESS]*/void r192with_capacity(T192* C,T2 a1){
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(a1)){
/*SFN*/(C->_storage/*4p*/)=new193(a1);
/*SFN*/(C->_capacity/*4p*/)=a1;
}
else{
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))>(a1)){
r193clear((/*RF2*/(C)->_storage/*4p*/),INT32_C(0),(/*RF2*/(C)->_upper/*4p*/));
}
}
/*SFN*/(C->_upper/*4p*/)=INT32_C(-1);
r192next_generation(C);
}/*--*/

/*FAST_ARRAY[POSIX_PROCESS]*/void r192mark_native_arrays(T192* C){
T2 _i=0;
_i=(/*RF2*/(C)->_upper/*4p*/);
while(!(((int32_t)(_i))<(INT32_C(0))))
{
{/*mark_item*/
T0* elt=(/*RF2*/(C)->_storage/*4p*/)[_i];
if(NULL!=elt)gc_mark179((T179*)(elt));
/*mark_item*/}_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*WEAK_REFERENCE[STRING]*/void r204set_item(T204* C,T0* a1){
/*SFN*/(C->_item/*p*/)=a1;
}/*--*/

/*STACK[STRING]*/void r194push(T194* C,T0* a1){
T2 _new_capacity=0;
if(((int32_t)(((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1))))<=(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))-(INT32_C(1)))){
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
}
else{
if(((/*RF2*/(C)->_capacity/*4p*/))==(INT8_C(0))){
/*SFN*/(C->_storage/*4p*/)=new200(INT32_C(2));
/*SFN*/(C->_capacity/*4p*/)=INT32_C(2);
/*SFN*/(C->_upper/*4p*/)=INT32_C(0);
}
else{
_new_capacity=((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))*(INT32_C(2));
/*SFN*/(C->_storage/*4p*/)=r200realloc((/*RF2*/(C)->_storage/*4p*/),(/*RF2*/(C)->_capacity/*4p*/),_new_capacity);
/*SFN*/(C->_capacity/*4p*/)=_new_capacity;
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))+(INT32_C(1));
}
}
((/*RF2*/(C)->_storage/*4p*/))[(/*RF2*/(C)->_upper/*4p*/)]=(a1);
r194next_generation(C);
}/*--*/

/*STACK[STRING]*/void r194pop(T194* C){
/*SFN*/(C->_upper/*4p*/)=((int32_t)((/*RF2*/(C)->_upper/*4p*/)))-(INT32_C(1));
}/*--*/

/*STACK[STRING]*/T0* r194top(T194* C){
T0* R=(void*)0;
R=((/*RF2*/(C)->_storage/*4p*/))[(/*RF2*/(C)->_upper/*4p*/)];
return R;
}/*--*/

/*STACK[STRING]*/void r194make(T194* C){
r194with_capacity(C,INT32_C(16));
}/*--*/

/*STACK[STRING]*/void r194next_generation(T194* C){
/*SFN*/(C->_generation/*4p*/)=((int32_t)((/*RF2*/(C)->_generation/*4p*/)))+(INT32_C(1));
}/*--*/

/*STACK[STRING]*/void r194with_capacity(T194* C,T2 a1){
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))<(a1)){
/*SFN*/(C->_storage/*4p*/)=new200(a1);
/*SFN*/(C->_capacity/*4p*/)=a1;
}
else{
if(((int32_t)((/*RF2*/(C)->_capacity/*4p*/)))>(a1)){
r200clear((/*RF2*/(C)->_storage/*4p*/),INT32_C(0),(/*RF2*/(C)->_upper/*4p*/));
}
}
/*SFN*/(C->_upper/*4p*/)=INT32_C(-1);
r194next_generation(C);
}/*--*/

/*STRING_RECYCLING_ITEM_SORTER*/T6 r137lt(T115 a1,T115 a2){
T6 R=0;
R=((T6)(((int32_t)((/*RF2*/(a1)._capacity/**/)))>((/*RF2*/(a2)._capacity/**/))));
return R;
}/*--*/

/*STRING_RECYCLING_ITEM_SORTER*/T2 r137insert_index(T0* a1,T115 a2){
T2 R=0;
T2 _min=0;
T2 _max=0;
_min=INT32_C(0);
_max=((int32_t)((/*RF2*/(((T201*)/*no_dispatch.e*/(T0*)(a1)))->_upper/*4p*/)))+(INT32_C(1));
while(!((_min)==(_max)))
{
R=((int32_t)(((int32_t)(_min))+(_max)))/(INT32_C(2));
if(r137lte(((/*RF2*/(((T201*)/*no_dispatch.e*/(T0*)(a1)))->_storage/*4p*/))[R],a2)){
_min=((int32_t)(R))+(INT32_C(1));
}
else{
_max=R;
}
}
R=_min;
return R;
}/*--*/

/*STRING_RECYCLING_ITEM_SORTER*/T6 r137lte(T115 a1,T115 a2){
T6 R=0;
R=((T6)((r137lt(a2,a1))==(0)));
return R;
}/*--*/

/*STRING_RECYCLING_ITEM*/void r115set_item(T115* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if((a1)==((void*)((void*)0))){
if(((/*RF2*/(*C)._item_memory/**/))!=((void*)((void*)0))){
(/*RF2*/((T204*)((/*RF2*/(*C)._item_memory/**/)))->_item/*p*/)=(void*)0;
}
}
else{
/*SFN*/(C->_capacity/**/)=(/*RF2*/(((T7*)a1))->_capacity/*i7p*/);
if(((/*RF2*/(*C)._item_memory/**/))==((void*)((void*)0))){
tmp0/*new*/=((T0*)(new204()));
r204set_item(((T204*)tmp0/*new*/),a1);
/*SFN*/(C->_item_memory/**/)=tmp0/*new*/;
/*tmp0.unlock*/
}
else{
(/*RF2*/((T204*)((/*RF2*/(*C)._item_memory/**/)))->_item/*p*/)=a1;
}
}
}/*--*/

/*STRING_RECYCLING_ITEM*/T0* r115item(T115* C){
T0* R=(void*)0;
if(((/*RF2*/(*C)._item_memory/**/))!=((void*)((void*)0))){
R=(/*RF2*/((T204*)((/*RF2*/(*C)._item_memory/**/)))->_item/*p*/);
}
return R;
}/*--*/

/*STRING_RECYCLING_POOL*/void r65make(T65* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
tmp0/*new*/=((T0*)(new201()));
r201make(((T201*)tmp0/*new*/),INT32_C(0));
/*SFN*/(C->_strings/*3p*/)=tmp0/*new*/;
/*tmp0.unlock*/
}/*--*/

/*STRING_RECYCLING_POOL*/void r65recycle(T65* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
T115 tmp1;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
T115 _item={0,(void*)0};
r7clear_count(((T7*)a1));
r115set_item(&((/*RF2*/(C)->_recycling_item/*3p*/)),a1);
if(r201is_empty((T201*)((/*RF2*/(C)->_strings/*3p*/)))){
r201add_last((T201*)((/*RF2*/(C)->_strings/*3p*/)),(/*RF2*/(C)->_recycling_item/*3p*/));
/*SFN*/(C->_recycling_item/*3p*/)=_item;
}
else{
_i=r137insert_index((/*RF2*/(C)->_strings/*3p*/),_item);
tmp0/*and then*/=((T6)(r201valid_index((T201*)((/*RF2*/(C)->_strings/*3p*/)),_i)));
if(tmp0/*and then*/){
tmp0/*and then*/=((T6)((r115item((tmp1/*fcstrangeisnotunlock*/=((/*RF2*/((T201*)((/*RF2*/(C)->_strings/*3p*/)))->_storage/*4p*/))[_i],&tmp1/*fcstrangeisnotunlock*/)))==((void*)((void*)0))));
}
if(tmp0/*and then*/){
_item=((/*RF2*/((T201*)((/*RF2*/(C)->_strings/*3p*/)))->_storage/*4p*/))[_i];
r115set_item(&_item,a1);
r201put((T201*)((/*RF2*/(C)->_strings/*3p*/)),_item,_i);
r115set_item(&((/*RF2*/(C)->_recycling_item/*3p*/)),(void*)0);
}
else{
r201add((T201*)((/*RF2*/(C)->_strings/*3p*/)),_item,_i);
/*SFN*/(C->_recycling_item/*3p*/)=_item;
}
}
}/*--*/

/*STRING_RECYCLING_POOL*/T0* r65best_fit(T65* C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T115 tmp0;
T6 tmp1;
T6 tmp2;
T115 tmp3;
T0* tmp4;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
T2 _i=0;
T6 _gc=0;
T115 _item={0,(void*)0};
_gc=((T6)(!gc_is_off));
gc_is_off=1;
if((r201is_empty((T201*)((/*RF2*/(C)->_strings/*3p*/))))==(0)){
(/*RF2*/(_item)._capacity/**/)=a1;
_i=r137insert_index((/*RF2*/(C)->_strings/*3p*/),_item);
if(r201valid_index((T201*)((/*RF2*/(C)->_strings/*3p*/)),_i)){
R=r115item((tmp0/*fcstrangeisnotunlock*/=((/*RF2*/((T201*)((/*RF2*/(C)->_strings/*3p*/)))->_storage/*4p*/))[_i],&tmp0/*fcstrangeisnotunlock*/));
while(1){
tmp1/*and then*/=((T6)((R)!=((void*)((void*)0))));
if(tmp1/*and then*/){
tmp1/*and then*/=((T6)(((int32_t)((/*RF2*/(((T7*)R))->_capacity/*i7p*/)))>=(a1)));
}
tmp2/*or else*/=((T6)(tmp1/*and then*/));
if(tmp2/*or else*/){
}
else{
tmp2/*or else*/=((T6)((_i)==(INT32_C(0))));
}
if(tmp2/*or else*/){
break;
}
_i=((int32_t)(_i))-(INT32_C(1));
R=r115item((tmp3/*fcstrangeisnotunlock*/=((/*RF2*/((T201*)((/*RF2*/(C)->_strings/*3p*/)))->_storage/*4p*/))[_i],&tmp3/*fcstrangeisnotunlock*/));
}
if((R)!=((void*)((void*)0))){
_item=((/*RF2*/((T201*)((/*RF2*/(C)->_strings/*3p*/)))->_storage/*4p*/))[_i];
r115set_item(&_item,(void*)0);
r201put((T201*)((/*RF2*/(C)->_strings/*3p*/)),_item,_i);
if(((int32_t)((/*RF2*/(((T7*)R))->_capacity/*i7p*/)))<(a1)){
r7ensure_capacity(((T7*)R),a1);
}
}
}
}
if(_gc){
gc_is_off=0;
}
if((R)==((void*)((void*)0))){
tmp4/*new*/=((T0*)(new7()));
r7make(((T7*)tmp4/*new*/),a1);
R=tmp4/*new*/;
/*tmp4.unlock*/
}
return R;
}/*--*/

/*ROPE*/T0* r89_ix_124(T89* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
tmp0/*new*/=((T0*)(new89()));
r89from_strings(((T89*)tmp0/*new*/),(T0*)C,a1);
R=tmp0/*new*/;
/*tmp0.unlock*/
return R;
}/*--*/

/*ROPE*/T2 r89count(T89* C){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
T2 tmp1;
/*INTERNAL_C_LOCAL list]*/
T2 R=0;
/*[inspectDynamicDispatch*/
switch((((/*RF2*/(C)->_left/*i2p*/))->id)){
case 89:
tmp0/*count*/=r89count(((T89*)(/*RF2*/(C)->_left/*i2p*/)));
break;
default:;
tmp0/*count*/=(/*RF2*/(((T7*)(/*RF2*/(C)->_left/*i2p*/)))->_count/*i7p*/);
}
/*inspect]*/
/*[inspectDynamicDispatch*/
switch((((/*RF2*/(C)->_right/*i2p*/))->id)){
case 89:
tmp1/*count*/=r89count(((T89*)(/*RF2*/(C)->_right/*i2p*/)));
break;
default:;
tmp1/*count*/=(/*RF2*/(((T7*)(/*RF2*/(C)->_right/*i2p*/)))->_count/*i7p*/);
}
/*inspect]*/
R=((int32_t)(tmp0/*count*/))+(tmp1/*count*/);
return R;
}/*--*/

/*ROPE*/void r89from_strings(T89* C,T0* a1,T0* a2){
/*SFN*/(C->_left/*i2p*/)=a1;
/*SFN*/(C->_right/*i2p*/)=a2;
}/*--*/

/*ROPE*/T2 r89split_index(T89* C){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
/*INTERNAL_C_LOCAL list]*/
T2 R=0;
/*[inspectDynamicDispatch*/
switch((((/*RF2*/(C)->_left/*i2p*/))->id)){
case 89:
tmp0/*upper*/=r89count(((T89*)(/*RF2*/(C)->_left/*i2p*/)));
break;
default:;
tmp0/*upper*/=(/*RF2*/(((T7*)(/*RF2*/(C)->_left/*i2p*/)))->_count/*i7p*/);
}
/*inspect]*/
R=tmp0/*upper*/;
return R;
}/*--*/

/*ROPE*/void r89print_on(T89* C,T0* a1){
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 63:
r63put_abstract_string(((T63*)a1),(T0*)C);
break;
default:;
r51put_abstract_string((T0*)C);
}
/*inspect]*/
}/*--*/

/*ROPE*/T3 r89item(T89* C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T3 tmp0;
/*INTERNAL_C_LOCAL list]*/
T3 R=0;
if(((int32_t)(a1))<=(r89split_index(C))){
/*[inspectDynamicDispatch*/
switch((((/*RF2*/(C)->_left/*i2p*/))->id)){
case 89:
tmp0/*item*/=r89item(((T89*)(/*RF2*/(C)->_left/*i2p*/)),a1);
break;
default:;
tmp0/*item*/=r7item(((T7*)(/*RF2*/(C)->_left/*i2p*/)),a1);
}
/*inspect]*/
R=tmp0/*item*/;
}
else{
/*[inspectDynamicDispatch*/
switch((((/*RF2*/(C)->_right/*i2p*/))->id)){
case 89:
/*auto-unlock tmp0*/tmp0/*item*/=r89item(((T89*)(/*RF2*/(C)->_right/*i2p*/)),((int32_t)(a1))-(r89split_index(C)));
break;
default:;
tmp0/*item*/=r7item(((T7*)(/*RF2*/(C)->_right/*i2p*/)),((int32_t)(a1))-(r89split_index(C)));
}
/*inspect]*/
R=tmp0/*item*/;
}
return R;
}/*--*/
/*l58c19/std_error.e*//*l59c19/std_error.e*/
/*STD_ERROR*/void r51put_natively_stored_string(T0* a1){
T2 _unused_result=0;
T0* _fs=(void*)0;
if((a1)==((void*)((void*)0))){
_fs=a1;
if((/*se_evobt*/(void*)0,se_print_run_time_stack(),exit(1),M6)){
/*se_evobt*/(void*)0,se_print_run_time_stack(),exit(1);
}
}
_unused_result=io_fwrite((/*RF2*/(((T7*)/*no_dispatch.e*/(T0*)(a1)))->_storage/*i7p*/),(/*RF2*/(((T7*)/*no_dispatch.e*/(T0*)(a1)))->_count/*i7p*/),(stderr));
}/*--*/

/*STD_ERROR*/void r51put_string(T51* C,T0* a1){
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 89:
r89print_on(((T89*)a1),r51as_output_stream(C));
break;
default:;
r7print_on(((T7*)a1),r51as_output_stream(C));
}
/*inspect]*/
}/*--*/

/*STD_ERROR*/T0* r51as_output_stream(T51* C){
T0* R=(void*)0;
R=((T0*)(C));
return R;
}/*--*/

/*STD_ERROR*/void r51put_abstract_string(T0* a1){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
T3 tmp1;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
T2 _count=0;
_i=INT32_C(1);
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 89:
tmp0/*count*/=r89count(((T89*)a1));
break;
default:;
tmp0/*count*/=(/*RF2*/(((T7*)a1))->_count/*i7p*/);
}
/*inspect]*/
_count=tmp0/*count*/;
while(!(((int32_t)(_i))>(_count)))
{
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 89:
tmp1/*item*/=r89item(((T89*)a1),_i);
break;
default:;
tmp1/*item*/=r7item(((T7*)a1),_i);
}
/*inspect]*/
io_putc(tmp1/*item*/,(stderr));
_i=((int32_t)(_i))+(INT32_C(1));
}
}/*--*/
/*l75c19/std_output.e*//*l76c19/std_output.e*/
/*STD_OUTPUT*/void r63put_natively_stored_string(T63* C,T0* a1){
T2 _unused_result=0;
T0* _fs=(void*)0;
r63write_buffer(C);
if((a1)==((void*)((void*)0))){
_fs=a1;
if((/*se_evobt*/(void*)0,se_print_run_time_stack(),exit(1),M6)){
/*se_evobt*/(void*)0,se_print_run_time_stack(),exit(1);
}
}
_unused_result=io_fwrite((/*RF2*/(((T7*)/*no_dispatch.e*/(T0*)(a1)))->_storage/*i7p*/),(/*RF2*/(((T7*)/*no_dispatch.e*/(T0*)(a1)))->_count/*i7p*/),(stdout));
}/*--*/
T0*oBC13std_output=(void*)0;
int fBC13std_output=0;

/*STD_OUTPUT*/T0* r63std_output(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13std_output==0){fBC13std_output=1;{
tmp0/*new*/=((T0*)(new63()));
r63make(((T63*)tmp0/*new*/));
oBC13std_output=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13std_output;
}/*--*/

/*STD_OUTPUT*/void r63flush(T63* C){
r63filtered_flush(C);
}/*--*/

/*STD_OUTPUT*/void r63put_string(T63* C,T0* a1){
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 89:
r89print_on(((T89*)a1),r63as_output_stream(C));
break;
default:;
r7print_on(((T7*)a1),r63as_output_stream(C));
}
/*inspect]*/
}/*--*/

/*STD_OUTPUT*/T0* r63as_output_stream(T63* C){
T0* R=(void*)0;
R=((T0*)(C));
return R;
}/*--*/

/*STD_OUTPUT*/void r63put_abstract_string(T63* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
T3 tmp1;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
T2 _count=0;
_i=INT32_C(1);
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 89:
tmp0/*count*/=r89count(((T89*)a1));
break;
default:;
tmp0/*count*/=(/*RF2*/(((T7*)a1))->_count/*i7p*/);
}
/*inspect]*/
_count=tmp0/*count*/;
while(!(((int32_t)(_i))>(_count)))
{
/*[inspectDynamicDispatch*/
switch(((a1)->id)){
case 89:
tmp1/*item*/=r89item(((T89*)a1),_i);
break;
default:;
tmp1/*item*/=r7item(((T7*)a1),_i);
}
/*inspect]*/
r63filtered_put_character(C,tmp1/*item*/);
_i=((int32_t)(_i))+(INT32_C(1));
}
}/*--*/

/*STD_OUTPUT*/void r63se_atexit(void){
r63filtered_flush((T63*)(r63std_output()));
}/*--*/

/*STD_OUTPUT*/void r63filtered_flush(T63* C){
if(((int32_t)((/*RF2*/(C)->_buffer_position/*i3p*/)))>(INT32_C(0))){
r63write_buffer(C);
}
io_flush((stdout));
}/*--*/

/*STD_OUTPUT*/void r63make(T63* C){
/*SFN*/(C->_buffer/*i3p*/)=new9(INT32_C(4096));
/*SFN*/(C->_capacity/*i3p*/)=INT32_C(4096);
}/*--*/

/*STD_OUTPUT*/void r63filtered_put_character(T63* C,T3 a1){
if(((int32_t)((/*RF2*/(C)->_buffer_position/*i3p*/)))>=(INT32_C(4096))){
r63write_buffer(C);
}
((/*RF2*/(C)->_buffer/*i3p*/))[(/*RF2*/(C)->_buffer_position/*i3p*/)]=(a1);
/*SFN*/(C->_buffer_position/*i3p*/)=((int32_t)((/*RF2*/(C)->_buffer_position/*i3p*/)))+(INT32_C(1));
if((a1)==(((T3)'\n'))){
r63write_buffer(C);
}
}/*--*/

/*STD_OUTPUT*/void r63write_buffer(T63* C){
T2 _unused_result=0;
if(((int32_t)((/*RF2*/(C)->_buffer_position/*i3p*/)))>(INT32_C(0))){
_unused_result=io_fwrite((/*RF2*/(C)->_buffer/*i3p*/),(/*RF2*/(C)->_buffer_position/*i3p*/),(stdout));
/*SFN*/(C->_buffer_position/*i3p*/)=INT32_C(0);
}
}/*--*/

T179*create179start(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
tmp0/*new*/=((T0*)(new179()));
r179start(((T179*)tmp0/*new*/));
return ((T179*)tmp0/*new*/);
/*tmp0.unlock*/
}/*--*/

/*MY_CHILD*/T0* r179std_output(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13std_output==0){fBC13std_output=1;{
tmp0/*new*/=((T0*)(new63()));
r63make(((T63*)tmp0/*new*/));
oBC13std_output=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13std_output;
}/*--*/

/*MY_CHILD*/void r179start(T179* C){
/*SFN*/(C->_child_process_id/*p*/)=fork();
if(((/*RF2*/(C)->_child_process_id/*p*/))==(INT8_C(0))){
r179run();
se_die(INT32_C(0));
}
else{
if(((/*RF2*/(C)->_child_process_id/*p*/))==(INT8_C(-1))){
if((errno)==(EAGAIN)){
r179not_yet_implemented(C);
}
else{
if((errno)==(ENOMEM)){
r179not_yet_implemented(C);
}
else{
r179not_yet_implemented(C);
}
}
}
}
}/*--*/

/*MY_CHILD*/void r179run(void){
r89print_on((T89*)(r89_ix_124((T89*)(r7_ix_124(((T7*)se_ms(30,s179_1327430360)),r2out(getpid()))),se_ms(3,s179_1265))),r179std_output());
}/*--*/
T0*oBC13std_error=(void*)0;

/*MY_CHILD*/void r179crash(T179* C){
se_print_run_time_stack();
se_die(INT32_C(1));
}/*--*/

/*MY_CHILD*/void r179not_yet_implemented(T179* C){
r51put_string(((T51*)oBC13std_error),se_ms(223,s13_1216703285));
r51put_string(((T51*)oBC13std_error),(T0*)(t[179]));
r51put_string(((T51*)oBC13std_error),se_ms(3,s13_1210));
r179crash(C);
}/*--*/


/*agent launcher*/static void _agenT25f25l8c12(se_agenT25f25l8c12*u){
T0* closed_C=(u->closed_C);
r25add_child(((T25*)closed_C));
}/*--*/

/*agent creation*/T0*agenT25f25l8c12(T0* closed_C){
se_agenT25f25l8c12*u=(void*)new_agent(189);
u->creation_mold_id=0;
u->afp=_agenT25f25l8c12;
u->gc_mark_agent_mold=gc_mark_agenT25f25l8c12;
u->closed_C=closed_C;
return((T0*)u);
}/*--*/

void gc_mark_agenT25f25l8c12(se_agenT25f25l8c12*u){
gc_agent*gcu=(gc_agent*)u;
if (gcu->header.flag==FSOH_UNMARKED){
gcu->header.flag=FSOH_MARKED;
gc_mark(u->closed_C);
}
}/*--*/

/*FORKING*/T0* r25std_output(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13std_output==0){fBC13std_output=1;{
tmp0/*new*/=((T0*)(new63()));
r63make(((T63*)tmp0/*new*/));
oBC13std_output=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13std_output;
}/*--*/

/*FORKING*/void r25print(T0* a1){
if((a1)==((void*)((void*)0))){
r63put_string((T63*)(r25std_output()),ms13_14150);
}
else{
r63put_string((T63*)(r25std_output()),a1);
}
}/*--*/

/*FORKING*/void r25add_child(T25* C){
r192add_last((T192*)((/*RF2*/(C)->_children/*p*/)),((T0*)create179start()));
}/*--*/

/*FORKING*/void r25make(T25* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
r25print(se_ms(29,s25_603433087));
tmp0/*new*/=((T0*)(new192()));
r192with_capacity(((T192*)tmp0/*new*/),INT32_C(5));
/*SFN*/(C->_children/*p*/)=tmp0/*new*/;
/*tmp0.unlock*/
r1times(INT8_C(5),agenT25f25l8c12((T0*)C));
r25print(se_ms(5,s25_59640));
}/*--*/

void agent_launcher_INTEGER_8(/*agent*/T0*a,T1 a1){
/*PROCEDURE[TUPLE[INTEGER_8]]*/switch(((se_agent0*)a)->creation_mold_id){
case 0:{
((se_agenT25f25l8c12*)a)->afp(((/*agent*/void*)a));
break;
}
}
}/*--*/
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#ifdef SE_GC_LIB
gc_agent *store_agent = NULL;
gc_agent *gc_free_agent = NULL;
int       store_left_agent = 0;
int       count_agent=0;
int       gc_info_nb_agent = 0;
fsoc     *store_chunk_agent = NULL;
fsoc H_agent =
{
  {
    FSOC_SIZE, FSO_STORE_CHUNK,
    (void (*)(mch *, void *)) gc_align_mark_agent,
    (void (*)(mch *)) gc_sweep_agent
  },
  NULL,
  (((FSOC_SIZE - sizeof (fsoc) + sizeof (double)) / sizeof (gc_agent)) - 1)
};
#endif

se_agent* new_agent(Tid id) {
#ifdef SE_GC_LIB
  int i;
  gc_agent *agent;
  fsoc *c;
  if (store_left_agent > 1)
    {
      store_left_agent--;
      agent = store_agent++;
    }
  else if (gc_free_agent != NULL)
    {
      agent = gc_free_agent;
      gc_free_agent = agent->header.next;
    }
  else if (store_left_agent == 1)
    {
      store_left_agent = 0;
      store_chunk_agent->header.state_type = FSO_USED_CHUNK;
      agent = store_agent++;
    }
  else
    {
      c = gc_fsoc_get1 ();
      if (c == NULL)
	c = gc_fsoc_get2 ();
      store_chunk_agent = c;
      *store_chunk_agent = H_agent;
      store_agent = ((gc_agent *) (&(store_chunk_agent->first_object)));
      store_left_agent = H_agent.count_minus_one;
      agent = store_agent++;
    }
  agent->header.flag = FSOH_UNMARKED;
  for(i=0;i<(sizeof(se_agent)/sizeof(int));i++)
    ((int*) (agent))[i] = 0;

#else /* SE_GC_LIB */
  se_agent* agent = se_calloc(1,sizeof(se_agent));

#endif /* SE_GC_LIB */

  ((se_agent*) agent)->u0.id = id;

#ifdef SE_GC_LIB
  gc_info_nb_agent++;
#endif /* SE_GC_LIB */
  return (se_agent *) agent;
}


#ifdef SE_GC_LIB
void gc_sweep_agent (fsoc * c) {
  gc_agent *a1, *a2, *flt, flh;
  a1 = ((gc_agent *) (&(c->first_object)));
  if (c->header.state_type == FSO_STORE_CHUNK) {
    for (; a1 < store_agent; a1++) {
      if ((a1->header.flag) == FSOH_MARKED) {
	a1->header.flag = FSOH_UNMARKED;
      }
      else if ((a1->header.flag) == FSOH_UNMARKED) {
	a1->header.next = gc_free_agent;
	gc_free_agent = a1;
      }
    }
  }
  else {
    int dead = 1;
    flh.header.next = NULL;
    flt = &flh;
    a2 = a1 + c->count_minus_one;
    for (; a1 <= a2; a2--) {
      if ((a2->header.flag) == FSOH_MARKED) {
	a2->header.flag = FSOH_UNMARKED;
	dead = 0;
      }
      else if ((a2->header.flag) == FSOH_UNMARKED) {
	flt->header.next = a2;
	flt = a2;
      }
    }
    if (dead) {
      gc_agent **prvnxt=&gc_free_agent;
      char *inf=(char*)((gc_agent*)(&(c->first_object)));
      char *sup=(char*)(((gc_agent*)(&(c->first_object)))+c->count_minus_one);
      a1=gc_free_agent;
      while(a1!=NULL) {
	if(inf>(char*)a1 || (char*)a1>sup) {
	  *prvnxt=a1;
	  prvnxt=&a1->header.next;
	}
	a1=a1->header.next;
      }
      *prvnxt=NULL;
      c->next = fsocfl;
      fsocfl = c;
      c->header.state_type = FSO_FREE_CHUNK;
    }
    else if (flh.header.next != NULL) {
      flt->header.next = gc_free_agent;
      gc_free_agent = flh.header.next;
    }
  }
}

void gc_align_mark_agent (fsoc * c, gc_agent * p) {
  gc_agent *b = ((gc_agent *) (&(c->first_object)));
  if ((c->header.state_type == FSO_STORE_CHUNK)
      && (((char *) p) >= ((char *) store_agent)))
    return;

  if (((char *) p) > ((char *) (b + (c->count_minus_one))))
    return;

  if (((char *) p) < ((char *) b))
    return;
  if (((((char *) p) - ((char *) b)) % sizeof (*p)) == 0)
    {
      se_agent *ta = (&(p->object));
      (*(ta->u0.gc_mark_agent_mold))(ta);
    }
}

#endif /* SE_GC_LIB */
T0*ms13_14150;

T0*se_ms(int c,char*e){
/* Allocate a Manifest STRING.*/
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage_lower=0;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

T0*se_string(char*e){
/* Allocate an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage_lower=0;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

void se_msi1(void){
ms13_14150=se_ms(4,s13_14150);
}/*--*/

void manifest_string_mark1(void){
gc_mark7((T7*)ms13_14150);
}/*--*/

void once_function_mark(void){
/*NON_VOID_NO_DISPATCH:*/
gc_mark51((T51*)(oBC13std_error));
gc_mark195((T195*)(oBC13tagged_out_memory_ref));
/*Ordinary once functions:*/
if(NULL!=oBC13std_output)gc_mark63((T63*)(oBC13std_output));
if(NULL!=oBC13tagged_out_memories)gc_mark194((T194*)(oBC13tagged_out_memories));
if(NULL!=oBC13tagged_out_memory_pool)gc_mark65((T65*)(oBC13tagged_out_memory_pool));
}/*--*/

void gc_start(void){
if(gc_is_off)return;
if(garbage_delayed())return;
handle(SE_HANDLE_ENTER_GC,NULL);
gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);
((gc25*)eiffel_root_object)->header.flag=FSOH_UNMARKED;
if(na_env212.store_left>0){
na_env212.store->header.size=na_env212.store_left;
na_env212.store->header.magic_flag=RSOH_FREE;
na_env212.store_left=0;
}
na_env212.chunk_list=NULL;
na_env212.store_chunk=NULL;
if(na_env211.store_left>0){
na_env211.store->header.size=na_env211.store_left;
na_env211.store->header.magic_flag=RSOH_FREE;
na_env211.store_left=0;
}
na_env211.chunk_list=NULL;
na_env211.store_chunk=NULL;
gc_free204=(void*)0;
if(na_env203.store_left>0){
na_env203.store->header.size=na_env203.store_left;
na_env203.store->header.magic_flag=RSOH_FREE;
na_env203.store_left=0;
}
na_env203.chunk_list=NULL;
na_env203.store_chunk=NULL;
if(na_env200.store_left>0){
na_env200.store->header.size=na_env200.store_left;
na_env200.store->header.magic_flag=RSOH_FREE;
na_env200.store_left=0;
}
na_env200.chunk_list=NULL;
na_env200.store_chunk=NULL;
gc_free201=(void*)0;
gc_free194=(void*)0;
gc_free65=(void*)0;
gc_free195=(void*)0;
gc_free89=(void*)0;
gc_free51=(void*)0;
if(na_env193.store_left>0){
na_env193.store->header.size=na_env193.store_left;
na_env193.store->header.magic_flag=RSOH_FREE;
na_env193.store_left=0;
}
na_env193.chunk_list=NULL;
na_env193.store_chunk=NULL;
gc_free63=(void*)0;
gc_free179=(void*)0;
gc_free192=(void*)0;
if(na_env9.store_left>0){
na_env9.store->header.size=na_env9.store_left;
na_env9.store->header.magic_flag=RSOH_FREE;
na_env9.store_left=0;
}
na_env9.chunk_list=NULL;
na_env9.store_chunk=NULL;
gc_free7=(void*)0;
gc_free25=(void*)0;
gc_mark25(eiffel_root_object);
manifest_string_mark1();
once_function_mark();
{int i=SE_MAXID-1;
while(i>=0){
if(g[i]!=NULL)gc_mark7(g[i]);
i--;}
}
{int i=SE_MAXID-1;
while(i>=0){
if(t[i]!=NULL)gc_mark7(t[i]);
i--;}
}
mark_stack_and_registers();
gc_sweep();
collector_counter++;
handle(SE_HANDLE_EXIT_GC,NULL);
}/*--*/
na_env na_env212={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark212};
na_env na_env211={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark211};
gc204*store204=(void*)0;
int store_left204=0;
fsoc*store_chunk204=(void*)0;
gc204*gc_free204=(void*)0;
na_env na_env203={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark203};
na_env na_env200={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark200};
gc201*store201=(void*)0;
int store_left201=0;
fsoc*store_chunk201=(void*)0;
gc201*gc_free201=(void*)0;
gc194*store194=(void*)0;
int store_left194=0;
fsoc*store_chunk194=(void*)0;
gc194*gc_free194=(void*)0;
gc65*store65=(void*)0;
int store_left65=0;
fsoc*store_chunk65=(void*)0;
gc65*gc_free65=(void*)0;
gc195*store195=(void*)0;
int store_left195=0;
fsoc*store_chunk195=(void*)0;
gc195*gc_free195=(void*)0;
gc89*store89=(void*)0;
int store_left89=0;
fsoc*store_chunk89=(void*)0;
gc89*gc_free89=(void*)0;
gc51*store51=(void*)0;
int store_left51=0;
fsoc*store_chunk51=(void*)0;
gc51*gc_free51=(void*)0;
na_env na_env193={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark193};
gc63*store63=(void*)0;
int store_left63=0;
fsoc*store_chunk63=(void*)0;
gc63*gc_free63=(void*)0;
gc179*store179=(void*)0;
int store_left179=0;
fsoc*store_chunk179=(void*)0;
gc179*gc_free179=(void*)0;
gc192*store192=(void*)0;
int store_left192=0;
fsoc*store_chunk192=(void*)0;
gc192*gc_free192=(void*)0;
na_env na_env9={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark9};
gc7*store7=(void*)0;
int store_left7=0;
fsoc*store_chunk7=(void*)0;
gc7*gc_free7=(void*)0;
gc25*store25=(void*)0;
int store_left25=0;
fsoc*store_chunk25=(void*)0;
gc25*gc_free25=(void*)0;

void gc_mark212(T212 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
}}}}
}/*--*/

T212 new212(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env212.store_left)){
rsoh*r=na_env212.store;
na_env212.store_left-=size;
if(na_env212.store_left>sizeof(rsoh)){
r->header.size=size;
na_env212.store=((rsoh*)(((char*)(na_env212.store))+size));
}
else {
r->header.size=size+na_env212.store_left;
na_env212.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T212)(r+1));
}
return((T212)new_na(&na_env212,size));
}/*--*/

void gc_mark211(T211 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
}}}}
}/*--*/

T211 new211(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env211.store_left)){
rsoh*r=na_env211.store;
na_env211.store_left-=size;
if(na_env211.store_left>sizeof(rsoh)){
r->header.size=size;
na_env211.store=((rsoh*)(((char*)(na_env211.store))+size));
}
else {
r->header.size=size+na_env211.store_left;
na_env211.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T211)(r+1));
}
return((T211)new_na(&na_env211,size));
}/*--*/

void gc_sweep204(fsoc*c){
gc204*o1,*o2;
o1=((gc204*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store204;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item204(&(o1->object));
}
else{
o1->header.next=gc_free204;
gc_free204=o1;
}
}
}
else{
int dead=1;
gc204* old_gc_free = gc_free204;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item204(&(o1->object));
dead=0;}
else{
o1->header.next=gc_free204;
gc_free204=o1;
}
}
if (dead){
gc_free204 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_update_weak_ref_item204(T204* wr){
gc7* obj_ptr = (gc7*)(wr->_item);
if (obj_ptr != NULL){
int swept = (((void*)obj_ptr) <= ((void*)wr));
if (swept != (obj_ptr->header.flag == FSOH_UNMARKED))
/* (already swept) xor marked */
wr->_item = NULL;
}
}/*--*/

void gc_mark204(T204*o){
((gc204*)o)->header.flag=FSOH_MARKED;
}/*--*/

void gc_align_mark204(fsoc*c,gc204*p){
gc204*b=((gc204*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store204)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T204*o=(&(p->object));
((gc204*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H204={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark204,
(void(*)(mch*))gc_sweep204},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc204))-1)};

T204*new204(void){
gc204*n;
fsoc*c;
if(store_left204>1){
store_left204--;
n=store204++;
}
else if(gc_free204!=NULL){
n=gc_free204;
gc_free204=n->header.next;
}
else if(store_left204==1){
store_left204=0;
store_chunk204->header.state_type=FSO_USED_CHUNK;
n=store204++;
}
else{
c=gc_fsoc_get1();
if(gc_free204!=NULL){
n=gc_free204;
gc_free204=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk204=c;
*store_chunk204=H204;
store204=((gc204*)(&(store_chunk204->first_object)));
store_left204=H204.count_minus_one;
n=store204++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M204;
return((T204*)n);
}/*--*/

void gc_mark203(T203 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T115 e;
T115*p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
gc_mark115(&(e));
}}}}
}/*--*/

T203 new203(unsigned int size){
size=(size*sizeof(T115))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env203.store_left)){
rsoh*r=na_env203.store;
na_env203.store_left-=size;
if(na_env203.store_left>sizeof(rsoh)){
r->header.size=size;
na_env203.store=((rsoh*)(((char*)(na_env203.store))+size));
}
else {
r->header.size=size+na_env203.store_left;
na_env203.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T203)(r+1));
}
return((T203)new_na(&na_env203,size));
}/*--*/

void gc_mark200(T200 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark7((T7*)(e));
}}}}
}/*--*/

T200 new200(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env200.store_left)){
rsoh*r=na_env200.store;
na_env200.store_left-=size;
if(na_env200.store_left>sizeof(rsoh)){
r->header.size=size;
na_env200.store=((rsoh*)(((char*)(na_env200.store))+size));
}
else {
r->header.size=size+na_env200.store_left;
na_env200.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T200)(r+1));
}
return((T200)new_na(&na_env200,size));
}/*--*/

void gc_mark115(T115*o){
/**/if(NULL!=o->_item_memory)gc_mark204((T204*)(o->_item_memory));
}/*--*/

void gc_sweep201(fsoc*c){
gc201*o1,*o2;
o1=((gc201*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store201;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free201;
gc_free201=o1;
}
}
}
else{
int dead=1;
gc201* old_gc_free = gc_free201;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free201;
gc_free201=o1;
}
}
if (dead){
gc_free201 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark201(T201*o){
if(((gc201*)o)->header.flag==FSOH_UNMARKED){
((gc201*)o)->header.flag=FSOH_MARKED;
/*4p*/if(NULL!=o->_storage)gc_mark203((o->_storage));
}
}/*--*/

void gc_align_mark201(fsoc*c,gc201*p){
gc201*b=((gc201*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store201)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T201*o=(&(p->object));
((gc201*)o)->header.flag=FSOH_MARKED;
/*4p*/if(NULL!=o->_storage)gc_mark203((o->_storage));
}
}
}/*--*/
fsoc H201={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark201,
(void(*)(mch*))gc_sweep201},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc201))-1)};

T201*new201(void){
gc201*n;
fsoc*c;
if(store_left201>1){
store_left201--;
n=store201++;
}
else if(gc_free201!=NULL){
n=gc_free201;
gc_free201=n->header.next;
}
else if(store_left201==1){
store_left201=0;
store_chunk201->header.state_type=FSO_USED_CHUNK;
n=store201++;
}
else{
c=gc_fsoc_get1();
if(gc_free201!=NULL){
n=gc_free201;
gc_free201=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk201=c;
*store_chunk201=H201;
store201=((gc201*)(&(store_chunk201->first_object)));
store_left201=H201.count_minus_one;
n=store201++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M201;
return((T201*)n);
}/*--*/

void gc_sweep194(fsoc*c){
gc194*o1,*o2;
o1=((gc194*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store194;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free194;
gc_free194=o1;
}
}
}
else{
int dead=1;
gc194* old_gc_free = gc_free194;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free194;
gc_free194=o1;
}
}
if (dead){
gc_free194 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark194(T194*o){
if(((gc194*)o)->header.flag==FSOH_UNMARKED){
((gc194*)o)->header.flag=FSOH_MARKED;
/*4p*/if(NULL!=o->_storage)gc_mark200((o->_storage));
}
}/*--*/

void gc_align_mark194(fsoc*c,gc194*p){
gc194*b=((gc194*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store194)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T194*o=(&(p->object));
((gc194*)o)->header.flag=FSOH_MARKED;
/*4p*/if(NULL!=o->_storage)gc_mark200((o->_storage));
}
}
}/*--*/
fsoc H194={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark194,
(void(*)(mch*))gc_sweep194},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc194))-1)};

T194*new194(void){
gc194*n;
fsoc*c;
if(store_left194>1){
store_left194--;
n=store194++;
}
else if(gc_free194!=NULL){
n=gc_free194;
gc_free194=n->header.next;
}
else if(store_left194==1){
store_left194=0;
store_chunk194->header.state_type=FSO_USED_CHUNK;
n=store194++;
}
else{
c=gc_fsoc_get1();
if(gc_free194!=NULL){
n=gc_free194;
gc_free194=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk194=c;
*store_chunk194=H194;
store194=((gc194*)(&(store_chunk194->first_object)));
store_left194=H194.count_minus_one;
n=store194++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M194;
return((T194*)n);
}/*--*/

void gc_sweep65(fsoc*c){
gc65*o1,*o2;
o1=((gc65*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store65;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free65;
gc_free65=o1;
}
}
}
else{
int dead=1;
gc65* old_gc_free = gc_free65;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free65;
gc_free65=o1;
}
}
if (dead){
gc_free65 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark65(T65*o){
if(((gc65*)o)->header.flag==FSOH_UNMARKED){
((gc65*)o)->header.flag=FSOH_MARKED;
/*3p*/if(NULL!=o->_strings)gc_mark201((T201*)(o->_strings));
/*3p*/gc_mark115(&(o->_recycling_item));
}
}/*--*/

void gc_align_mark65(fsoc*c,gc65*p){
gc65*b=((gc65*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store65)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T65*o=(&(p->object));
((gc65*)o)->header.flag=FSOH_MARKED;
/*3p*/if(NULL!=o->_strings)gc_mark201((T201*)(o->_strings));
/*3p*/gc_mark115(&(o->_recycling_item));
}
}
}/*--*/
fsoc H65={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark65,
(void(*)(mch*))gc_sweep65},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc65))-1)};

T65*new65(void){
gc65*n;
fsoc*c;
if(store_left65>1){
store_left65--;
n=store65++;
}
else if(gc_free65!=NULL){
n=gc_free65;
gc_free65=n->header.next;
}
else if(store_left65==1){
store_left65=0;
store_chunk65->header.state_type=FSO_USED_CHUNK;
n=store65++;
}
else{
c=gc_fsoc_get1();
if(gc_free65!=NULL){
n=gc_free65;
gc_free65=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk65=c;
*store_chunk65=H65;
store65=((gc65*)(&(store_chunk65->first_object)));
store_left65=H65.count_minus_one;
n=store65++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M65;
return((T65*)n);
}/*--*/

void gc_sweep195(fsoc*c){
gc195*o1,*o2;
o1=((gc195*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store195;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free195;
gc_free195=o1;
}
}
}
else{
int dead=1;
gc195* old_gc_free = gc_free195;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free195;
gc_free195=o1;
}
}
if (dead){
gc_free195 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark195(T195*o){
if(((gc195*)o)->header.flag==FSOH_UNMARKED){
((gc195*)o)->header.flag=FSOH_MARKED;
/*p*/if(NULL!=o->_item)gc_mark7((T7*)(o->_item));
}
}/*--*/

void gc_align_mark195(fsoc*c,gc195*p){
gc195*b=((gc195*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store195)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T195*o=(&(p->object));
((gc195*)o)->header.flag=FSOH_MARKED;
/*p*/if(NULL!=o->_item)gc_mark7((T7*)(o->_item));
}
}
}/*--*/
fsoc H195={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark195,
(void(*)(mch*))gc_sweep195},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc195))-1)};

T195*new195(void){
gc195*n;
fsoc*c;
if(store_left195>1){
store_left195--;
n=store195++;
}
else if(gc_free195!=NULL){
n=gc_free195;
gc_free195=n->header.next;
}
else if(store_left195==1){
store_left195=0;
store_chunk195->header.state_type=FSO_USED_CHUNK;
n=store195++;
}
else{
c=gc_fsoc_get1();
if(gc_free195!=NULL){
n=gc_free195;
gc_free195=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk195=c;
*store_chunk195=H195;
store195=((gc195*)(&(store_chunk195->first_object)));
store_left195=H195.count_minus_one;
n=store195++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M195;
return((T195*)n);
}/*--*/

void gc_sweep89(fsoc*c){
gc89*o1,*o2;
o1=((gc89*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store89;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free89;
gc_free89=o1;
}
}
}
else{
int dead=1;
gc89* old_gc_free = gc_free89;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free89;
gc_free89=o1;
}
}
if (dead){
gc_free89 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark89(T89*o){
if(((gc89*)o)->header.flag==FSOH_UNMARKED){
((gc89*)o)->header.flag=FSOH_MARKED;
/*i2p*/if(NULL!=o->_left)Xgc_mark39((T0*)(o->_left));
/*i2p*/if(NULL!=o->_right)Xgc_mark39((T0*)(o->_right));
}
}/*--*/

void gc_align_mark89(fsoc*c,gc89*p){
gc89*b=((gc89*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store89)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T89*o=(&(p->object));
((gc89*)o)->header.flag=FSOH_MARKED;
/*i2p*/if(NULL!=o->_left)Xgc_mark39((T0*)(o->_left));
/*i2p*/if(NULL!=o->_right)Xgc_mark39((T0*)(o->_right));
}
}
}/*--*/
fsoc H89={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark89,
(void(*)(mch*))gc_sweep89},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc89))-1)};

T89*new89(void){
gc89*n;
fsoc*c;
if(store_left89>1){
store_left89--;
n=store89++;
}
else if(gc_free89!=NULL){
n=gc_free89;
gc_free89=n->header.next;
}
else if(store_left89==1){
store_left89=0;
store_chunk89->header.state_type=FSO_USED_CHUNK;
n=store89++;
}
else{
c=gc_fsoc_get1();
if(gc_free89!=NULL){
n=gc_free89;
gc_free89=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk89=c;
*store_chunk89=H89;
store89=((gc89*)(&(store_chunk89->first_object)));
store_left89=H89.count_minus_one;
n=store89++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M89;
return((T89*)n);
}/*--*/

void gc_sweep51(fsoc*c){
gc51*o1,*o2;
o1=((gc51*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store51;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free51;
gc_free51=o1;
}
}
}
else{
int dead=1;
gc51* old_gc_free = gc_free51;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free51;
gc_free51=o1;
}
}
if (dead){
gc_free51 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark51(T51*o){
((gc51*)o)->header.flag=FSOH_MARKED;
}/*--*/

void gc_align_mark51(fsoc*c,gc51*p){
gc51*b=((gc51*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store51)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T51*o=(&(p->object));
((gc51*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H51={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark51,
(void(*)(mch*))gc_sweep51},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc51))-1)};

T51*new51(void){
gc51*n;
fsoc*c;
if(store_left51>1){
store_left51--;
n=store51++;
}
else if(gc_free51!=NULL){
n=gc_free51;
gc_free51=n->header.next;
}
else if(store_left51==1){
store_left51=0;
store_chunk51->header.state_type=FSO_USED_CHUNK;
n=store51++;
}
else{
c=gc_fsoc_get1();
if(gc_free51!=NULL){
n=gc_free51;
gc_free51=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk51=c;
*store_chunk51=H51;
store51=((gc51*)(&(store_chunk51->first_object)));
store_left51=H51.count_minus_one;
n=store51++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M51;
return((T51*)n);
}/*--*/

void gc_mark193(T193 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark179((T179*)(e));
}}}}
}/*--*/

T193 new193(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env193.store_left)){
rsoh*r=na_env193.store;
na_env193.store_left-=size;
if(na_env193.store_left>sizeof(rsoh)){
r->header.size=size;
na_env193.store=((rsoh*)(((char*)(na_env193.store))+size));
}
else {
r->header.size=size+na_env193.store_left;
na_env193.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T193)(r+1));
}
return((T193)new_na(&na_env193,size));
}/*--*/

void gc_sweep63(fsoc*c){
gc63*o1,*o2;
o1=((gc63*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store63;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free63;
gc_free63=o1;
}
}
}
else{
int dead=1;
gc63* old_gc_free = gc_free63;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free63;
gc_free63=o1;
}
}
if (dead){
gc_free63 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark63(T63*o){
if(((gc63*)o)->header.flag==FSOH_UNMARKED){
((gc63*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
}
}/*--*/

void gc_align_mark63(fsoc*c,gc63*p){
gc63*b=((gc63*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store63)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T63*o=(&(p->object));
((gc63*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
}
}
}/*--*/
fsoc H63={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark63,
(void(*)(mch*))gc_sweep63},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc63))-1)};

T63*new63(void){
gc63*n;
fsoc*c;
if(store_left63>1){
store_left63--;
n=store63++;
}
else if(gc_free63!=NULL){
n=gc_free63;
gc_free63=n->header.next;
}
else if(store_left63==1){
store_left63=0;
store_chunk63->header.state_type=FSO_USED_CHUNK;
n=store63++;
}
else{
c=gc_fsoc_get1();
if(gc_free63!=NULL){
n=gc_free63;
gc_free63=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk63=c;
*store_chunk63=H63;
store63=((gc63*)(&(store_chunk63->first_object)));
store_left63=H63.count_minus_one;
n=store63++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M63;
return((T63*)n);
}/*--*/

void gc_sweep179(fsoc*c){
gc179*o1,*o2;
o1=((gc179*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store179;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free179;
gc_free179=o1;
}
}
}
else{
int dead=1;
gc179* old_gc_free = gc_free179;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free179;
gc_free179=o1;
}
}
if (dead){
gc_free179 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark179(T179*o){
((gc179*)o)->header.flag=FSOH_MARKED;
}/*--*/

void gc_align_mark179(fsoc*c,gc179*p){
gc179*b=((gc179*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store179)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T179*o=(&(p->object));
((gc179*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H179={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark179,
(void(*)(mch*))gc_sweep179},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc179))-1)};

T179*new179(void){
gc179*n;
fsoc*c;
if(store_left179>1){
store_left179--;
n=store179++;
}
else if(gc_free179!=NULL){
n=gc_free179;
gc_free179=n->header.next;
}
else if(store_left179==1){
store_left179=0;
store_chunk179->header.state_type=FSO_USED_CHUNK;
n=store179++;
}
else{
c=gc_fsoc_get1();
if(gc_free179!=NULL){
n=gc_free179;
gc_free179=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk179=c;
*store_chunk179=H179;
store179=((gc179*)(&(store_chunk179->first_object)));
store_left179=H179.count_minus_one;
n=store179++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M179;
return((T179*)n);
}/*--*/

void gc_sweep192(fsoc*c){
gc192*o1,*o2;
o1=((gc192*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store192;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free192;
gc_free192=o1;
}
}
}
else{
int dead=1;
gc192* old_gc_free = gc_free192;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free192;
gc_free192=o1;
}
}
if (dead){
gc_free192 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark192(T192*o){
if(((gc192*)o)->header.flag==FSOH_UNMARKED){
((gc192*)o)->header.flag=FSOH_MARKED;
/*4p*/{
T193 na=o->_storage;
if(gc_find_chunk(na)!=NULL){/* non external NA */
   rsoh*h=((rsoh*)na)-1;
   if((h->header.magic_flag)==RSOH_UNMARKED){
      h->header.magic_flag=RSOH_MARKED;
r192mark_native_arrays(o);
}
}
}}
}/*--*/

void gc_align_mark192(fsoc*c,gc192*p){
gc192*b=((gc192*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store192)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T192*o=(&(p->object));
((gc192*)o)->header.flag=FSOH_MARKED;
/*4p*/{
T193 na=o->_storage;
if(gc_find_chunk(na)!=NULL){/* non external NA */
   rsoh*h=((rsoh*)na)-1;
   if((h->header.magic_flag)==RSOH_UNMARKED){
      h->header.magic_flag=RSOH_MARKED;
r192mark_native_arrays(o);
}
}
}}
}
}/*--*/
fsoc H192={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark192,
(void(*)(mch*))gc_sweep192},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc192))-1)};

T192*new192(void){
gc192*n;
fsoc*c;
if(store_left192>1){
store_left192--;
n=store192++;
}
else if(gc_free192!=NULL){
n=gc_free192;
gc_free192=n->header.next;
}
else if(store_left192==1){
store_left192=0;
store_chunk192->header.state_type=FSO_USED_CHUNK;
n=store192++;
}
else{
c=gc_fsoc_get1();
if(gc_free192!=NULL){
n=gc_free192;
gc_free192=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk192=c;
*store_chunk192=H192;
store192=((gc192*)(&(store_chunk192->first_object)));
store_left192=H192.count_minus_one;
n=store192++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M192;
return((T192*)n);
}/*--*/

void gc_mark9(T9 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;
}/*--*/

T9 new9(unsigned int size){
size=(size*sizeof(T3))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env9.store_left)){
rsoh*r=na_env9.store;
na_env9.store_left-=size;
if(na_env9.store_left>sizeof(rsoh)){
r->header.size=size;
na_env9.store=((rsoh*)(((char*)(na_env9.store))+size));
}
else {
r->header.size=size+na_env9.store_left;
na_env9.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T9)(r+1));
}
return((T9)new_na(&na_env9,size));
}/*--*/

void gc_sweep7(fsoc*c){
gc7*o1,*o2;
o1=((gc7*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store7;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
}
else{
int dead=1;
gc7* old_gc_free = gc_free7;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
if (dead){
gc_free7 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark7(T7*o){
if(((gc7*)o)->header.flag==FSOH_UNMARKED){
((gc7*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_storage)gc_mark9((o->_storage));
}
}/*--*/

void gc_align_mark7(fsoc*c,gc7*p){
gc7*b=((gc7*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store7)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T7*o=(&(p->object));
((gc7*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_storage)gc_mark9((o->_storage));
}
}
}/*--*/
fsoc H7={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark7,
(void(*)(mch*))gc_sweep7},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc7))-1)};

T7*new7(void){
gc7*n;
fsoc*c;
if(store_left7>1){
store_left7--;
n=store7++;
}
else if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else if(store_left7==1){
store_left7=0;
store_chunk7->header.state_type=FSO_USED_CHUNK;
n=store7++;
}
else{
c=gc_fsoc_get1();
if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk7=c;
*store_chunk7=H7;
store7=((gc7*)(&(store_chunk7->first_object)));
store_left7=H7.count_minus_one;
n=store7++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M7;
return((T7*)n);
}/*--*/

void gc_sweep25(fsoc*c){
gc25*o1,*o2;
o1=((gc25*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store25;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free25;
gc_free25=o1;
}
}
}
else{
int dead=1;
gc25* old_gc_free = gc_free25;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free25;
gc_free25=o1;
}
}
if (dead){
gc_free25 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark25(T25*o){
if(((gc25*)o)->header.flag==FSOH_UNMARKED){
((gc25*)o)->header.flag=FSOH_MARKED;
/*p*/if(NULL!=o->_children)gc_mark192((T192*)(o->_children));
}
}/*--*/

void gc_align_mark25(fsoc*c,gc25*p){
gc25*b=((gc25*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store25)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T25*o=(&(p->object));
((gc25*)o)->header.flag=FSOH_MARKED;
/*p*/if(NULL!=o->_children)gc_mark192((T192*)(o->_children));
}
}
}/*--*/
fsoc H25={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark25,
(void(*)(mch*))gc_sweep25},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc25))-1)};

T25*new25(void){
gc25*n;
fsoc*c;
if(store_left25>1){
store_left25--;
n=store25++;
}
else if(gc_free25!=NULL){
n=gc_free25;
gc_free25=n->header.next;
}
else if(store_left25==1){
store_left25=0;
store_chunk25->header.state_type=FSO_USED_CHUNK;
n=store25++;
}
else{
c=gc_fsoc_get1();
if(gc_free25!=NULL){
n=gc_free25;
gc_free25=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk25=c;
*store_chunk25=H25;
store25=((gc25*)(&(store_chunk25->first_object)));
store_left25=H25.count_minus_one;
n=store25++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M25;
return((T25*)n);
}/*--*/

void Xgc_mark39(T0*o){
{int i=o->id;
if (i <= 7) {
gc_mark7((T7*)o);
}
else{
gc_mark89((T89*)o);
}}}/*--*/
T25*eiffel_root_object=(void*)0;
int se_argc;
char**se_argv;
T7*g[222];
T7*t[222];
int se_strucT[222]={0,sizeof(T1),sizeof(T2),sizeof(T3),0,0,sizeof(T6),sizeof(T7),sizeof(T8),sizeof(T9),0,0,0,0,0,0,0,0,0,
0,
0,
0,
0,
0,
0,
sizeof(T25),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T51),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T63),
0,
sizeof(T65),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T89),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T115),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T137),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T179),
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T189),
0,
0,
sizeof(T192),
sizeof(T193),
sizeof(T194),
sizeof(T195),
0,
0,
0,
0,
sizeof(T200),
sizeof(T201),
0,
sizeof(T203),
sizeof(T204),
0,
0,
0,
0,
0,
0,
sizeof(T211),
sizeof(T212)};

void se_atexit(void){
r63se_atexit();
}/*--*/

void initialize_eiffel_runtime(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
se_argc=argc;
se_argv=argv;
atexit(se_atexit);
gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));
#ifdef FIXED_STACK_BOTTOM
if (!stack_bottom) stack_bottom=((void**)(void*)(&argc));
#endif
g[179]=(T7*)se_string("MY_CHILD");
g[25]=(T7*)se_string("FORKING");
g[68]=(T7*)se_string("UNISTD_EXTERNALS");
g[67]=(T7*)se_string("POSIX_PROCESS");
g[43]=(T7*)se_string("RECYCLABLE");
g[47]=(T7*)se_string("DISPOSABLE");
g[34]=(T7*)se_string("TRAVERSABLE");
g[32]=(T7*)se_string("INDEXABLE");
g[35]=(T7*)se_string("ITERABLE");
g[31]=(T7*)se_string("SEARCHABLE");
g[41]=(T7*)se_string("HASHABLE");
g[36]=(T7*)se_string("STORABLE");
g[40]=(T7*)se_string("COMPARABLE");
g[33]=(T7*)se_string("HOARD");
g[60]=(T7*)se_string("SINGLETON");
g[178]=(T7*)se_string("SYSTEM");
g[104]=(T7*)se_string("FILE_STREAM");
g[96]=(T7*)se_string("FILTER");
g[45]=(T7*)se_string("OUTPUT_STREAM");
g[112]=(T7*)se_string("FILTER_INPUT_STREAM");
g[52]=(T7*)se_string("TERMINAL_OUTPUT_STREAM");
g[56]=(T7*)se_string("TERMINAL_INPUT_STREAM");
g[55]=(T7*)se_string("TERMINAL_INPUT_OUTPUT_STREAM");
g[109]=(T7*)se_string("FILTER_OUTPUT_STREAM");
g[57]=(T7*)se_string("INPUT_STREAM");
g[46]=(T7*)se_string("STREAM");
g[103]=(T7*)se_string("TEXT_FILE_READ");
g[152]=(T7*)se_string("TEXT_FILE_READ_WRITE");
g[54]=(T7*)se_string("STD_INPUT_OUTPUT");
g[51]=(T7*)se_string("STD_ERROR");
g[150]=(T7*)se_string("TEXT_FILE_WRITE");
g[64]=(T7*)se_string("STD_INPUT");
g[63]=(T7*)se_string("STD_OUTPUT");
g[156]=(T7*)se_string("DIRECTORY_NOTATION");
g[172]=(T7*)se_string("PATH_NAME");
g[173]=(T7*)se_string("POSIX_PATH_NAME");
g[154]=(T7*)se_string("PATH_NAME_NOTATION");
g[182]=(T7*)se_string("MACINTOSH_DIRECTORY_NOTATION");
g[183]=(T7*)se_string("OPENVMS_DIRECTORY_NOTATION");
g[186]=(T7*)se_string("MICROSOFT_PATH_NAME");
g[185]=(T7*)se_string("WINDOWS_DIRECTORY_NOTATION");
g[153]=(T7*)se_string("UNIX_DIRECTORY_NOTATION");
g[184]=(T7*)se_string("AMIGA_DIRECTORY_NOTATION");
g[187]=(T7*)se_string("CYGWIN_DIRECTORY_NOTATION");
g[58]=(T7*)se_string("INPUT_STREAM_TOOLS");
g[49]=(T7*)se_string("OUTPUT_STREAM_TOOLS");
g[53]=(T7*)se_string("REDIRECTION_TOOLS");
g[171]=(T7*)se_string("BASIC_DIRECTORY");
g[174]=(T7*)se_string("UNIXISH_PATH_NAME");
g[48]=(T7*)se_string("FILTERABLE");
g[155]=(T7*)se_string("PATH_JOINER");
g[59]=(T7*)se_string("STANDARD_STREAMS");
g[177]=(T7*)se_string("FILE_TOOLS");
g[78]=(T7*)se_string("ITERATOR");
g[95]=(T7*)se_string("ITERATOR_ON_TRAVERSABLE");
g[131]=(T7*)se_string("ITERATOR_ON_UNICODE_STRING");
g[117]=(T7*)se_string("ITERATOR_ON_DICTIONARY_ITEMS");
g[93]=(T7*)se_string("ITERATOR_ON_STRING");
g[120]=(T7*)se_string("ITERATOR_ON_DICTIONARY_KEYS");
g[116]=(T7*)se_string("PROCEDURE");
g[66]=(T7*)se_string("MEMORY");
g[15]=(T7*)se_string("TUPLE 1");
g[16]=(T7*)se_string("TUPLE 2");
g[76]=(T7*)se_string("ROUTINE");
g[17]=(T7*)se_string("TUPLE 3");
g[18]=(T7*)se_string("TUPLE 4");
g[19]=(T7*)se_string("TUPLE 5");
g[20]=(T7*)se_string("TUPLE 6");
g[21]=(T7*)se_string("TUPLE 7");
g[22]=(T7*)se_string("TUPLE 8");
g[23]=(T7*)se_string("TUPLE 9");
g[14]=(T7*)se_string("TUPLE");
g[24]=(T7*)se_string("TUPLE 10");
g[8]=(T7*)se_string("POINTER");
g[26]=(T7*)se_string("REFERENCE");
g[75]=(T7*)se_string("FUNCTION");
g[6]=(T7*)se_string("BOOLEAN");
g[77]=(T7*)se_string("SAFE_EQUAL");
g[13]=(T7*)se_string("ANY");
g[111]=(T7*)se_string("WEAK_REFERENCE");
g[44]=(T7*)se_string("PLATFORM");
g[114]=(T7*)se_string("INTERNALS_HANDLER");
g[130]=(T7*)se_string("NATIVE_ARRAY_INTERNALS");
g[61]=(T7*)se_string("TYPED_INTERNALS");
g[37]=(T7*)se_string("NATIVE_ARRAY_COLLECTOR");
g[62]=(T7*)se_string("INTERNALS");
g[105]=(T7*)se_string("URL");
g[162]=(T7*)se_string("ADDRESS");
g[133]=(T7*)se_string("PROTOCOL");
g[135]=(T7*)se_string("RESOURCE_LOCATOR");
g[160]=(T7*)se_string("ACCESS");
g[158]=(T7*)se_string("SOCKET_INPUT_OUTPUT_STREAM");
g[132]=(T7*)se_string("PROTOCOLS");
g[106]=(T7*)se_string("URL_VALIDITY");
g[161]=(T7*)se_string("HOST");
g[176]=(T7*)se_string("IP_ADDRESS");
g[159]=(T7*)se_string("TCP_ACCESS");
g[147]=(T7*)se_string("SOCKET_SERVER");
g[175]=(T7*)se_string("CLIENT_SOCKET_INPUT_OUTPUT_STREAM");
g[169]=(T7*)se_string("SERVER_SOCKET_INPUT_OUTPUT_STREAM");
g[148]=(T7*)se_string("SOCKET_PLUG_IN");
g[149]=(T7*)se_string("SOCKET_HANDLER");
g[168]=(T7*)se_string("SOCKET");
g[134]=(T7*)se_string("STREAM_PROTOCOL");
g[164]=(T7*)se_string("HTTP_CLIENT_INPUT_STREAM");
g[142]=(T7*)se_string("FILE_PROTOCOL");
g[143]=(T7*)se_string("HTTP_PROTOCOL");
g[144]=(T7*)se_string("TCP_PROTOCOL");
g[163]=(T7*)se_string("HTTP_PROXY");
g[165]=(T7*)se_string("HTTP_CLIENT_OUTPUT_STREAM");
g[151]=(T7*)se_string("FILE_RESOURCE_LOCATOR");
g[145]=(T7*)se_string("NETWORK_RESOURCE_VALIDITY");
g[157]=(T7*)se_string("NETWORK_RESOURCE_LOCATOR");
g[12]=(T7*)se_string("REAL_EXTENDED");
g[73]=(T7*)se_string("REAL_GENERAL");
g[101]=(T7*)se_string("NATURAL_64");
g[2]=(T7*)se_string("INTEGER_32");
g[91]=(T7*)se_string("NUMBER");
g[90]=(T7*)se_string("INTEGER_RANGE");
g[4]=(T7*)se_string("REAL_32");
g[1]=(T7*)se_string("INTEGER_8");
g[126]=(T7*)se_string("MUTABLE_BIG_INTEGER");
g[11]=(T7*)se_string("INTEGER_64");
g[88]=(T7*)se_string("NUMBER_TOOLS");
g[70]=(T7*)se_string("INTEGER_GENERAL");
g[5]=(T7*)se_string("REAL_64");
g[97]=(T7*)se_string("NATURAL_16");
g[71]=(T7*)se_string("INTEGRAL");
g[72]=(T7*)se_string("NUMERIC");
g[74]=(T7*)se_string("FLOAT");
g[100]=(T7*)se_string("NATURAL_32");
g[99]=(T7*)se_string("NATURAL_8");
g[98]=(T7*)se_string("NATURAL_GENERAL");
g[10]=(T7*)se_string("INTEGER_16");
g[127]=(T7*)se_string("FRACTION_WITH_BIG_INTEGER_NUMBER");
g[122]=(T7*)se_string("INTEGER_64_NUMBER");
g[123]=(T7*)se_string("INTEGER_GENERAL_NUMBER");
g[125]=(T7*)se_string("INTEGER_RANGE_ITERATOR");
g[128]=(T7*)se_string("FRACTION_GENERAL_NUMBER");
g[129]=(T7*)se_string("BIG_INTEGER_NUMBER");
g[139]=(T7*)se_string("PARSE_ERROR");
g[140]=(T7*)se_string("DEFAULT_MINI_PARSER_MEMORY");
g[141]=(T7*)se_string("MINI_PARSER_MEMORY");
g[121]=(T7*)se_string("MINI_PARSER_BUFFER");
g[136]=(T7*)se_string("EVENTS_SET");
g[107]=(T7*)se_string("EVENT_DESCRIPTOR");
g[113]=(T7*)se_string("CAN_READ_DATA_FROM_STREAM");
g[170]=(T7*)se_string("NETWORK_CONNECTION_OCCURRED");
g[108]=(T7*)se_string("STREAM_EXCEPTION");
g[110]=(T7*)se_string("CAN_WRITE_DATA_TO_STREAM");
g[138]=(T7*)se_string("ABSTRACT_SORTER");
g[30]=(T7*)se_string("COLLECTION");
g[27]=(T7*)se_string("STACK");
g[84]=(T7*)se_string("SIMPLE_DICTIONARY");
g[85]=(T7*)se_string("DICTIONARY");
g[86]=(T7*)se_string("MAP");
g[28]=(T7*)se_string("FAST_ARRAY");
g[80]=(T7*)se_string("ARRAY");
g[82]=(T7*)se_string("HASHED_DICTIONARY");
g[83]=(T7*)se_string("ABSTRACT_HASHED_DICTIONARY");
g[79]=(T7*)se_string("NATIVE_ARRAY");
g[115]=(T7*)se_string("STRING_RECYCLING_ITEM");
g[94]=(T7*)se_string("RECYCLING_POOL");
g[180]=(T7*)se_string("ARRAYED_COLLECTION_HANDLER");
g[65]=(T7*)se_string("STRING_RECYCLING_POOL");
g[137]=(T7*)se_string("STRING_RECYCLING_ITEM_SORTER");
g[119]=(T7*)se_string("ANY_HASHED_DICTIONARY_NODE");
g[29]=(T7*)se_string("ARRAYED_COLLECTION");
g[118]=(T7*)se_string("HASHED_DICTIONARY_NODE");
g[87]=(T7*)se_string("HASH_TABLE_SIZE");
g[81]=(T7*)se_string("FIXED_STRING");
g[102]=(T7*)se_string("UNICODE_STRING");
g[39]=(T7*)se_string("ABSTRACT_STRING");
g[50]=(T7*)se_string("LAZY_STRING");
g[89]=(T7*)se_string("ROPE");
g[38]=(T7*)se_string("NATIVELY_STORED_STRING");
g[3]=(T7*)se_string("CHARACTER");
g[7]=(T7*)se_string("STRING");
g[181]=(T7*)se_string("UNICODE_STRING_HANDLER");
g[42]=(T7*)se_string("STRING_HANDLER");
g[92]=(T7*)se_string("PARTIALLY_FILLED_STRING");
g[124]=(T7*)se_string("ITERATOR_ON_ROPE");
g[188]=(T7*)se_string("TIME_FORMATTER");
g[166]=(T7*)se_string("TIME");
g[146]=(T7*)se_string("MICROSECOND_TIME");
g[167]=(T7*)se_string("TIME_HANDLER");
g[69]=(T7*)se_string("ERRNO");
g[212]=g[79];
g[211]=g[79];
g[204]=g[111];
g[203]=g[79];
g[201]=g[28];
g[200]=g[79];
g[195]=g[26];
g[194]=g[27];
g[193]=g[79];
g[192]=g[28];
g[189]=g[116];
g[9]=g[79];
t[212]=(T7*)se_string("NATIVE_ARRAY[WEAK_REFERENCE[FAST_ARRAY[FIXED_STRING]]]");
t[211]=(T7*)se_string("NATIVE_ARRAY[FIXED_STRING]");
t[204]=(T7*)se_string("WEAK_REFERENCE[STRING]");
t[203]=(T7*)se_string("NATIVE_ARRAY[STRING_RECYCLING_ITEM]");
t[201]=(T7*)se_string("FAST_ARRAY[STRING_RECYCLING_ITEM]");
t[200]=(T7*)se_string("NATIVE_ARRAY[STRING]");
t[195]=(T7*)se_string("REFERENCE[STRING]");
t[194]=(T7*)se_string("STACK[STRING]");
t[193]=(T7*)se_string("NATIVE_ARRAY[POSIX_PROCESS]");
t[192]=(T7*)se_string("FAST_ARRAY[POSIX_PROCESS]");
t[189]=(T7*)se_string("PROCEDURE[TUPLE]");
t[179]=g[179];
t[137]=g[137];
t[115]=g[115];
t[89]=g[89];
t[65]=g[65];
t[63]=g[63];
t[51]=g[51];
t[25]=g[25];
t[9]=(T7*)se_string("NATIVE_ARRAY[CHARACTER]");
t[8]=g[8];
t[7]=g[7];
t[6]=g[6];
t[3]=g[3];
t[2]=g[2];
t[1]=g[1];
#ifdef SIGQUIT
signal(SIGQUIT,se_signal_handler);
#endif
#ifdef SIGILL
signal(SIGILL,se_signal_handler);
#endif
#ifdef SIGABRT
signal(SIGABRT,se_signal_handler);
#endif
#ifdef SIGFPE
signal(SIGFPE,se_signal_handler);
#endif
#ifdef SIGSEGV
signal(SIGSEGV,se_signal_handler);
#endif
#ifdef SIGBUS
signal(SIGBUS,se_signal_handler);
#endif
#ifdef SIGSYS
signal(SIGSYS,se_signal_handler);
#endif
#ifdef SIGTRAP
signal(SIGTRAP,se_signal_handler);
#endif
#ifdef SIGXCPU
signal(SIGXCPU,se_signal_handler);
#endif
#ifdef SIGXFSZ
signal(SIGXFSZ,se_signal_handler);
#endif
se_msi1();
/*PCO*/
tmp0/*new*/=((T0*)(new195()));
oBC13tagged_out_memory_ref=tmp0/*new*/;
/*tmp0.unlock*/
/*PCO*/
/*reusing tmp0*/tmp0/*new*/=((T0*)(new51()));
oBC13std_error=tmp0/*new*/;
/*tmp0.unlock*/
gc_is_off=0;
/*reusing tmp0*/tmp0/*root*/=((T0*)(new25()));
eiffel_root_object=((T25*)tmp0/*root*/);
/*tmp0.unlock*/
}/*--*/

int main(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
stack_bottom=((void**)(void*)(&argc));
initialize_eiffel_runtime(argc,argv);
tmp0/*prof*/=((T0*)eiffel_root_object);
r25make(((T25*)tmp0/*prof*/));
handle(SE_HANDLE_NORMAL_EXIT, NULL);
/*tmp0.unlock*/
exit(0);
return 0;
}/*--*/

#ifdef __cplusplus
}
#endif
