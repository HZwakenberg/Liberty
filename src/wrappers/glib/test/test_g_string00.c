#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.4 (svn snaphsot 9297) [????]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe -Os
*/

#ifdef __cplusplus
}
#endif
#include "test_g_string00.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
    /* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
T53 M53={0};
T49 M49={0,(void*)0,0};
T7 M7={(void*)0,0,0};
T54 M54={(void*)0};
T25 M25={0};
/*Aliased storage area or unicode storage.*/
char*s26_0="";
char*s26_212160365="require_check";
char*s26_48390502="all_check";
char*s26_1690381566="invariant_check";
char*s26_1992063831="ensure_check";
char*s26_1325941860="ERROR: \173""EIFFELTEST_TOOLS\175"".assert call ";
char*s26_113001857=" in class ";
char*s26_2167877="number ";
char*s26_718083334="no_check or boost";
char*s26_1075456615="Assertion level was ";
char*s26_265093627="loop_check";
char*s25_237426731="abcdefghij";
char*s26_1682790378=" failed.\nRerun this test under the -sedb debugger to find out what is going wrong.\n";
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
void se_print_run_time_stack (void) {
  handle(SE_HANDLE_ENTER_PRINT_STACK, NULL);
  fprintf(SE_ERR,"Eiffel program crash at run time.\n");
  fprintf(SE_ERR,"No trace when using option \"-boost\"\n");
  handle(SE_HANDLE_EXIT_PRINT_STACK, NULL);
}

void se_signal_handler(int sig) {
  handle(SE_HANDLE_RUNTIME_ERROR, NULL);
  printf("Received signal %d.\n",sig);
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}

/*INTEGER_32*/void r2append_in(T2 C,T0* a1){
T2 _val=0;
T2 _i=0;
T2 _idx=0;
if((C)==(INT8_C(0))){
r7extend(((T7*)a1),((T3)'0'));
}
else{
if(((int32_t)(C))>(INT32_C(0))){
_val=C;
_i=((int32_t)((/*RF2*/(((T7*)a1))->_count/*3p*/)))+(INT32_C(1));
}
else{
r7extend(((T7*)a1),((T3)'\055'));
_i=((int32_t)((/*RF2*/(((T7*)a1))->_count/*3p*/)))+(INT32_C(1));
_val=((int32_t)(C))%(INT32_C(10));
if(((int32_t)(_val))<=(INT32_C(0))){
r7extend(((T7*)a1),r2decimal_digit(-(_val)));
_val=-(((int32_t)(C))/(INT32_C(10)));
}
else{
r7extend(((T7*)a1),r2decimal_digit(((int32_t)(-(_val)))+(INT32_C(10))));
_val=((int32_t)(-(((int32_t)(C))/(INT32_C(10)))))-(INT32_C(1));
}
}
while(!((_val)==(INT8_C(0))))
{
r7extend(((T7*)a1),r2decimal_digit(((int32_t)(_val))%(INT32_C(10))));
_val=((int32_t)(_val))/(INT32_C(10));
}
_idx=(/*RF2*/(((T7*)a1))->_count/*3p*/);
while(!(((int32_t)(_i))>=(_idx)))
{
r7swap(((T7*)a1),_i,_idx);
_idx=((int32_t)(_idx))-(INT32_C(1));
_i=((int32_t)(_i))+(INT32_C(1));
}
}
}/*--*/

/*INTEGER_32*/T3 r2decimal_digit(T2 C){
T3 R=0;
R=((T3)(((int32_t)(C))+(INT32_C(48))));
return R;
}/*--*/

/*INTEGER_32*/T2 r2max(T2 C,T2 a1){
T2 R=0;
if(((int32_t)(C))>=(a1)){
R=C;
}
else{
R=a1;
}
return R;
}/*--*/

/*CHARACTER*/T6 r3_ix_62(T3 C,T3 a1){
T6 R=0;
R=((T6)(((int16_t)(T3code(C)))>(T3code(a1))));
return R;
}/*--*/

/*CHARACTER*/T3 r3next(T3 C){
T3 R=0;
R=((T3)(((int16_t)(T3code(C)))+(INT16_C(1))));
return R;
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(T9 C,T2 a1,T2 a2){
T9 R=(void*)0;
R=((T9)(se_calloc(a2,sizeof(T3))));
r9copy_from(R,C,((int32_t)(a1))-(INT32_C(1)));
return R;
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(T9 C,T9 a1,T2 a2){
T2 _i=0;
_i=a2;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=((a1)[_i]);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(T9 C,T2 a1){
T3 _v=0;
T2 _i=0;
_i=a1;
while(!(((int32_t)(_i))<(INT32_C(0))))
{
(C)[_i]=(_v);
_i=((int32_t)(_i))-(INT32_C(1));
}
}/*--*/

/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_memcmp(T9 C,T9 a1,T2 a2){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
_i=((int32_t)(a2))-(INT32_C(1));
while(1){
tmp0/*or else*/=((T6)(((int32_t)(_i))<(INT32_C(0))));
if(tmp0/*or else*/){
}
else{
tmp0/*or else*/=((T6)(((C)[_i])!=((a1)[_i])));
}
if(tmp0/*or else*/){
break;
}
_i=((int32_t)(_i))-(INT32_C(1));
}
R=((T6)(((int32_t)(_i))<(INT32_C(0))));
return R;
}/*--*/

/*STRING*/T6 r7is_equal(T7* C,T0* a1){
T6 R=0;
if(((/*RF2*/(C)->_count/*3p*/))==((/*RF2*/(((T7*)a1))->_count/*3p*/))){
R=((T6)(r9fast_memcmp((/*RF2*/(C)->_storage/*3p*/),(/*RF2*/(((T7*)a1))->_storage/*3p*/),(/*RF2*/(C)->_count/*3p*/))));
}
return R;
}/*--*/

/*STRING*/void r7copy(T7* C,T0* a1){
T2 _c=0;
_c=(/*RF2*/(((T7*)a1))->_count/*3p*/);
if(((int32_t)(_c))>(INT32_C(0))){
if(((int32_t)((/*RF2*/(C)->_capacity/*3p*/)))<(_c)){
/*SFN*/(C->_storage/*3p*/)=((T9)(se_calloc(_c,sizeof(T3))));
/*SFN*/(C->_capacity/*3p*/)=_c;
}
r9copy_from((/*RF2*/(C)->_storage/*3p*/),(/*RF2*/(((T7*)a1))->_storage/*3p*/),((int32_t)(_c))-(INT32_C(1)));
}
/*SFN*/(C->_count/*3p*/)=_c;
}/*--*/

/*STRING*/void r7put(T7* C,T3 a1,T2 a2){
((/*RF2*/(C)->_storage/*3p*/))[((int32_t)(a2))-(INT32_C(1))]=(a1);
}/*--*/

/*STRING*/void r7extend(T7* C,T3 a1){
if(((/*RF2*/(C)->_count/*3p*/))==((/*RF2*/(C)->_capacity/*3p*/))){
r7ensure_capacity(C,((int32_t)((/*RF2*/(C)->_count/*3p*/)))+(INT32_C(1)));
}
((/*RF2*/(C)->_storage/*3p*/))[(/*RF2*/(C)->_count/*3p*/)]=(a1);
/*SFN*/(C->_count/*3p*/)=((int32_t)((/*RF2*/(C)->_count/*3p*/)))+(INT32_C(1));
}/*--*/

/*STRING*/void r7add_last(T7* C,T3 a1){
if(((/*RF2*/(C)->_count/*3p*/))==((/*RF2*/(C)->_capacity/*3p*/))){
r7ensure_capacity(C,((int32_t)((/*RF2*/(C)->_count/*3p*/)))+(INT32_C(1)));
}
((/*RF2*/(C)->_storage/*3p*/))[(/*RF2*/(C)->_count/*3p*/)]=(a1);
/*SFN*/(C->_count/*3p*/)=((int32_t)((/*RF2*/(C)->_count/*3p*/)))+(INT32_C(1));
}/*--*/

/*STRING*/void r7ensure_capacity(T7* C,T2 a1){
T2 _new_capacity=0;
if(((NULL!=((void*)((/*RF2*/(C)->_storage/*3p*/)))))==(0)){
_new_capacity=r2max(a1,INT32_C(32));
/*SFN*/(C->_storage/*3p*/)=((T9)(se_calloc(_new_capacity,sizeof(T3))));
/*SFN*/(C->_capacity/*3p*/)=_new_capacity;
}
else{
if(((int32_t)((/*RF2*/(C)->_capacity/*3p*/)))<(a1)){
_new_capacity=r2max(a1,(int32_t)(((uint32_t)((/*RF2*/(C)->_capacity/*3p*/)))*((uint32_t)(INT32_C(2)))));
/*SFN*/(C->_storage/*3p*/)=r9realloc((/*RF2*/(C)->_storage/*3p*/),(/*RF2*/(C)->_capacity/*3p*/),_new_capacity);
/*SFN*/(C->_capacity/*3p*/)=_new_capacity;
}
}
}/*--*/

/*STRING*/void r7from_external_copy(T7* C,T8 a1){
T9 _s=(void*)0;
T2 _i=0;
_s=a1;
/*SFN*/(C->_count/*3p*/)=INT32_C(0);
while(!(((_s)[_i])==(((T3)'\000'))))
{
r7add_last(C,(_s)[_i]);
_i=((int32_t)(_i))+(INT32_C(1));
}
}/*--*/

/*STRING*/T8 r7to_external(T7* C){
T8 R=(void*)0;
if(((int32_t)((/*RF2*/(C)->_capacity/*3p*/)))>((/*RF2*/(C)->_count/*3p*/))){
/*SFN*/(C->_count/*3p*/)=((int32_t)((/*RF2*/(C)->_count/*3p*/)))+(INT32_C(1));
if((r7item(C,(/*RF2*/(C)->_count/*3p*/)))!=(((T3)'\000'))){
r7put(C,((T3)'\000'),(/*RF2*/(C)->_count/*3p*/));
}
}
else{
r7add_last(C,((T3)'\000'));
}
/*SFN*/(C->_count/*3p*/)=((int32_t)((/*RF2*/(C)->_count/*3p*/)))-(INT32_C(1));
R=((void*)((/*RF2*/(C)->_storage/*3p*/)));
return R;
}/*--*/

/*STRING*/void r7swap(T7* C,T2 a1,T2 a2){
T3 _tmp=0;
_tmp=r7item(C,a1);
r7put(C,r7item(C,a2),a1);
r7put(C,_tmp,a2);
}/*--*/

/*STRING*/T3 r7item(T7* C,T2 a1){
T3 R=0;
R=((/*RF2*/(C)->_storage/*3p*/))[((int32_t)(a1))-(INT32_C(1))];
return R;
}/*--*/

/*COUNTER*/void r53increment(T53* C){
/*SFN*/(C->_value/*p*/)=((int32_t)((/*RF2*/(C)->_value/*p*/)))+(INT32_C(1));
}/*--*/
T0*oBC13std_output=(void*)0;
int fBC13std_output=0;

/*STD_OUTPUT*/T0* r49std_output(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13std_output==0){fBC13std_output=1;{
tmp0/*new*/=((T0*)se_malloc(sizeof(T49)))/*3p*/;
*((T49*)tmp0/*new*/)=M49;
r49make(((T49*)tmp0/*new*/));
oBC13std_output=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13std_output;
}/*--*/

/*STD_OUTPUT*/void r49filtered_flush(T49* C){
if(((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))>(INT32_C(0))){
r49write_buffer(C);
}
io_flush((stdout));
}/*--*/

/*STD_OUTPUT*/void r49filtered_put_character(T49* C,T3 a1){
if(((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))>=(INT32_C(4096))){
r49write_buffer(C);
}
((/*RF2*/(C)->_buffer/*3p*/))[(/*RF2*/(C)->_buffer_position/*3p*/)]=(a1);
/*SFN*/(C->_buffer_position/*3p*/)=((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))+(INT32_C(1));
if((a1)==(((T3)'\n'))){
r49write_buffer(C);
}
}/*--*/

/*STD_OUTPUT*/void r49se_atexit(void){
r49filtered_flush((T49*)(r49std_output()));
}/*--*/

/*STD_OUTPUT*/void r49make(T49* C){
/*SFN*/(C->_buffer/*3p*/)=((T9)(se_calloc(INT32_C(4096),sizeof(T3))));
/*SFN*/(C->_capacity/*3p*/)=INT32_C(4096);
}/*--*/

/*STD_OUTPUT*/void r49write_buffer(T49* C){
if(((int32_t)((/*RF2*/(C)->_buffer_position/*3p*/)))>(INT32_C(0))){
io_fwrite((/*RF2*/(C)->_buffer/*3p*/),(/*RF2*/(C)->_buffer_position/*3p*/),(stdout));
/*SFN*/(C->_buffer_position/*3p*/)=INT32_C(0);
}
}/*--*/

/*STD_OUTPUT*/void r49flush(T49* C){
r49filtered_flush(C);
}/*--*/

/*STD_OUTPUT*/void r49put_string(T49* C,T0* a1){
T2 _i=0;
T2 _count=0;
_i=INT32_C(1);
_count=(/*RF2*/(((T7*)a1))->_count/*3p*/);
while(!(((int32_t)(_i))>(_count)))
{
r49filtered_put_character(C,r7item(((T7*)a1),_i));
_i=((int32_t)(_i))+(INT32_C(1));
}
}/*--*/

/*G_STRING*/T6 r54is_equal(T54* C,T0* a1){
T6 R=0;
R=((T6)((g_string_equal((/*RF2*/(C)->_handle/*p*/),(/*RF2*/(((T54*)a1))->_handle/*p*/))
/*l262c12/g_string_externals.e*/)!=(INT8_C(0))));
return R;
}/*--*/

/*G_STRING*/void r54dispose(T54* C){
T8 _p=(void*)0;
_p=g_string_free((/*RF2*/(C)->_handle/*p*/),INT32_C(1))
/*l248c12/g_string_externals.e*/;
/*SFN*/(C->_handle/*p*/)=NULL/*_POINTER*/;
}/*--*/

/*G_STRING*/T8 r54c_string(T54* C){
T8 R=(void*)0;
R=(((GString*)(/*RF2*/(C)->_handle/*p*/))->str)
/*l29c12/g_string_externals.e*/;
return R;
}/*--*/

/*G_STRING*/void r54from_string(T54* C,T0* a1){
/*SFN*/(C->_handle/*p*/)=g_string_new(r7to_external(((T7*)a1)))
/*l46c12/g_string_externals.e*/;
}/*--*/

/*G_STRING*/void r54make(T54* C,T2 a1){
/*SFN*/(C->_handle/*p*/)=g_string_sized_new(a1)
/*l54c12/g_string_externals.e*/;
}/*--*/

/*G_STRING*/void r54add_last(T54* C,T3 a1){
T9 _array=(void*)0;
T2 _oc=0;
_oc=r54count(C);
r54resize(C,((int32_t)(r54count(C)))+(INT32_C(1)));
_array=r54c_string(C);
(_array)[_oc]=(a1);
}/*--*/

/*G_STRING*/void r54resize(T54* C,T2 a1){
if(((int32_t)(a1))<(r54count(C))){
g_string_truncate((/*RF2*/(C)->_handle/*p*/),a1);
/*l228c12/g_string_externals.e*/;
}
else{
/*SFN*/(C->_handle/*p*/)=g_string_set_size((/*RF2*/(C)->_handle/*p*/),a1)
/*l238c12/g_string_externals.e*/;
}
}/*--*/

/*G_STRING*/T0* r54to_string(T54* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
tmp0/*new*/=((T0*)se_malloc(sizeof(T7)))/*3p*/;
*((T7*)tmp0/*new*/)=M7;
r7from_external_copy(((T7*)tmp0/*new*/),r54c_string(C));
R=tmp0/*new*/;
/*tmp0.unlock*/
return R;
}/*--*/

/*G_STRING*/T2 r54count(T54* C){
T2 R=0;
R=(((GString*)(/*RF2*/(C)->_handle/*p*/))->len)
/*l33c12/g_string_externals.e*/;
return R;
}/*--*/

/*TEST_G_STRING00*/T0* r25std_output(void){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
if(fBC13std_output==0){fBC13std_output=1;{
tmp0/*new*/=((T0*)se_malloc(sizeof(T49)))/*3p*/;
*((T49*)tmp0/*new*/)=M49;
r49make(((T49*)tmp0/*new*/));
oBC13std_output=tmp0/*new*/;
/*tmp0.unlock*/
}}
return oBC13std_output;
}/*--*/
T0*oBC26assert_counter=(void*)0;

/*TEST_G_STRING00*/T0* r25assertion_flag(T25* C){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
tmp0/*inspectExpression*/=(/*RF2*/(C)->_assertion_level/*p*/);
/*[inspect*/
switch(tmp0/*inspectExpression*/){
case 5:
R=ms26_48390502;
break;
case 4:
R=ms26_265093627;
break;
case 3:
R=ms26_1690381566;
break;
case 2:
R=ms26_1992063831;
break;
case 1:
R=ms26_212160365;
break;
default:;
R=ms26_718083334;
}
/*inspect]*/
return R;
}/*--*/

/*TEST_G_STRING00*/void r25label_assert(T25* C,T0* a1,T6 a2){
T0* _actual_label=(void*)0;
r53increment(((T53*)oBC26assert_counter));
if((a2)==(0)){
if((a1)!=((void*)((void*)0))){
_actual_label=a1;
}
else{
_actual_label=ms26_0;
r7copy(((T7*)_actual_label),ms26_2167877);
r2append_in((/*RF2*/(((T53*)oBC26assert_counter))->_value/*p*/),_actual_label);
}
r49put_string((T49*)(r25std_output()),ms26_1325941860);
r49put_string((T49*)(r25std_output()),_actual_label);
r49put_string((T49*)(r25std_output()),ms26_113001857);
r49put_string((T49*)(r25std_output()),(T0*)(g[25]));
r49put_string((T49*)(r25std_output()),ms26_1682790378);
r49put_string((T49*)(r25std_output()),ms26_1075456615);
r49put_string((T49*)(r25std_output()),r25assertion_flag(C));
r49filtered_put_character((T49*)(r25std_output()),((T3)'\056'));
r49filtered_put_character((T49*)(r25std_output()),((T3)'\n'));
}
}/*--*/

/*TEST_G_STRING00*/void r25make(T25* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* _s=(void*)0;
T0* _s2=(void*)0;
T3 _c=0;
tmp0/*new*/=((T0*)se_malloc(sizeof(T54)))/*p*/;
*((T54*)tmp0/*new*/)=M54;
r54make(((T54*)tmp0/*new*/),INT32_C(10));
_s=tmp0/*new*/;
/*tmp0.unlock*/
r25label_assert(C,(void*)0,(T6)((r54count(((T54*)_s)))==(INT8_C(0))));
_c=((T3)'a');
while(!((((unsigned)(_c))>((unsigned)(((T3)'j'))))))
{
r54add_last(((T54*)_s),_c);
_c=r3next(_c);
}
r25label_assert(C,(void*)0,(T6)((r54count(((T54*)_s)))==(INT8_C(10))));
/*reusing tmp0*/tmp0/*new*/=((T0*)se_malloc(sizeof(T54)))/*p*/;
*((T54*)tmp0/*new*/)=M54;
r54from_string(((T54*)tmp0/*new*/),se_ms(10,s25_237426731));
_s2=tmp0/*new*/;
/*tmp0.unlock*/
r25label_assert(C,(void*)0,(T6)(r54is_equal(((T54*)_s),_s2)));
r25label_assert(C,(void*)0,(T6)(r7is_equal((T7*)(r54to_string(((T54*)_s))),se_ms(10,s25_237426731))));
}/*--*/
T0*ms26_718083334;
T0*ms26_2167877;
T0*ms26_1992063831;
T0*ms26_1325941860;
T0*ms26_0;
T0*ms26_1690381566;
T0*ms26_113001857;
T0*ms26_265093627;
T0*ms26_212160365;
T0*ms26_48390502;
T0*ms26_1682790378;
T0*ms26_1075456615;

T0*se_ms(int c,char*e){
/* Allocate a Manifest STRING.*/
T7*s=((T7*)se_malloc(sizeof(T7)));
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)se_malloc(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

T0*se_string(char*e){
/* Allocate an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=((T7*)se_malloc(sizeof(T7)));
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)se_malloc(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

void se_msi1(void){
ms26_718083334=se_ms(17,s26_718083334);
ms26_2167877=se_ms(7,s26_2167877);
ms26_1992063831=se_ms(12,s26_1992063831);
ms26_1325941860=se_ms(38,s26_1325941860);
ms26_0=se_ms(0,s26_0);
ms26_1690381566=se_ms(15,s26_1690381566);
ms26_113001857=se_ms(10,s26_113001857);
ms26_265093627=se_ms(10,s26_265093627);
ms26_212160365=se_ms(13,s26_212160365);
ms26_48390502=se_ms(9,s26_48390502);
ms26_1682790378=se_ms(83,s26_1682790378);
ms26_1075456615=se_ms(20,s26_1075456615);
}/*--*/
T25*eiffel_root_object=(void*)0;
int se_argc;
char**se_argv;
T7*g[173];

void se_atexit(void){
r49se_atexit();
}/*--*/

void initialize_eiffel_runtime(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
se_argc=argc;
se_argv=argv;
atexit(se_atexit);
g[55]=(T7*)se_string("WRAPPER");
g[94]=(T7*)se_string("CONST_STRING");
g[56]=(T7*)se_string("POINTER_HANDLING");
g[57]=(T7*)se_string("WRAPPER_HANDLER");
g[54]=(T7*)se_string("G_STRING");
g[61]=(T7*)se_string("G_STRING_EXTERNALS");
g[60]=(T7*)se_string("GLIB_BASIC_TYPES");
g[59]=(T7*)se_string("GLIB_STRING_UTILITY_FUNCTIONS");
g[25]=(T7*)se_string("TEST_G_STRING00");
g[107]=(T7*)se_string("PROCEDURE");
g[111]=(T7*)se_string("MEMORY");
g[15]=(T7*)se_string("TUPLE 1");
g[16]=(T7*)se_string("TUPLE 2");
g[84]=(T7*)se_string("ROUTINE");
g[17]=(T7*)se_string("TUPLE 3");
g[18]=(T7*)se_string("TUPLE 4");
g[19]=(T7*)se_string("TUPLE 5");
g[20]=(T7*)se_string("TUPLE 6");
g[21]=(T7*)se_string("TUPLE 7");
g[22]=(T7*)se_string("TUPLE 8");
g[58]=(T7*)se_string("EXCEPTIONS");
g[23]=(T7*)se_string("TUPLE 9");
g[14]=(T7*)se_string("TUPLE");
g[24]=(T7*)se_string("TUPLE 10");
g[8]=(T7*)se_string("POINTER");
g[93]=(T7*)se_string("REFERENCE");
g[83]=(T7*)se_string("FUNCTION");
g[6]=(T7*)se_string("BOOLEAN");
g[64]=(T7*)se_string("SAFE_EQUAL");
g[13]=(T7*)se_string("ANY");
g[132]=(T7*)se_string("WEAK_REFERENCE");
g[38]=(T7*)se_string("PLATFORM");
g[92]=(T7*)se_string("INTERNALS_HANDLER");
g[115]=(T7*)se_string("NATIVE_ARRAY_INTERNALS");
g[47]=(T7*)se_string("TYPED_INTERNALS");
g[86]=(T7*)se_string("NATIVE_ARRAY_COLLECTOR");
g[48]=(T7*)se_string("INTERNALS");
g[82]=(T7*)se_string("COLLECTION");
g[103]=(T7*)se_string("STACK");
g[117]=(T7*)se_string("SIMPLE_DICTIONARY");
g[118]=(T7*)se_string("DICTIONARY");
g[101]=(T7*)se_string("FAST_ARRAY");
g[85]=(T7*)se_string("ARRAY");
g[116]=(T7*)se_string("HASHED_DICTIONARY");
g[63]=(T7*)se_string("NATIVE_ARRAY");
g[124]=(T7*)se_string("STRING_RECYCLING_ITEM");
g[102]=(T7*)se_string("RECYCLING_POOL");
g[110]=(T7*)se_string("STRING_RECYCLING_POOL");
g[150]=(T7*)se_string("STRING_RECYCLING_ITEM_SORTER");
g[131]=(T7*)se_string("ANY_HASHED_DICTIONARY_NODE");
g[87]=(T7*)se_string("ARRAYED_COLLECTION");
g[130]=(T7*)se_string("HASHED_DICTIONARY_NODE");
g[119]=(T7*)se_string("HASH_TABLE_SIZE");
g[140]=(T7*)se_string("DIRECTORY_NOTATION");
g[62]=(T7*)se_string("FILTER");
g[27]=(T7*)se_string("OUTPUT_STREAM");
g[158]=(T7*)se_string("PATH_NAME");
g[90]=(T7*)se_string("FILTER_INPUT_STREAM");
g[40]=(T7*)se_string("TERMINAL_OUTPUT_STREAM");
g[163]=(T7*)se_string("FILE_TOOLS");
g[44]=(T7*)se_string("TERMINAL_INPUT_STREAM");
g[43]=(T7*)se_string("TERMINAL_INPUT_OUTPUT_STREAM");
g[79]=(T7*)se_string("FILTER_OUTPUT_STREAM");
g[45]=(T7*)se_string("INPUT_STREAM");
g[28]=(T7*)se_string("STREAM");
g[74]=(T7*)se_string("FILE");
g[73]=(T7*)se_string("TEXT_FILE_READ");
g[136]=(T7*)se_string("TEXT_FILE_READ_WRITE");
g[42]=(T7*)se_string("STD_INPUT_OUTPUT");
g[39]=(T7*)se_string("STD_ERROR");
g[134]=(T7*)se_string("TEXT_FILE_WRITE");
g[50]=(T7*)se_string("STD_INPUT");
g[49]=(T7*)se_string("STD_OUTPUT");
g[46]=(T7*)se_string("INPUT_STREAM_TOOLS");
g[32]=(T7*)se_string("OUTPUT_STREAM_TOOLS");
g[41]=(T7*)se_string("REDIRECTION_TOOLS");
g[157]=(T7*)se_string("BASIC_DIRECTORY");
g[160]=(T7*)se_string("UNIXISH_PATH_NAME");
g[31]=(T7*)se_string("FILTERABLE");
g[139]=(T7*)se_string("PATH_JOINER");
g[159]=(T7*)se_string("POSIX_PATH_NAME");
g[138]=(T7*)se_string("PATH_NAME_NOTATION");
g[166]=(T7*)se_string("MACINTOSH_DIRECTORY_NOTATION");
g[167]=(T7*)se_string("OPENVMS_DIRECTORY_NOTATION");
g[170]=(T7*)se_string("MICROSOFT_PATH_NAME");
g[169]=(T7*)se_string("WINDOWS_DIRECTORY_NOTATION");
g[137]=(T7*)se_string("UNIX_DIRECTORY_NOTATION");
g[168]=(T7*)se_string("AMIGA_DIRECTORY_NOTATION");
g[171]=(T7*)se_string("CYGWIN_DIRECTORY_NOTATION");
g[165]=(T7*)se_string("UNICODE_STRING_HANDLER");
g[81]=(T7*)se_string("ITERATOR");
g[113]=(T7*)se_string("ITERATOR_ON_TRAVERSABLE");
g[104]=(T7*)se_string("ITERATOR_ON_UNICODE_STRING");
g[129]=(T7*)se_string("ITERATOR_ON_DICTIONARY_ITEMS");
g[89]=(T7*)se_string("ITERATOR_ON_STRING");
g[133]=(T7*)se_string("ITERATOR_ON_DICTIONARY_KEYS");
g[151]=(T7*)se_string("ABSTRACT_SORTER");
g[53]=(T7*)se_string("COUNTER");
g[26]=(T7*)se_string("EIFFELTEST_TOOLS");
g[114]=(T7*)se_string("MINI_PARSER_BUFFER");
g[112]=(T7*)se_string("EVENTS_SET");
g[77]=(T7*)se_string("EVENT_DESCRIPTOR");
g[91]=(T7*)se_string("CAN_READ_DATA_FROM_STREAM");
g[156]=(T7*)se_string("NETWORK_CONNECTION_OCCURRED");
g[78]=(T7*)se_string("STREAM_EXCEPTION");
g[80]=(T7*)se_string("CAN_WRITE_DATA_TO_STREAM");
g[30]=(T7*)se_string("RECYCLABLE");
g[29]=(T7*)se_string("DISPOSABLE");
g[34]=(T7*)se_string("TRAVERSABLE");
g[37]=(T7*)se_string("HASHABLE");
g[35]=(T7*)se_string("STORABLE");
g[36]=(T7*)se_string("COMPARABLE");
g[12]=(T7*)se_string("REAL_EXTENDED");
g[67]=(T7*)se_string("REAL_GENERAL");
g[70]=(T7*)se_string("NATURAL_64");
g[2]=(T7*)se_string("INTEGER_32");
g[71]=(T7*)se_string("NUMBER");
g[4]=(T7*)se_string("REAL_32");
g[1]=(T7*)se_string("INTEGER_8");
g[97]=(T7*)se_string("MUTABLE_BIG_INTEGER");
g[11]=(T7*)se_string("INTEGER_64");
g[88]=(T7*)se_string("NUMBER_TOOLS");
g[51]=(T7*)se_string("INTEGER_GENERAL");
g[5]=(T7*)se_string("REAL_64");
g[65]=(T7*)se_string("NATURAL_16");
g[52]=(T7*)se_string("NUMERIC");
g[69]=(T7*)se_string("NATURAL_32");
g[68]=(T7*)se_string("NATURAL_8");
g[66]=(T7*)se_string("NATURAL_GENERAL");
g[10]=(T7*)se_string("INTEGER_16");
g[98]=(T7*)se_string("FRACTION_WITH_BIG_INTEGER_NUMBER");
g[95]=(T7*)se_string("INTEGER_64_NUMBER");
g[96]=(T7*)se_string("INTEGER_GENERAL_NUMBER");
g[99]=(T7*)se_string("FRACTION_GENERAL_NUMBER");
g[100]=(T7*)se_string("BIG_INTEGER_NUMBER");
g[72]=(T7*)se_string("UNICODE_STRING");
g[3]=(T7*)se_string("CHARACTER");
g[7]=(T7*)se_string("STRING");
g[33]=(T7*)se_string("STRING_HANDLER");
g[172]=(T7*)se_string("TIME_FORMATTER");
g[152]=(T7*)se_string("TIME");
g[125]=(T7*)se_string("MICROSECOND_TIME");
g[153]=(T7*)se_string("TIME_HANDLER");
g[75]=(T7*)se_string("URL");
g[145]=(T7*)se_string("ADDRESS");
g[106]=(T7*)se_string("PROTOCOL");
g[109]=(T7*)se_string("RESOURCE_LOCATOR");
g[143]=(T7*)se_string("ACCESS");
g[146]=(T7*)se_string("SOCKET_INPUT_OUTPUT_STREAM");
g[105]=(T7*)se_string("PROTOCOLS");
g[76]=(T7*)se_string("URL_VALIDITY");
g[144]=(T7*)se_string("HOST");
g[162]=(T7*)se_string("IP_ADDRESS");
g[142]=(T7*)se_string("TCP_ACCESS");
g[126]=(T7*)se_string("SOCKET_SERVER");
g[161]=(T7*)se_string("CLIENT_SOCKET_INPUT_OUTPUT_STREAM");
g[155]=(T7*)se_string("SERVER_SOCKET_INPUT_OUTPUT_STREAM");
g[127]=(T7*)se_string("SOCKET_PLUG_IN");
g[128]=(T7*)se_string("SOCKET_HANDLER");
g[154]=(T7*)se_string("SOCKET");
g[108]=(T7*)se_string("STREAM_PROTOCOL");
g[148]=(T7*)se_string("HTTP_CLIENT_INPUT_STREAM");
g[120]=(T7*)se_string("FILE_PROTOCOL");
g[121]=(T7*)se_string("HTTP_PROTOCOL");
g[122]=(T7*)se_string("TCP_PROTOCOL");
g[147]=(T7*)se_string("HTTP_PROXY");
g[149]=(T7*)se_string("HTTP_CLIENT_OUTPUT_STREAM");
g[135]=(T7*)se_string("FILE_RESOURCE_LOCATOR");
g[123]=(T7*)se_string("NETWORK_RESOURCE_VALIDITY");
g[141]=(T7*)se_string("NETWORK_RESOURCE_LOCATOR");
g[164]=(T7*)se_string("SYSTEM");
g[9]=g[63];
#ifdef SIGQUIT
signal(SIGQUIT,se_signal_handler);
#endif
#ifdef SIGILL
signal(SIGILL,se_signal_handler);
#endif
#ifdef SIGABRT
signal(SIGABRT,se_signal_handler);
#endif
#ifdef SIGFPE
signal(SIGFPE,se_signal_handler);
#endif
#ifdef SIGSEGV
signal(SIGSEGV,se_signal_handler);
#endif
#ifdef SIGBUS
signal(SIGBUS,se_signal_handler);
#endif
#ifdef SIGSYS
signal(SIGSYS,se_signal_handler);
#endif
#ifdef SIGTRAP
signal(SIGTRAP,se_signal_handler);
#endif
#ifdef SIGXCPU
signal(SIGXCPU,se_signal_handler);
#endif
#ifdef SIGXFSZ
signal(SIGXFSZ,se_signal_handler);
#endif
se_msi1();
/*PCO*/
tmp0/*new*/=((T0*)se_malloc(sizeof(T53)))/*p*/;
*((T53*)tmp0/*new*/)=M53;
oBC26assert_counter=tmp0/*new*/;
/*tmp0.unlock*/
/*reusing tmp0*/tmp0/*root*/=((T0*)se_malloc(sizeof(T25)))/*p*/;
*((T25*)tmp0/*root*/)=M25;
eiffel_root_object=((T25*)tmp0/*root*/);
/*tmp0.unlock*/
}/*--*/

int main(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
initialize_eiffel_runtime(argc,argv);
tmp0/*prof*/=((T0*)eiffel_root_object);
r25make(((T25*)tmp0/*prof*/));
handle(SE_HANDLE_NORMAL_EXIT, NULL);
/*tmp0.unlock*/
exit(0);
return 0;
}/*--*/

#ifdef __cplusplus
}
#endif
