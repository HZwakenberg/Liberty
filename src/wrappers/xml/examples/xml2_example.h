#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.4 (svn snaphsot 9297) [????]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/

#ifndef _BASE_H
#define _BASE_H

#if defined(_MSC_VER) && (_MSC_VER >= 1400)       /* VC8+ */
# ifndef _CRT_SECURE_NO_DEPRECATE
#  define _CRT_SECURE_NO_DEPRECATE
# endif
# ifndef _CRT_NONSTDC_NO_DEPRECATE
#  define _CRT_NONSTDC_NO_DEPRECATE
# endif
#endif   /* VC8+ */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1600) /* MSVC older than v10 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1220) /* WATCOM 12.2 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned __int64 uint64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#  include <cygwin/version.h>
#  if defined(CYGWIN_VERSION_DLL_MAJOR) && (CYGWIN_VERSION_DLL_MAJOR<1005)
typedef unsigned char uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
#  endif
#elif defined(SASC)
#    error("Too old SAS/C compiler, sorry.");
#elif defined(__SASC__)
#  if (__SASC__ < 750 ) /*  SAS/C before 7.50 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long int uint32_t;
typedef unsigned long long int uint64_t;
#  endif
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif


/*
  Endian stuff
*/
#if defined(BSD) && (BSD >= 199103)
#  include <machine/endian.h>
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
/* bi-endian processor, current mode should be find in machine/endian.h file */
#  include <machine/endian.h>
#elif defined(linux)
#  include <endian.h>
#endif



#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
#  define BYTE_ORDER      __BYTE_ORDER
#endif

#if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
#  define LITTLE_ENDIAN      __LITTLE_ENDIAN
#endif

#if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
#  define BIG_ENDIAN      __BIG_ENDIAN
#endif

#if !defined(LITTLE_ENDIAN)
#  define LITTLE_ENDIAN   1234    /* LSB first (vax, pc) */
#endif
#if !defined(BIG_ENDIAN)
#  define BIG_ENDIAN      4321    /* MSB first (IBM, net) */
#endif
#if !defined(PDP_ENDIAN)
#  define PDP_ENDIAN      3412    /* LSB first in word, MSW first in long */
#endif

#if !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_RIGHT)
#  define BYTE_ORDER      LITTLE_ENDIAN
#elif !defined(BYTE_ORDER) && defined(BIT_ZERO_ON_LEFT)
#  define BYTE_ORDER      BIG_ENDIAN
#elif !defined(BYTE_ORDER)

/* ARM */
#  if defined(__ARMEL__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(__ARMEB__)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__arm__)
#    error "ARMs are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* HP RISC */
#  if defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* IBM */
#  if defined(ibm032) || defined(ibm370) || defined(_IBMR2) || \
      defined(IBM370) || defined(__MVS__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Intel x86 */
#  if defined(i386) || defined(__i386__) || defined(__i386) || \
      defined(_M_IX86) || defined(_X86_) || defined(__THW_INTEL) || \
      defined(sun386)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Intel Itanium */
#  if defined(__ia64__) || defined(_IA64) || defined(__IA64__) || \
      defined(_M_IA64)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Nationnal Semiconductor 32000 serie */
#  if  defined(ns32000)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Motorola 68000 */
#  if defined(mc68000) || defined(is68k) || defined(macII) || defined(m68k)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* MIPS */
#  if defined(MIPSEL) || defined(_MIPSEL)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  elif defined(MIPSEB) || defined(_MIPSEB)
#    define BYTE_ORDER      BIG_ENDIAN
#  elif defined(__mips__) || defined(__mips) || defined(__MIPS__)
#    error "MIPS are bi-endian processors. Endianness is unknown for this system, please drop an e-mail to SmartEiffel@loria.fr"
#  endif

/* Power PC */
/* this processor is bi-endian, how to know if little-endian is set? */
#  if defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \
      defined(__ppc__) || defined(__ppc) || defined(_M_PPC) || \
      defined(__PPC) || defined(__PPC__)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* Pyramid 9810 */
#  if defined(pyr)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* RS/6000 */
#  if defined(__THW_RS6000) || defined(_IBMR2) || defined(_POWER) || \
      defined(_ARCH_PWR) || defined(_ARCH_PWR2)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* SPARC */
#  if defined(__sparc__) || defined(sparc) || defined(__sparc)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* CCI Tahoe */
#  if defined(tahoe)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif

/* VAX */
#  if defined(vax) || defined(VAX) || defined(__vax__) || defined(_vax_) || \
      defined(__vax) || defined(__VAX)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* ELATE is a virtual OS with a little endian Virtual Processor */
#  if defined(__ELATE__)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous little endian */
#  if defined(wrltitan)
#    define BYTE_ORDER      LITTLE_ENDIAN
#  endif

/* Miscellaneous big endian */
#  if defined(apollo) || defined(__convex__) || defined(_CRAY) || defined(sel)
#    define BYTE_ORDER      BIG_ENDIAN
#  endif
#endif


#if !defined(BYTE_ORDER)
#  error "Unknown byte order. Add your system in above macros once you know your system type. Please drop an e-mail to SmartEiffel@loria.fr"
#endif
#if (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN)
#  error "Only little-endian and big-endian are valid at this time. Please drop an e-mail to SmartEiffel@loria.fr"
#endif


/*
  Byte swapping stuff
*/
extern void copy_swap_16(const uint16_t *src, uint16_t *dest, int count);


/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.

   NOTE: with gcc, -ansi is used for SmartEiffel generated files EXCEPT in
   -no_split mode. ANSI only recognizes the non-sig versions.
*/
#if (defined(_SIGSET_H_types) && !defined(__STRICT_ANSI__))
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T10)(x))
#define T3to_integer(x) ((signed char)(x))
#define T3to_integer_8(x) ((signed char)(x))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL_32 is #4:
*/
typedef float T4;
typedef T4 real32_t;
#define EIF_REAL_32 T4
#define M4 (0.0)
#define EIF_MINIMUM_REAL_32 (-(FLT_MAX))
#define EIF_MAXIMUM_REAL_32 (FLT_MAX)

/*
  Eiffel type REAL or REAL_64 is #5:
*/
typedef double T5;
typedef T5 real64_t;
#define EIF_REAL_64 T5
#define M5 (0.0)
#define EIF_MINIMUM_REAL_64 (-(DBL_MAX))
#define EIF_MINIMUM_REAL (EIF_MINIMUM_REAL_64)
#define EIF_MAXIMUM_REAL_64 (DBL_MAX)
#define EIF_MAXIMUM_REAL (EIF_MAXIMUM_REAL_64)

/*
  Eiffel type REAL_EXTENDED is #12:
*/
typedef long double T12;
typedef T12 real_extended_t;
#define EIF_REAL_EXTENDED T12
#define M12 (0.0)
#define EIF_MINIMUM_REAL_EXTENDED (-(DBL_MAX))
#define EIF_MAXIMUM_REAL_EXTENDED (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
/* Sometimes, NULL is defined as 0 */
#define M8 ((void*)NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void* src, size_t size);

/*
   die method.
 */
void se_die(int code);

/*
    Runtime hooks. They allow different runtime modules to be quite independant. In time, they will also allow
    thread-safe operations.

    Currently known modules:
      - boost
      - no_check
      - sedb
      - gc
      - print stack
      - profile
      - plugins

    However, currently only profile uses this method. It will be extended to other modules later.

    The currently defined hooks are described in the enum below (the names should be self-explanatory).
 */
typedef enum {
  SE_HANDLE_EXCEPTION_SET, /* called when an exception handler is set, prior to SETJMP */
  SE_HANDLE_EXCEPTION_CLEAR, /* called when a feature with an exception handler normally returns */
  SE_HANDLE_EXCEPTION_THROWN, /* called when an exception is thrown, prior to the LONGJMP */
  SE_HANDLE_ENTER_GC, /* called when gc_start() begins */
  SE_HANDLE_EXIT_GC, /* called when gc_start() ends */
  SE_HANDLE_ENTER_PRINT_STACK, /* called when se_print_run_time_stack() begins */
  SE_HANDLE_EXIT_PRINT_STACK, /* called when se_print_run_time_stack() ends */
  SE_HANDLE_NO_MORE_MEMORY, /* called by se_alloc() and co */
  SE_HANDLE_SEDB_BREAK, /* called when sedb stops the program */
  SE_HANDLE_SEDB_CONTINUE, /* called when sedb continues the program */
  SE_HANDLE_RUNTIME_ERROR, /* called when a runtime error is raised and not caught by an exception. Cannot be raised in boost mode. */
  SE_HANDLE_DIE_WITH_CODE, /* called when the program is stopped by the die_with_code feature. The data points to the int code. */
  SE_HANDLE_NORMAL_EXIT /* called when the program correctly terminates. The data is null. */
} se_handler_action_t;

extern int handlers_count;
typedef void se_runtime_handler_t(se_handler_action_t action, void*data);
void register_handler(se_runtime_handler_t*handler);
void _handle(se_handler_action_t action, void*data);

#define handle(action,data) do{if(handlers_count>0)_handle(action,data);}while(0)

#endif /* #ifndef _BASE_H */
#define SE_GC_LIB 1
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#include <errno.h>

#define text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define io_fclose(p) (fclose((FILE*)(p)))
#define io_flush(p) (fflush((FILE*)(p)))
#define io_getc(f) (getc(((FILE*)(f))))
#define io_putc(b, f) (putc((b),((FILE*)(f))))
#define io_ungetc(b, f) (ungetc((b), (FILE*)(f)))
#define io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define io_feof(f) (feof(((FILE*)(f))))
#define io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define io_remove(f) (remove(((char*)(f))))
#define io_fseek(f, o) (fseek((FILE*)(f),(o),SEEK_SET))
#define io_ftell(f) ((EIF_INTEGER_64)ftell((FILE*)(f)))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
   extern int read_stdin(EIF_CHARACTER *buffer, int size);
#endif

extern void io_copy(char*source, char*target);
extern int io_file_exists(char*source);
extern int io_same_physical_file(char*path1,char*path2);
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>

xmlChar *xml_node_get_name (xmlNode *a_node);
xmlNode *xml_node_get_children (xmlNode *a_node);
xmlNode *xml_node_get_children (xmlNode *a_node);
xmlNode *xml_node_get_parent (xmlNode *a_node);
xmlNode *xml_node_get_next (xmlNode *a_node);
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#define pointer_hash_code(p) (((unsigned int)(unsigned long)(p))>>1)
#define pointer_to_any(p) ((T0*)(p))
#define pointer_plus(p, o) (((char*)(p))+o)
/* C Header Pass 1: */
typedef struct S190 T190;
typedef struct S193 T193;
typedef struct S192 T192;
typedef struct S189 T189;
typedef struct S188 T188;
typedef struct S187 T187;
typedef struct S184 T184;
typedef struct S182 T182;
typedef struct S181 T181;
typedef struct S7 T7;
typedef struct S98 T98;
typedef struct S179 T179;
typedef struct S51 T51;
typedef struct S67 T67;
typedef struct S59 T59;
typedef struct S25 T25;
/* C Header Pass 2: */
typedef T0**T194;
#define M194 NULL
typedef T0**T191;
#define M191 NULL
typedef T0**T183;
#define M183 NULL
typedef T0**T180;
#define M180 NULL
typedef T3*T9;
#define M9 NULL
/* C Header Pass 3: */
/* C Header Pass 4: */
void se_prinT194(FILE* file,T194*o);
struct S193{Tid id;T0* _item;};
extern T193 M193;
void se_prinT193(FILE* file,T193**o);
struct S192{Tid id;T8 _item;T0* _key;T0* _next;};
extern T192 M192;
void se_prinT192(FILE* file,T192**o);
void se_prinT191(FILE* file,T191*o);
struct S190{Tid id;T0* _item;T0* _key;T0* _next;};
extern T190 M190;
void se_prinT190(FILE* file,T190**o);
struct S189{Tid id;T0* _item;};
extern T189 M189;
void se_prinT189(FILE* file,T189**o);
struct S188{Tid id;T194 _buckets;T2 _capacity;T2 _count;T2 _cache_user;T0* _cache_node;T2 _cache_buckets;T0* _free_nodes;};
extern T188 M188;
void se_prinT188(FILE* file,T188**o);
struct S187{Tid id;T0* _item;};
extern T187 M187;
void se_prinT187(FILE* file,T187**o);
struct S184{Tid id;T0* _item;T8 _key;T0* _next;};
extern T184 M184;
void se_prinT184(FILE* file,T184**o);
void se_prinT183(FILE* file,T183*o);
struct S182{Tid id;T191 _buckets;T2 _capacity;T2 _count;T2 _cache_user;T0* _cache_node;T2 _cache_buckets;T0* _free_nodes;};
extern T182 M182;
void se_prinT182(FILE* file,T182**o);
struct S181{Tid id;T183 _buckets;T2 _capacity;T2 _count;T2 _cache_user;T0* _cache_node;T2 _cache_buckets;T0* _free_nodes;};
extern T181 M181;
void se_prinT181(FILE* file,T181**o);
void se_prinT180(FILE* file,T180*o);
struct S98{Tid id;T0* _wrappers;};
extern T98 M98;
void se_prinT98(FILE* file,T98**o);
struct S179{Tid id;T180 _storage;T2 _capacity;T2 _upper;};
extern T179 M179;
void se_prinT179(FILE* file,T179**o);
struct S51{Tid id;T0* _filter;T2 _buffer_position;T9 _buffer;T2 _capacity;};
extern T51 M51;
void se_prinT51(FILE* file,T51**o);
struct S67{Tid id;T8 _handle;T6 _is_shared;};
extern T67 M67;
void se_prinT67(FILE* file,T67**o);
struct S59{Tid id;T8 _handle;};
extern T59 M59;
void se_prinT59(FILE* file,T59**o);
struct S25{Tid id;T0* _doc;};
extern T25 M25;
void se_prinT25(FILE* file,T25**o);
void se_prinT9(FILE* file,T9*o);
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
extern char*s25_1097781507;
extern char*s25_1367916000;
extern char*s13_14150;
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.h) is automatically included
  when `ace.no_check' is true (ie. all modes except mode -boost).
*/

void se_prinT0(FILE* file,T0** o);
void se_prinT1(FILE* file,EIF_INTEGER_8* o);
void se_prinT2(FILE* file,EIF_INTEGER* o);
void se_prinT3(FILE* file,EIF_CHARACTER* o);
void se_prinT4(FILE* file,EIF_REAL_32* o);
void se_prinT5(FILE* file,EIF_REAL_64* o);
void se_prinT12(FILE* file,EIF_REAL_EXTENDED* o);
void se_prinT6(FILE* file,EIF_BOOLEAN* o);
void se_prinT7(FILE* file,EIF_STRING* o);
void se_prinT8(FILE* file,EIF_POINTER* o);
void se_prinT10(FILE* file,EIF_INTEGER_16* o);
void se_prinT11(FILE* file,EIF_INTEGER_64* o);

/*
   This type is used to store a position in some Eiffel source file.
   It must be compatible with the implementation of class POSITION.
*/
typedef unsigned int se_position;

#define se_position2line(position) (((position) & 1) \
  ? ((EIF_INTEGER)(((position) >> 1) & 0x7FFF)) \
  : ((EIF_INTEGER)(((position) >> 8) & 0x1FFF)))

#define se_position2column(position) (((position) & 1) \
  ? 0 \
  : ((EIF_INTEGER)(((position) >> 1) & 0x7F)))

#define se_position2path_id(position) (((position) & 1) \
  ? ((position) >> 17) \
  : ((position) >> 21))

/*
  To be able to print a stack frame in a human readable format :
*/
typedef struct _se_frame_descriptor se_frame_descriptor;
struct _se_frame_descriptor {
  char* name; /* Eiffel name of the routine. */
  int use_current; /* Flag is 1 when this routine use Current. */
  int local_count; /* Number of C variables to print. */
  char* local_format; /* Format/type information. */
  int assertion_flag; /* 1 when assertions can be checked. */
};

/* For flat_check opion */
extern int assertion_depth;

/*
  To keep the track of execution in order to be able to print a
  dump when things goes wrong :
*/
typedef struct _se_dump_stack se_dump_stack;
struct _se_dump_stack {
  se_frame_descriptor* fd;
  void* current; /* NULL when not used. */
  se_position p; /* The current position. */
  se_dump_stack* caller; /* Back to the caller. */
  se_dump_stack* exception_origin; /* The exception origin if we are handling an exception. That object was malloc'ed */
  void*** locals;
};

se_dump_stack* se_dst;
#define set_se_dst(ds) se_dst=(ds)

int se_stack_size(se_dump_stack* ds);
void se_print_run_time_stack(void);
void se_print_run_time_stack_in(FILE* file);
int se_print_one_frame(se_dump_stack*ds);
int se_print_one_frame_in(FILE* file, se_dump_stack*ds);

int se_rci(se_dump_stack*caller,void*C);
void error0(char*m,char*vv);
void error1(char*m,se_position position);
void error2(T0* o,se_position position);
T0* vc(T0* o, se_position position);
T0* se_string_inspect_check(T0* o, se_position position);
T0* ci(int id, T0* o, se_position position);
void ac_req(int v, char* vv);
void ac_ens(int v, char* vv);
void ac_inv(int v, char* vv);
void ac_liv(int v, char* vv);
void ac_insp(int v);
int ac_lvc(int lc,int lv1,int lv2);
void ac_civ(int v,char*vv);
T0* se_evobt(T0* o,se_position position);
void se_signal_handler(int sig);
void se_gc_check_id(void*o,int id);

/* The two following instructions are used by the exceptions system to keep
   the stack trace when jumping back to the retry clause */
se_dump_stack* se_new_dump_stack(se_dump_stack* copy);
void se_delete_dump_stack(se_dump_stack* ds);

#ifndef SE_TRACE
#    define set_dump_stack_top(ds) set_se_dst(ds)
#else
#    define set_dump_stack_top(ds) \
       do { \
         se_print_call_trace(ds); \
         set_se_dst(ds); \
       } while(0)
#endif
#define FSOC_SIZE 8192
#define RSOC_SIZE 32768
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
   This file (SmartEiffel/sys/runtime/gc_lib.h) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has
   been selected).
*/

#define SE_GC_LIB 1

#define SE_GC_LOW_MEMORY_STRATEGY 0
#define SE_GC_HIGH_MEMORY_STRATEGY 1
#define SE_GC_DEFAULT_MEMORY_STRATEGY 2
extern int se_gc_strategy;


#define RSOH_UNMARKED 15253
#define RSOH_FREE 1
#define RSOH_MARKED 2


#define FSOH_UNMARKED ((void *) 1)
#define FSOH_MARKED   ((void *) 2)

/* To codify the state and the type of some Memory Chunk, we are
   using the following definitions :
*/
#define FSO_FREE_CHUNK  (-2)
#define RSO_FREE_CHUNK  (-1)
#define RSO_USED_CHUNK  ( 0)
#define FSO_STORE_CHUNK ( 1)
#define FSO_USED_CHUNK  ( 2)
#define FREE_CHUNK(x) ((x)<0)

/* Minimum size for a store area in a ReSizable Objects Chunk :
 */
#define RSOC_MIN_STORE 512

/* The default channel used to print -gc_info flag information :
*/
#define SE_GCINFO SE_ERR

extern int collector_counter; /* MEMORY.collector_counter */

typedef struct s_mch mch; /* Memory Chunk Header. */
typedef struct s_fsoc fsoc; /* Fixed Size Objects Chunk. */
typedef union u_rsoh rsoh; /* ReSizable Object Header. */
typedef struct s_fll_rsoh fll_rsoh;
typedef struct s_rsoc rsoc; /* ReSizable Objects Chunk. */
typedef struct s_na_env na_env; /* Native Array ENVironment. */


struct s_mch{
  unsigned int size; /* In number of bytes (actual argument of malloc).*/
  int state_type; /* One value in : RSO_USED_CHUNK,
                     FREE_CHUNK, FSO_STORE_CHUNK, FSO_USED_CHUNK */
  void(*amfp)(mch*,void*); /* Align Mark Function Pointer. */
  void(*swfp)(mch*); /* SWeep Function Pointer. */
};

struct s_fsoc{
  mch header; /* Common header for fsoc and rsoc. */
  fsoc* next; /* The next one when in free list (fsocfl). */
  int count_minus_one;
  double first_object;
};

typedef struct _rso_header rso_header;

struct _rso_header{
    unsigned int size;
    int magic_flag;     /* RSOH_MARKED when used,
			   RSOH_FREE when free,
			   else RSOH_UNMARKED */
};

typedef union u_fso_header fso_header;

union u_fso_header{
  void* flag;
  void* next;/* accurately typed as gcXX* in actual fso headers */
};

union u_rsoh{
  rso_header header;
  double padding;
};

struct s_fll_rsoh {
  rso_header rsoh_field;
  fll_rsoh* nextflol;
};

struct s_rsoc{
  mch header; /* Common header for fsoc and rsoc. */
  unsigned int isize; /* Initial size (at malloc time) to detect split chunks. */
  rsoc* next; /* Next one when in free list (rsocfl) or in na_env->chunk_list. */
  fll_rsoh*free_list_of_large; /* Intra. free list. */
  na_env*nae;
  rsoh first_header;
};

struct s_na_env{
  unsigned int store_left;
  rsoh* store;
  rsoc*store_chunk;
  rsoc*chunk_list; /*List of chunks of that type that have a non-null free_list_of_large*/
  void (*gc_mark)(T0*);
  int space_used;
};

extern void**stack_bottom;
extern mch**gcmt;
extern int gcmt_max;
extern int gcmt_used;
extern int gc_is_off;
extern fsoc* fsocfl;
extern unsigned int fsoc_count;
extern unsigned int rsoc_count;
extern void*gcmt_tail_addr;

void gc_sweep(void);
void gc_mark(void* p);
mch* gc_find_chunk(void* p);
int gc_stack_size(void);
int garbage_delayed(void);
void gc_update_ceils(void);
char*new_na(na_env*nae,unsigned int size);
unsigned int fsocfl_count(void);
unsigned int rsocfl_count(void);
void gc_dispose_before_exit(void);
void mark_stack_and_registers (void);
fsoc* gc_fsoc_get1(void);
fsoc* gc_fsoc_get2(void);

int gc_memory_used(void);
extern unsigned int fsoc_count_ceil;
extern unsigned int rsoc_count_ceil;
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/T0* r194item(se_dump_stack*caller,T194 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/void r194put(se_dump_stack*caller,T194 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/T6 r194all_default(se_dump_stack*caller,T194 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/void r194clear_all(se_dump_stack*caller,T194 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/T194 r194calloc(se_dump_stack*caller,T194 C,T2 a1);
/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/void r193set_item(se_dump_stack*caller,T193* C,T0* a1);
/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/T6 r192is_default(se_dump_stack*caller,T192* C);
/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/T0* r192default(se_dump_stack*caller,T192* C);
/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/void r192make(se_dump_stack*caller,T192* C,T8 a1,T0* a2,T0* a3);
/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/void r192set_next(se_dump_stack*caller,T192* C,T0* a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/T0* r191item(se_dump_stack*caller,T191 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/void r191put(se_dump_stack*caller,T191 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/T6 r191all_default(se_dump_stack*caller,T191 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/void r191clear_all(se_dump_stack*caller,T191 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/T191 r191calloc(se_dump_stack*caller,T191 C,T2 a1);
/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r190is_default(se_dump_stack*caller,T190* C);
/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r190default(se_dump_stack*caller,T190* C);
/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r190make(se_dump_stack*caller,T190* C,T0* a1,T0* a2,T0* a3);
/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r190set_next(se_dump_stack*caller,T190* C,T0* a1);
/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/void r189set_item(se_dump_stack*caller,T189* C,T0* a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188new_node(se_dump_stack*caller,T188* C,T0* a1,T0* a2,T0* a3);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r188special_common_dictionary(se_dump_stack*caller,T188* C,T0* a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r188increase_capacity(se_dump_stack*caller,T188* C);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r188add(se_dump_stack*caller,T188* C,T0* a1,T0* a2);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188at(se_dump_stack*caller,T188* C,T0* a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188fast_has(se_dump_stack*caller,T188* C,T0* a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188has(se_dump_stack*caller,T188* C,T0* a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188prime_capacity(se_dump_stack*caller,T188* C,T2 a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188prime_number_ceiling(se_dump_stack*caller,T188* C,T2 a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188should_increase_capacity(se_dump_stack*caller,T188* C,T2 a1,T2 a2);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188key_safe_equal(se_dump_stack*caller,T188* C,T0* a1,T0* a2);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188fast_at(se_dump_stack*caller,T188* C,T0* a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188count(se_dump_stack*caller,T188* C);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188fast_reference_at(se_dump_stack*caller,T188* C,T0* a1);
/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188upper(se_dump_stack*caller,T188* C);
extern se_frame_descriptor se_ifd188;
T188*se_i188(se_dump_stack*caller,T188*C);
/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/void r187set_item(se_dump_stack*caller,T187* C,T0* a1);
/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/T6 r184is_default(se_dump_stack*caller,T184* C);
/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/T0* r184default(se_dump_stack*caller,T184* C);
/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/void r184make(se_dump_stack*caller,T184* C,T0* a1,T8 a2,T0* a3);
/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/void r184set_next(se_dump_stack*caller,T184* C,T0* a1);
/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/void r184set_item(se_dump_stack*caller,T184* C,T0* a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/T0* r183item(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/void r183put(se_dump_stack*caller,T183 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/T6 r183all_default(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/void r183clear_all(se_dump_stack*caller,T183 C,T2 a1);
/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/T183 r183calloc(se_dump_stack*caller,T183 C,T2 a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/T0* r182new_node(se_dump_stack*caller,T182* C,T8 a1,T0* a2,T0* a3);
/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182is_empty(se_dump_stack*caller,T182* C);
/*HASHED_DICTIONARY[POINTER,STRING]*/void r182create_with_capacity(se_dump_stack*caller,T182* C,T2 a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/void r182increase_capacity(se_dump_stack*caller,T182* C);
/*HASHED_DICTIONARY[POINTER,STRING]*/void r182add(se_dump_stack*caller,T182* C,T8 a1,T0* a2);
/*HASHED_DICTIONARY[POINTER,STRING]*/T8 r182at(se_dump_stack*caller,T182* C,T0* a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182fast_has(se_dump_stack*caller,T182* C,T0* a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182has(se_dump_stack*caller,T182* C,T0* a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/void r182make(se_dump_stack*caller,T182* C);
/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182prime_capacity(se_dump_stack*caller,T182* C,T2 a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182prime_number_ceiling(se_dump_stack*caller,T182* C,T2 a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182should_increase_capacity(se_dump_stack*caller,T182* C,T2 a1,T2 a2);
/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182key_safe_equal(se_dump_stack*caller,T182* C,T0* a1,T0* a2);
/*HASHED_DICTIONARY[POINTER,STRING]*/T8 r182fast_at(se_dump_stack*caller,T182* C,T0* a1);
/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182count(se_dump_stack*caller,T182* C);
extern T0*oBC122common_free_nodes;
extern int fBC122common_free_nodes;
/*HASHED_DICTIONARY[POINTER,STRING]*/T0* r182common_free_nodes(se_dump_stack*caller,T182* C);
/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182upper(se_dump_stack*caller,T182* C);
extern se_frame_descriptor se_ifd182;
T182*se_i182(se_dump_stack*caller,T182*C);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T0* r181new_node(se_dump_stack*caller,T181* C,T0* a1,T8 a2,T0* a3);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T6 r181is_empty(se_dump_stack*caller,T181* C);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/void r181create_with_capacity(se_dump_stack*caller,T181* C,T2 a1);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/void r181increase_capacity(se_dump_stack*caller,T181* C);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/void r181put(se_dump_stack*caller,T181* C,T0* a1,T8 a2);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T0* r181at(se_dump_stack*caller,T181* C,T8 a1);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T6 r181has(se_dump_stack*caller,T181* C,T8 a1);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/void r181make(se_dump_stack*caller,T181* C);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T2 r181prime_capacity(se_dump_stack*caller,T181* C,T2 a1);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T2 r181prime_number_ceiling(se_dump_stack*caller,T181* C,T2 a1);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T6 r181should_increase_capacity(se_dump_stack*caller,T181* C,T2 a1,T2 a2);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T0* r181reference_at(se_dump_stack*caller,T181* C,T8 a1);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T6 r181key_safe_equal(se_dump_stack*caller,T181* C,T8 a1,T8 a2);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T2 r181count(se_dump_stack*caller,T181* C);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T0* r181common_free_nodes(se_dump_stack*caller,T181* C);
/*HASHED_DICTIONARY[XML2_NODE,POINTER]*/T2 r181upper(se_dump_stack*caller,T181* C);
extern se_frame_descriptor se_ifd181;
T181*se_i181(se_dump_stack*caller,T181*C);
/*NATIVE_ARRAY[STRING]*/T0* r180item(se_dump_stack*caller,T180 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/T6 r180is_not_null(se_dump_stack*caller,T180 C);
/*NATIVE_ARRAY[STRING]*/void r180put(se_dump_stack*caller,T180 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/T6 r180all_default(se_dump_stack*caller,T180 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/void r180clear_all(se_dump_stack*caller,T180 C,T2 a1);
/*NATIVE_ARRAY[STRING]*/T180 r180calloc(se_dump_stack*caller,T180 C,T2 a1);
/*XML2_NODE_CACHE*/void r98default_create(se_dump_stack*caller,T98* C);
/*XML2_NODE_CACHE*/T6 r98current_is_not_an_expanded_type(se_dump_stack*caller,T98* C);
extern T0*oBC99singleton_memory_pool;
extern int fBC99singleton_memory_pool;
/*XML2_NODE_CACHE*/T0* r98singleton_memory_pool(se_dump_stack*caller,T98* C);
/*XML2_NODE_CACHE*/T6 r98is_real_singleton(se_dump_stack*caller,T98* C);
/*XML2_NODE_CACHE*/T0* r98wrapper_or_void(se_dump_stack*caller,T98* C,T8 a1);
/*XML2_NODE_CACHE*/T0* r98wrapper(se_dump_stack*caller,T98* C,T8 a1);
extern se_frame_descriptor se_ifd98;
T98*se_i98(se_dump_stack*caller,T98*C);
/*FAST_ARRAY[STRING]*/T6 r179valid_index(se_dump_stack*caller,T179* C,T2 a1);
/*FAST_ARRAY[STRING]*/T6 r179is_empty(se_dump_stack*caller,T179* C);
/*FAST_ARRAY[STRING]*/T0* r179item(se_dump_stack*caller,T179* C,T2 a1);
/*FAST_ARRAY[STRING]*/void r179mark_native_arrays(se_dump_stack*caller,T179* C);
/*FAST_ARRAY[STRING]*/void r179put(se_dump_stack*caller,T179* C,T0* a1,T2 a2);
/*FAST_ARRAY[STRING]*/T6 r179all_default(se_dump_stack*caller,T179* C);
/*FAST_ARRAY[STRING]*/void r179make(se_dump_stack*caller,T179* C,T2 a1);
/*FAST_ARRAY[STRING]*/T2 r179count(se_dump_stack*caller,T179* C);
extern se_frame_descriptor se_ifd179;
T179*se_i179(se_dump_stack*caller,T179*C);
/*INTEGER_16*/T6 r10is_equal(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10_ix_6261(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10_ix_60(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T6 r10in_range(se_dump_stack*caller,T10 C,T10 a1,T10 a2);
/*INTEGER_16*/T6 r10_ix_6061(se_dump_stack*caller,T10 C,T10 a1);
/*INTEGER_16*/T2 r10hash_code(se_dump_stack*caller,T10 C);
/*STD_OUTPUT*/T6 r51can_put_character(se_dump_stack*caller,T51* C,T3 a1);
/*STD_OUTPUT*/void r51put_new_line(se_dump_stack*caller,T51* C);
/*STD_OUTPUT*/void r51dispose(se_dump_stack*caller,T51* C);
extern T0*oBC13std_output;
extern int fBC13std_output;
/*STD_OUTPUT*/T0* r51std_output(se_dump_stack*caller,T51* C);
/*STD_OUTPUT*/void r51filtered_flush(se_dump_stack*caller,T51* C);
/*STD_OUTPUT*/void r51filtered_put_character(se_dump_stack*caller,T51* C,T3 a1);
/*STD_OUTPUT*/void r51se_atexit(se_dump_stack*caller,T51* C);
/*STD_OUTPUT*/void r51make(se_dump_stack*caller,T51* C);
/*STD_OUTPUT*/T6 r51is_filtered(se_dump_stack*caller,T51* C);
/*STD_OUTPUT*/void r51put_character(se_dump_stack*caller,T51* C,T3 a1);
/*STD_OUTPUT*/void r51flush(se_dump_stack*caller,T51* C);
/*STD_OUTPUT*/void r51put_string(se_dump_stack*caller,T51* C,T0* a1);
/*STD_OUTPUT*/void r51write_buffer(se_dump_stack*caller,T51* C);
/*XML2_NODE*/T6 r67is_not_null(se_dump_stack*caller,T67* C);
/*XML2_NODE*/void r67dispose(se_dump_stack*caller,T67* C);
/*XML2_NODE*/T8 r67default_pointer(se_dump_stack*caller,T67* C);
extern T0*oBC66cache;
extern int fBC66cache;
/*XML2_NODE*/T0* r67cache(se_dump_stack*caller,T67* C);
/*XML2_NODE*/void r67free(se_dump_stack*caller,T67* C,T8 a1);
/*XML2_NODE*/void r67from_external_pointer(se_dump_stack*caller,T67* C,T8 a1);
/*XML2_NODE*/void r67set_shared(se_dump_stack*caller,T67* C);
/*XML2_NODE*/T0* r67next(se_dump_stack*caller,T67* C);
/*XML2_NODE*/T0* r67name(se_dump_stack*caller,T67* C);
/*XML2_NODE*/T0* r67first(se_dump_stack*caller,T67* C);
/*XML2_DOC*/void r59dispose(se_dump_stack*caller,T59* C);
/*XML2_DOC*/T8 r59default_pointer(se_dump_stack*caller,T59* C);
/*XML2_DOC*/T0* r59cache(se_dump_stack*caller,T59* C);
/*XML2_DOC*/void r59free(se_dump_stack*caller,T59* C,T8 a1);
/*XML2_DOC*/void r59from_external_pointer(se_dump_stack*caller,T59* C,T8 a1);
/*XML2_DOC*/T0* r59root(se_dump_stack*caller,T59* C);
/*POINTER*/T6 r8is_equal(se_dump_stack*caller,T8 C,T8 a1);
/*POINTER*/T6 r8is_null(se_dump_stack*caller,T8 C);
/*POINTER*/T8 r8default(se_dump_stack*caller);
/*POINTER*/T6 r8same_dynamic_type(se_dump_stack*caller,T8 C,T8 a1);
/*POINTER*/T2 r8hash_code(se_dump_stack*caller,T8 C);
/*BOOLEAN*/T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1);
/*BOOLEAN*/T6 r6_px_not(se_dump_stack*caller,T6 C);
/*BOOLEAN*/T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1);
/*INTEGER_8*/T6 r1is_equal(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T1 r1_ix_45(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1_ix_6261(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1_ix_60(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1_ix_62(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T6 r1in_range(se_dump_stack*caller,T1 C,T1 a1,T1 a2);
/*INTEGER_8*/T6 r1_ix_6061(se_dump_stack*caller,T1 C,T1 a1);
/*INTEGER_8*/T2 r1hash_code(se_dump_stack*caller,T1 C);
/*INTEGER_32*/T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_ix_354747(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_ix_43(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_ix_42(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2_px_45(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_45(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_6261(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2compare(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_60(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_62(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2in_range(se_dump_stack*caller,T2 C,T2 a1,T2 a2);
/*INTEGER_32*/T2 r2min(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T6 r2_ix_6061(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2max(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2hash_code(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_359292(se_dump_stack*caller,T2 C,T2 a1);
/*INTEGER_32*/T2 r2abs(se_dump_stack*caller,T2 C);
/*INTEGER_32*/T2 r2_ix_1246060(se_dump_stack*caller,T2 C,T1 a1);
/*XML2_EXAMPLE*/T0* r25std_output(se_dump_stack*caller,T25* C);
/*XML2_EXAMPLE*/void r25print(se_dump_stack*caller,T25* C,T0* a1);
/*XML2_EXAMPLE*/T2 r25argument_count(se_dump_stack*caller,T25* C);
/*XML2_EXAMPLE*/T0* r25argument(se_dump_stack*caller,T25* C,T2 a1);
extern T0*oBC26command_arguments;
extern int fBC26command_arguments;
/*XML2_EXAMPLE*/T0* r25command_arguments(se_dump_stack*caller,T25* C);
/*XML2_EXAMPLE*/T0* r25parse_file(se_dump_stack*caller,T25* C,T0* a1);
/*XML2_EXAMPLE*/void r25parse(se_dump_stack*caller,T25* C,T0* a1);
/*XML2_EXAMPLE*/void r25make(se_dump_stack*caller,T25* C);
/*CHARACTER*/T6 r3is_default(se_dump_stack*caller,T3 C);
/*CHARACTER*/T3 r3default(se_dump_stack*caller);
/*CHARACTER*/T10 r3Maximum_character_code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T10 r3Minimum_character_code(se_dump_stack*caller,T3 C);
/*CHARACTER*/T6 r3_ix_60(se_dump_stack*caller,T3 C,T3 a1);
/*CHARACTER*/T10 r3code(se_dump_stack*caller,T3 C);
/*NATIVE_ARRAY[CHARACTER]*/T3 r9item(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9is_not_null(se_dump_stack*caller,T9 C);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9is_null(se_dump_stack*caller,T9 C);
/*NATIVE_ARRAY[CHARACTER]*/void r9put(se_dump_stack*caller,T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/void r9clear_all(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9calloc(se_dump_stack*caller,T9 C,T2 a1);
/*NATIVE_ARRAY[CHARACTER]*/T9 r9realloc(se_dump_stack*caller,T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_from(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9copy_at(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/T6 r9fast_memcmp(se_dump_stack*caller,T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/void r9slice_copy(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
/*STRING*/T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T6 r7is_default(se_dump_stack*caller,T7* C);
/*STRING*/T3 r7item(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/T0* r7substring(se_dump_stack*caller,T7* C,T2 a1,T2 a2);
/*STRING*/void r7copy(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T0* r7default(se_dump_stack*caller,T7* C);
/*STRING*/void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2);
/*STRING*/void r7out_in_tagged_out_memory(se_dump_stack*caller,T7* C);
/*STRING*/void r7append(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T0* r7twin(se_dump_stack*caller,T7* C);
extern T0*oBC13tagged_out_memory;
extern int fBC13tagged_out_memory;
/*STRING*/T0* r7tagged_out_memory(se_dump_stack*caller,T7* C);
/*STRING*/void r7set_count(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/void r7print_on(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T6 r7same_dynamic_type(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/void r7clear_count(se_dump_stack*caller,T7* C);
/*STRING*/T6 r7_ix_60(se_dump_stack*caller,T7* C,T0* a1);
/*STRING*/T2 r7hash_code(se_dump_stack*caller,T7* C);
/*STRING*/void r7make(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/void r7add_last(se_dump_stack*caller,T7* C,T3 a1);
/*STRING*/void r7ensure_capacity(se_dump_stack*caller,T7* C,T2 a1);
/*STRING*/void r7from_external_copy(se_dump_stack*caller,T7* C,T8 a1);
/*STRING*/T8 r7to_external(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7count(se_dump_stack*caller,T7* C);
/*STRING*/T2 r7upper(se_dump_stack*caller,T7* C);
extern se_frame_descriptor se_ifd7;
T7*se_i7(se_dump_stack*caller,T7*C);
extern T0*ms13_14150;
extern T0*ms25_1367916000;
extern T0*ms25_1097781507;
T0*se_ms(int c,char*e);
T0*se_string(char*e);
void se_msi1(void);
void manifest_string_mark1(void);
void once_function_mark(void);
void gc_start(void);
extern na_env na_env194;
typedef struct B193 gc193;
struct B193{T193 object;union {void*flag;gc193*next;} header;};
extern gc193*store193;
extern int store_left193;
extern fsoc*store_chunk193;
extern gc193*gc_free193;
typedef struct B192 gc192;
struct B192{T192 object;union {void*flag;gc192*next;} header;};
extern gc192*store192;
extern int store_left192;
extern fsoc*store_chunk192;
extern gc192*gc_free192;
extern na_env na_env191;
typedef struct B190 gc190;
struct B190{T190 object;union {void*flag;gc190*next;} header;};
extern gc190*store190;
extern int store_left190;
extern fsoc*store_chunk190;
extern gc190*gc_free190;
typedef struct B189 gc189;
struct B189{T189 object;union {void*flag;gc189*next;} header;};
extern gc189*store189;
extern int store_left189;
extern fsoc*store_chunk189;
extern gc189*gc_free189;
typedef struct B188 gc188;
struct B188{T188 object;union {void*flag;gc188*next;} header;};
extern gc188*store188;
extern int store_left188;
extern fsoc*store_chunk188;
extern gc188*gc_free188;
typedef struct B187 gc187;
struct B187{T187 object;union {void*flag;gc187*next;} header;};
extern gc187*store187;
extern int store_left187;
extern fsoc*store_chunk187;
extern gc187*gc_free187;
typedef struct B184 gc184;
struct B184{T184 object;union {void*flag;gc184*next;} header;};
extern gc184*store184;
extern int store_left184;
extern fsoc*store_chunk184;
extern gc184*gc_free184;
extern na_env na_env183;
typedef struct B182 gc182;
struct B182{T182 object;union {void*flag;gc182*next;} header;};
extern gc182*store182;
extern int store_left182;
extern fsoc*store_chunk182;
extern gc182*gc_free182;
typedef struct B181 gc181;
struct B181{T181 object;union {void*flag;gc181*next;} header;};
extern gc181*store181;
extern int store_left181;
extern fsoc*store_chunk181;
extern gc181*gc_free181;
extern na_env na_env180;
typedef struct B98 gc98;
struct B98{T98 object;union {void*flag;gc98*next;} header;};
extern gc98*store98;
extern int store_left98;
extern fsoc*store_chunk98;
extern gc98*gc_free98;
typedef struct B179 gc179;
struct B179{T179 object;union {void*flag;gc179*next;} header;};
extern gc179*store179;
extern int store_left179;
extern fsoc*store_chunk179;
extern gc179*gc_free179;
typedef struct B51 gc51;
struct B51{T51 object;union {void*flag;gc51*next;} header;};
extern gc51*store51;
extern int store_left51;
extern fsoc*store_chunk51;
extern gc51*gc_free51;
typedef struct B67 gc67;
struct B67{T67 object;union {void*flag;gc67*next;} header;};
extern gc67*store67;
extern int store_left67;
extern fsoc*store_chunk67;
extern gc67*gc_free67;
typedef struct B59 gc59;
struct B59{T59 object;union {void*flag;gc59*next;} header;};
extern gc59*store59;
extern int store_left59;
extern fsoc*store_chunk59;
extern gc59*gc_free59;
typedef struct B25 gc25;
struct B25{T25 object;union {void*flag;gc25*next;} header;};
extern gc25*store25;
extern int store_left25;
extern fsoc*store_chunk25;
extern gc25*gc_free25;
extern na_env na_env9;
typedef struct B7 gc7;
struct B7{T7 object;union {void*flag;gc7*next;} header;};
extern gc7*store7;
extern int store_left7;
extern fsoc*store_chunk7;
extern gc7*gc_free7;
void gc_mark194(T194 o);
T194 new194(unsigned int size);
void gc_sweep193(fsoc*c);
void gc_update_weak_ref_item193(T193* wr);
void gc_mark193(T193*o);
void gc_align_mark193(fsoc*c,gc193*p);
extern fsoc H193;
T193*new193(void);
void gc_sweep192(fsoc*c);
void gc_mark192(T192*o);
void gc_align_mark192(fsoc*c,gc192*p);
extern fsoc H192;
T192*new192(void);
void gc_mark191(T191 o);
T191 new191(unsigned int size);
void gc_sweep190(fsoc*c);
void gc_mark190(T190*o);
void gc_align_mark190(fsoc*c,gc190*p);
extern fsoc H190;
T190*new190(void);
void gc_sweep189(fsoc*c);
void gc_update_weak_ref_item189(T189* wr);
void gc_mark189(T189*o);
void gc_align_mark189(fsoc*c,gc189*p);
extern fsoc H189;
T189*new189(void);
void gc_sweep188(fsoc*c);
void gc_mark188(T188*o);
void gc_align_mark188(fsoc*c,gc188*p);
extern fsoc H188;
T188*new188(void);
void gc_sweep187(fsoc*c);
void gc_update_weak_ref_item187(T187* wr);
void gc_mark187(T187*o);
void gc_align_mark187(fsoc*c,gc187*p);
extern fsoc H187;
T187*new187(void);
void gc_sweep184(fsoc*c);
void gc_mark184(T184*o);
void gc_align_mark184(fsoc*c,gc184*p);
extern fsoc H184;
T184*new184(void);
void gc_mark183(T183 o);
T183 new183(unsigned int size);
void gc_sweep182(fsoc*c);
void gc_mark182(T182*o);
void gc_align_mark182(fsoc*c,gc182*p);
extern fsoc H182;
T182*new182(void);
void gc_sweep181(fsoc*c);
void gc_mark181(T181*o);
void gc_align_mark181(fsoc*c,gc181*p);
extern fsoc H181;
T181*new181(void);
void gc_mark180(T180 o);
T180 new180(unsigned int size);
void gc_sweep98(fsoc*c);
void gc_mark98(T98*o);
void gc_align_mark98(fsoc*c,gc98*p);
extern fsoc H98;
T98*new98(void);
void gc_sweep179(fsoc*c);
void gc_mark179(T179*o);
void gc_align_mark179(fsoc*c,gc179*p);
extern fsoc H179;
T179*new179(void);
void gc_sweep51(fsoc*c);
void gc_mark51(T51*o);
void gc_align_mark51(fsoc*c,gc51*p);
extern fsoc H51;
T51*new51(void);
void gc_sweep67(fsoc*c);
void gc_mark67(T67*o);
void gc_align_mark67(fsoc*c,gc67*p);
extern fsoc H67;
T67*new67(void);
void gc_sweep59(fsoc*c);
void gc_mark59(T59*o);
void gc_align_mark59(fsoc*c,gc59*p);
extern fsoc H59;
T59*new59(void);
void gc_sweep25(fsoc*c);
void gc_mark25(T25*o);
void gc_align_mark25(fsoc*c,gc25*p);
extern fsoc H25;
T25*new25(void);
void gc_mark9(T9 o);
T9 new9(unsigned int size);
void gc_sweep7(fsoc*c);
void gc_mark7(T7*o);
void gc_align_mark7(fsoc*c,gc7*p);
extern fsoc H7;
T7*new7(void);
void Xgc_mark186(T0*o);
extern T25*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 195
extern T7*g[];
extern T7*t[];
extern char*p[];
extern void(*se_prinT[195])(FILE*,void*);
extern int se_strucT[];
void se_atexit(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
int main(int argc,char*argv[]);

#ifdef __cplusplus
}
#endif
