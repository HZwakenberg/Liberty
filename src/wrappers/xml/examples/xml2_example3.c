#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.4 (svn snaphsot 9297) [????]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

#ifdef __cplusplus
}
#endif
#include "xml2_example.h"
#ifdef __cplusplus
extern "C" {
#endif

/*STRING*/T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
T6 tmp1;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal"" STRING",1,2,"%R7%other%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E0C804/*l200c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x01A03608/*l54c4/any.e*/;
ac_req((a1)!=((void*)((void*)0)),"other /= Void");
ds.p=0x01A03608/*l54c4/any.e*/;
ac_req((a1)!=((void*)((void*)0)),"other /= Void");
fd.assertion_flag=1;
}
ds.p=0x00E0CD0E/*l205c7/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E0CD1E/*l205c15/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E0CD1E/*l205c15/string.e*/);
}
if(((/*RF2*/(C)->_count/*i3p*/))==(r7count(&ds,se_i7(&ds,((T7*)(((T7*)a1))))))){
ds.p=0x00E0CE0A/*l206c5/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E0CE46/*l206c35/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E0CE46/*l206c35/string.e*/);
}
ds.p=0x00E0CE64/*l206c50/string.e*/;
R=((T6)(r9fast_memcmp(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(se_i7(&ds,((T7*)(((T7*)a1)))))->_storage/*i3p*/),(/*RF2*/(C)->_count/*i3p*/))));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x01A03922/*l57c17/any.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A03946/*l57c35/any.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A03946/*l57c35/any.e*/);
}
tmp0/*implies*/=((T6)(((T0*)(t[(C)->id]))==((void*)((T0*)(t[(a1)->id])))));
if(tmp0/*implies*/){
ds.p=0x01A03982/*l57c65/any.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A03994/*l57c74/any.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A03994/*l57c74/any.e*/);
}
tmp0/*implies*/=((T6)((R)==(r7is_equal(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),(T0*)C))));
}
else{
tmp0/*implies*/=((T6)(1));
}
ac_ens(tmp0/*implies*/,"commutative");
ds.p=0x04C01320/*l19c16/comparable.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x04C01372/*l19c57/comparable.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x04C01372/*l19c57/comparable.e*/);
}
ac_ens((R)==(r6_ix_and(&ds,(T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,C),a1)))),(T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),(T0*)C)))))),"trichotomy");
ds.p=0x04E01C08/*l28c4/hashable.e*/;
tmp1/*implies*/=((T6)(R));
if(tmp1/*implies*/){
ds.p=0x04E01C26/*l28c19/hashable.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x04E01C3E/*l28c31/hashable.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x04E01C3E/*l28c31/hashable.e*/);
}
tmp1/*implies*/=((T6)((r7hash_code(&ds,C))==(r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))))));
}
else{
tmp1/*implies*/=((T6)(1));
}
ac_ens(tmp1/*implies*/,"Result implies hash_code = other.hash_code");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index"" STRING",1,2,"%R7%i%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x04802504/*l37c2/traversable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x04802A08/*l42c4/traversable.e*/;
tmp0/*and then*/=((T6)(r2_ix_6061(&ds,/*RF1lower*/INT32_C(1),a1)));
if(tmp0/*and then*/){
ds.p=0x04802A48/*l42c36/traversable.e*/;
tmp0/*and then*/=((T6)(r2_ix_6061(&ds,a1,r7upper(&ds,C))));
}
R=((T6)(tmp0/*and then*/));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04802C20/*l44c16/traversable.e*/;
ac_ens((R)==(r6_ix_and(&ds,(T6)(r2_ix_6061(&ds,/*RF1lower*/INT32_C(1),a1)),(T6)(r2_ix_6061(&ds,a1,r7upper(&ds,C))))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T6 r7is_default(se_dump_stack*caller,T7* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default"" STRING",1,1,"%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A08404/*l132c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x01A08D08/*l141c4/any.e*/;
R=((T6)((C)==((void*)(r7default(&ds,C)))));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T3 r7item(se_dump_stack*caller,T7* C,T2 a1){
T3 R=0;
void**locals[2];
static se_frame_descriptor fd={"item"" STRING",1,2,"%R7%i%E2%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E07104/*l113c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04804808/*l72c4/traversable.e*/;
ac_req(r7valid_index(&ds,C,a1),"valid_index(i)");
fd.assertion_flag=1;
}
ds.p=0x00E07608/*l118c4/string.e*/;
R=r9item(&ds,(/*RF2*/(C)->_storage/*i3p*/),r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T0* r7substring(se_dump_stack*caller,T7* C,T2 a1,T2 a2){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
T2 _c=0;
void**locals[4];
static se_frame_descriptor fd={"substring"" STRING",1,4,"%R7%start_index%E2%end_index%E2%Result%R7%c%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E6F204/*l1778c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
locals[3]=(void**)&_c;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E6F732/*l1783c25/string.e*/;
ac_req(r2_ix_6061(&ds,/*IC*/(T2)(INT8_C(1)),a1),"valid_start_index");
ds.p=0x00E6F83E/*l1784c31/string.e*/;
ac_req(r2_ix_6061(&ds,a2,(/*RF2*/(C)->_count/*i3p*/)),"valid_end_index");
ds.p=0x00E6F94A/*l1785c37/string.e*/;
ac_req(r2_ix_6061(&ds,a1,r2_ix_43(&ds,a2,/*IC*/(T2)(INT8_C(1)))),"meaningful_interval");
fd.assertion_flag=1;
}
ds.p=0x00E6FD08/*l1789c4/string.e*/;
_c=r2_ix_43(&ds,r2_ix_45(&ds,a2,a1),/*IC*/(T2)(INT8_C(1)));
ds.p=0x00E6FE2E/*l1790c23/string.e*/;
tmp0/*new*/=((T0*)(new7()));
r7make(&ds,((T7*)tmp0/*new*/),_c);
R=tmp0/*new*/;
/*tmp0.unlock*/
se_i7(&ds,((T7*)(R)));ds.p=0x00E6FF12/*l1791c9/string.e*/;
if(r2_ix_62(&ds,_c,/*IC*/(T2)(INT8_C(0)))){
ds.p=0x00E70018/*l1792c12/string.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E7000A/*l1792c5/string.e*/);
}
if((((R)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E7000A/*l1792c5/string.e*/);
}
ds.p=0x00E7002C/*l1792c22/string.e*/;
r7set_count(&ds,se_i7(&ds,((T7*)(((T7*)R)))),_c);
ds.p=0x00E70128/*l1793c20/string.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E7010A/*l1793c5/string.e*/);
}
if((((R)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E7010A/*l1793c5/string.e*/);
}
ds.p=0x00E7013E/*l1793c31/string.e*/;
r9slice_copy(&ds,(/*RF2*/(se_i7(&ds,((T7*)(((T7*)R)))))->_storage/*i3p*/),/*IC*/(T2)(INT8_C(0)),(/*RF2*/(C)->_storage/*i3p*/),r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))),r2_ix_45(&ds,a2,/*IC*/(T2)(INT8_C(1))));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E70438/*l1796c28/string.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E7042A/*l1796c21/string.e*/);
}
if((((R)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E7042A/*l1796c21/string.e*/);
}
ds.p=0x00E70478/*l1796c60/string.e*/;
ac_ens((r7count(&ds,se_i7(&ds,((T7*)(((T7*)R))))))==(r2_ix_43(&ds,r2_ix_45(&ds,a2,a1),/*IC*/(T2)(INT8_C(1)))),"substring_count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7copy(se_dump_stack*caller,T7* C,T0* a1){
T2 _c=0;
void**locals[2];
static se_frame_descriptor fd={"copy"" STRING",1,2,"%R7%other%R7%c%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E47904/*l1145c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_c;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x01A05D08/*l93c4/any.e*/;
ac_req(r7same_dynamic_type(&ds,C,a1),"same_dynamic_type(other)");
ds.p=0x01A05D08/*l93c4/any.e*/;
ac_req(r7same_dynamic_type(&ds,C,a1),"same_dynamic_type(other)");
fd.assertion_flag=1;
}
ds.p=0x00E48008/*l1152c4/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E48012/*l1152c9/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E48012/*l1152c9/string.e*/);
}
_c=r7count(&ds,se_i7(&ds,((T7*)(((T7*)a1)))));
ds.p=0x00E48112/*l1153c9/string.e*/;
if(r2_ix_62(&ds,_c,/*IC*/(T2)(INT8_C(0)))){
ds.p=0x00E48222/*l1154c17/string.e*/;
if(r2_ix_60(&ds,(/*RF2*/(C)->_capacity/*i3p*/),_c)){
ds.p=0x00E4830C/*l1155c6/string.e*/;
/*SFN*/(C->_storage/*i3p*/)=r9calloc(&ds,(/*RF2*/(C)->_storage/*i3p*/),_c);
ds.p=0x00E4840C/*l1156c6/string.e*/;
/*SFN*/(C->_capacity/*i3p*/)=_c;
}
ds.p=0x00E4861A/*l1158c13/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E4862E/*l1158c23/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E4862E/*l1158c23/string.e*/);
}
ds.p=0x00E48650/*l1158c40/string.e*/;
r9copy_from(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(se_i7(&ds,((T7*)(((T7*)a1)))))->_storage/*i3p*/),r2_ix_45(&ds,_c,/*IC*/(T2)(INT8_C(1))));
}
ds.p=0x00E48808/*l1160c4/string.e*/;
/*SFN*/(C->_count/*i3p*/)=_c;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E48A08/*l1162c4/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E48A18/*l1162c12/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E48A18/*l1162c12/string.e*/);
}
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(r7count(&ds,se_i7(&ds,((T7*)(((T7*)a1)))))),"count = other.count");
ds.p=0x01A06008/*l96c4/any.e*/;
ac_ens(r7is_equal(&ds,C,a1),"is_equal(other)");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T0* r7default(se_dump_stack*caller,T7* C){
T0* R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"default"" STRING",1,1,"%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A07D12/*l125c9/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" STRING",1,2,"%R7%c%E3%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E53004/*l1328c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E53522/*l1333c17/string.e*/;
ac_req(r7valid_index(&ds,C,a2),"valid_index");
fd.assertion_flag=1;
}
ds.p=0x00E53718/*l1335c12/string.e*/;
r9put(&ds,(/*RF2*/(C)->_storage/*i3p*/),a1,r2_ix_45(&ds,a2,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E53908/*l1337c4/string.e*/;
ac_ens((r7item(&ds,C,a2))==(a1),"item(i) = c");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7out_in_tagged_out_memory(se_dump_stack*caller,T7* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
T2 tmp1;
T0* tmp2;
T0* tmp3;
T0* tmp4;
T2 tmp5;
T0* tmp6;
T0* tmp7;
/*INTERNAL_C_LOCAL list]*/
static se_frame_descriptor fd={"out_in_tagged_out_memory"" STRING",1,0,"%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E69604/*l1686c2/string.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
ds.p=0x01A0FD84/*l253c66/any.e*/;
if(((tmp0/*ddt1*/=(r7tagged_out_memory(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0FD60/*l253c48/any.e*/);
}
if((((tmp0/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0FD60/*l253c48/any.e*/);
}
tmp1/*old*/=r7count(&ds,((T7*)tmp0/*ddt1*/));
ds.p=0x01A0FE50/*l254c40/any.e*/;
if(((tmp2/*ddt1*/=(r7tagged_out_memory(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0FE2C/*l254c22/any.e*/);
}
if((((tmp2/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0FE2C/*l254c22/any.e*/);
}
tmp3/*old*/=r7twin(&ds,((T7*)tmp2/*ddt1*/));
ds.p=0x01A0FED8/*l254c108/any.e*/;
if(((tmp4/*ddt1*/=(r7tagged_out_memory(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0FEB4/*l254c90/any.e*/);
}
if((((tmp4/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0FEB4/*l254c90/any.e*/);
}
tmp5/*old*/=r7count(&ds,((T7*)tmp4/*ddt1*/));
ds.p=0x01A0FE50/*l254c40/any.e*/;
if((tmp2/*ddt1*/)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0FE2C/*l254c22/any.e*/);
}
if((((tmp2/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0FE2C/*l254c22/any.e*/);
}
tmp3/*old*/=r7twin(&ds,((T7*)tmp2/*ddt1*/));
ds.p=0x00E6982C/*l1688c22/string.e*/;
if(((tmp6/*ddt1*/=(r7tagged_out_memory(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x00E69808/*l1688c4/string.e*/);
}
if((((tmp6/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E69808/*l1688c4/string.e*/);
}
r7append(&ds,((T7*)tmp6/*ddt1*/),(T0*)C);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x01A0FD52/*l253c41/any.e*/;
if((/*auto-unlock tmp6*/(tmp6/*ddt1*/=(r7tagged_out_memory(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0FD22/*l253c17/any.e*/);
}
if((((tmp6/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0FD22/*l253c17/any.e*/);
}
ac_ens(r2_ix_6261(&ds,r7count(&ds,((T7*)tmp6/*ddt1*/)),tmp1/*old*/),"not_cleared");
ds.p=0x01A0FE5C/*l254c46/any.e*/;
if((tmp3/*old*/)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0FE24/*l254c18/any.e*/);
}
if((((tmp3/*old*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0FE24/*l254c18/any.e*/);
}
ds.p=0x01A0FE92/*l254c73/any.e*/;
if(((tmp7/*ddt1*/=(r7tagged_out_memory(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0FE6E/*l254c55/any.e*/);
}
if((((tmp7/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0FE6E/*l254c55/any.e*/);
}
ds.p=0x01A0FEA6/*l254c83/any.e*/;
ac_ens(r7is_equal(&ds,se_i7(&ds,((T7*)(((T7*)tmp3/*old*/)))),r7substring(&ds,((T7*)tmp7/*ddt1*/),/*IC*/(T2)(INT8_C(1)),tmp5/*old*/)),"append_only");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7append(se_dump_stack*caller,T7* C,T0* a1){
T2 _s_count=0;
T2 _needed_capacity=0;
void**locals[3];
static se_frame_descriptor fd={"append"" STRING",1,3,"%R7%s%R7%s_count%E2%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E4B304/*l1203c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_s_count;
locals[2]=(void**)&_needed_capacity;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E4B820/*l1208c16/string.e*/;
ac_req((a1)!=((void*)((void*)0)),"s_not_void");
fd.assertion_flag=1;
}
ds.p=0x00E4C008/*l1216c4/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E4C01E/*l1216c15/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E4C01E/*l1216c15/string.e*/);
}
_s_count=r7count(&ds,se_i7(&ds,((T7*)(((T7*)a1)))));
ds.p=0x00E4C108/*l1217c4/string.e*/;
_needed_capacity=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),_s_count);
ds.p=0x00E4C22E/*l1218c23/string.e*/;
if(r2_ix_62(&ds,_needed_capacity,(/*RF2*/(C)->_capacity/*i3p*/))){
ds.p=0x00E4C30A/*l1219c5/string.e*/;
r7ensure_capacity(&ds,C,_needed_capacity);
}
ds.p=0x00E4C518/*l1221c12/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E4C536/*l1221c27/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E4C536/*l1221c27/string.e*/);
}
ds.p=0x00E4C54C/*l1221c38/string.e*/;
r9copy_at(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(C)->_count/*i3p*/),(/*RF2*/(se_i7(&ds,((T7*)(((T7*)a1)))))->_storage/*i3p*/),_s_count);
ds.p=0x00E4C608/*l1222c4/string.e*/;
/*SFN*/(C->_count/*i3p*/)=_needed_capacity;
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T0* r7twin(se_dump_stack*caller,T7* C){
T0* R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"twin"" STRING",1,1,"%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A04F12/*l79c9/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=(void*)new7();
r7copy(&ds,((T7*)R),((T0*)C));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x01A05524/*l85c18/any.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A05516/*l85c11/any.e*/);
}
if((((R)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A05516/*l85c11/any.e*/);
}
ac_ens(r7is_equal(&ds,se_i7(&ds,((T7*)(((T7*)R)))),(T0*)C),"equal");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/
T0*oBC13tagged_out_memory=(void*)0;
int fBC13tagged_out_memory=0;

/*STRING*/T0* r7tagged_out_memory(se_dump_stack*caller,T7* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"tagged_out_memory"" STRING",1,1,"%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A10112/*l257c9/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC13tagged_out_memory;
set_dump_stack_top(&ds);/*link*/
if(fBC13tagged_out_memory==0){fBC13tagged_out_memory=1;{
ds.p=0x01A1032E/*l259c23/any.e*/;
tmp0/*new*/=((T0*)(new7()));
r7make(&ds,((T7*)tmp0/*new*/),/*IC*/(T2)(INT16_C(1024)));
oBC13tagged_out_memory=tmp0/*new*/;
/*tmp0.unlock*/
se_i7(&ds,((T7*)(oBC13tagged_out_memory)));}
fBC13tagged_out_memory=2;}
else{
ac_req(fBC13tagged_out_memory==2, "Recursive once function.");
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return oBC13tagged_out_memory;
}/*--*/

/*STRING*/void r7set_count(se_dump_stack*caller,T7* C,T2 a1){
void**locals[1];
static se_frame_descriptor fd={"set_count"" STRING",1,1,"%R7%new_count%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E88F04/*l2191c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E8911C/*l2193c14/string.e*/;
ac_req(r2_ix_6061(&ds,a1,(/*RF2*/(C)->_capacity/*i3p*/)),"new_count <= capacity");
fd.assertion_flag=1;
}
ds.p=0x00E89308/*l2195c4/string.e*/;
/*SFN*/(C->_count/*i3p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E89508/*l2197c4/string.e*/;
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(a1),"count = new_count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7print_on(se_dump_stack*caller,T7* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"print_on"" STRING",1,1,"%R7%file%R29%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A0CE04/*l206c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x01A0D412/*l212c9/any.e*/;
if((/*no_dispatch.e*/a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0D408/*l212c4/any.e*/);
}
if((((/*no_dispatch.e*/a1)->id))!=(INT8_C(51))){
error1("Bad target type. The expected type is STD_OUTPUT.",0x01A0D408/*l212c4/any.e*/);
}
ac_req(/*RF1is_connected*/1,"file.is_connected");
ds.p=0x01A0D412/*l212c9/any.e*/;
if((/*no_dispatch.e*/a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0D408/*l212c4/any.e*/);
}
if((((/*no_dispatch.e*/a1)->id))!=(INT8_C(51))){
error1("Bad target type. The expected type is STD_OUTPUT.",0x01A0D408/*l212c4/any.e*/);
}
ac_req(/*RF1is_connected*/1,"file.is_connected");
fd.assertion_flag=1;
}
ds.p=0x01A0D62C/*l214c22/any.e*/;
if(((tmp0/*ddt1*/=(r7tagged_out_memory(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0D608/*l214c4/any.e*/);
}
if((((tmp0/*ddt1*/)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x01A0D608/*l214c4/any.e*/);
}
r7clear_count(&ds,((T7*)tmp0/*ddt1*/));
ds.p=0x01A0D708/*l215c4/any.e*/;
r7out_in_tagged_out_memory(&ds,C);
ds.p=0x01A0D812/*l216c9/any.e*/;
if((/*no_dispatch.e*/a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x01A0D808/*l216c4/any.e*/);
}
if((((/*no_dispatch.e*/a1)->id))!=(INT8_C(51))){
error1("Bad target type. The expected type is STD_OUTPUT.",0x01A0D808/*l216c4/any.e*/);
}
ds.p=0x01A0D828/*l216c20/any.e*/;
r51put_string(&ds,((T51*)/*no_dispatch.e*/a1),r7tagged_out_memory(&ds,C));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T6 r7same_dynamic_type(se_dump_stack*caller,T7* C,T0* a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"same_dynamic_type"" STRING",1,2,"%R7%other%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A02B12/*l43c9/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x01A02E08/*l46c4/any.e*/;
ac_req((a1)!=((void*)((void*)0)),"other /= Void");
ds.p=0x01A02E08/*l46c4/any.e*/;
ac_req((a1)!=((void*)((void*)0)),"other /= Void");
fd.assertion_flag=1;
}
R=/* same_dynamic_type */
(((vc(((T0*)(C)),0))->id)==((vc(((T0*)(a1)),0))->id));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7clear_count(se_dump_stack*caller,T7* C){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
/*INTERNAL_C_LOCAL list]*/
static se_frame_descriptor fd={"clear_count"" STRING",1,0,"%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E45B04/*l1115c2/string.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
ds.p=0x00E46526/*l1125c19/string.e*/;
tmp0/*old*/=(/*RF2*/(C)->_capacity/*i3p*/);
ds.p=0x00E46208/*l1122c4/string.e*/;
/*SFN*/(C->_count/*i3p*/)=/*IC*/(T2)(INT8_C(0));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E4641C/*l1124c14/string.e*/;
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(INT8_C(0)),"is_empty");
ds.p=0x00E46508/*l1125c4/string.e*/;
ac_ens(((/*RF2*/(C)->_capacity/*i3p*/))==(tmp0/*old*/),"capacity = old capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T6 r7_ix_60(se_dump_stack*caller,T7* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
T6 tmp1;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T2 _maxi=0;
void**locals[4];
static se_frame_descriptor fd={"infix ""<"" (""infix ""<"" STRING)",1,4,"%R7%other%R7%Result%E6%i%E2%maxi%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E09804/*l152c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_maxi;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04C01B24/*l27c18/comparable.e*/;
ac_req((a1)!=((void*)((void*)0)),"other_exists");
fd.assertion_flag=1;
}
ds.p=0x00E0A00A/*l160c5/string.e*/;
_i=/*IC*/(T2)(INT8_C(1));
ds.p=0x00E0A10A/*l161c5/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E0A12E/*l161c23/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E0A12E/*l161c23/string.e*/);
}
_maxi=r2min(&ds,(/*RF2*/(C)->_count/*i3p*/),r7count(&ds,se_i7(&ds,((T7*)(((T7*)a1))))));
while(1){
ds.p=0x00E0A30E/*l163c7/string.e*/;
tmp0/*or else*/=((T6)(r2_ix_62(&ds,_i,_maxi)));
if(tmp0/*or else*/){
}
else{
ds.p=0x00E0A32C/*l163c22/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E0A342/*l163c33/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E0A342/*l163c33/string.e*/);
}
ds.p=0x00E0A358/*l163c44/string.e*/;
tmp0/*or else*/=((T6)((r7item(&ds,C,_i))!=(r7item(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),_i))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x00E0A50A/*l165c5/string.e*/;
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
ds.p=0x00E0A712/*l167c9/string.e*/;
if(r2_ix_6061(&ds,_i,_maxi)){
ds.p=0x00E0A80A/*l168c5/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E0A832/*l168c25/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E0A832/*l168c25/string.e*/);
}
ds.p=0x00E0A848/*l168c36/string.e*/;
R=((T6)(r3_ix_60(&ds,r7item(&ds,C,_i),r7item(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),_i))));
}
else{
ds.p=0x00E0AA0A/*l170c5/string.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x00E0AA28/*l170c20/string.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x00E0AA28/*l170c20/string.e*/);
}
R=((T6)(r2_ix_6061(&ds,_i,r7count(&ds,se_i7(&ds,((T7*)(((T7*)a1))))))));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04C01E20/*l30c16/comparable.e*/;
tmp1/*implies*/=((T6)(R));
if(tmp1/*implies*/){
ds.p=0x04C01E3E/*l30c31/comparable.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x04C01E48/*l30c36/comparable.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x04C01E48/*l30c36/comparable.e*/);
}
tmp1/*implies*/=((T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),(T0*)C)))));
}
else{
tmp1/*implies*/=((T6)(1));
}
ac_ens(tmp1/*implies*/,"asymmetric");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T2 r7hash_code(se_dump_stack*caller,T7* C){
T2 R=0;
T2 _i=0;
T2 _j=0;
void**locals[3];
static se_frame_descriptor fd={"hash_code"" STRING",1,3,"%R7%Result%E2%i%E2%j%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E08504/*l133c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
locals[1]=(void**)&_i;
locals[2]=(void**)&_j;
set_dump_stack_top(&ds);/*link*/
ds.p=0x00E08A0A/*l138c5/string.e*/;
_j=(/*RF2*/(C)->_count/*i3p*/);
ds.p=0x00E08B0A/*l139c5/string.e*/;
_i=/*IC*/(T2)(INT8_C(1));
while(1){
ds.p=0x00E08D0E/*l141c7/string.e*/;
if(r2_ix_6061(&ds,_j,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x00E08F0A/*l143c5/string.e*/;
R=(int32_t)(((uint32_t)((int32_t)(((uint32_t)(/*{INTEGER_32 5}*/INT32_C(5)))*((uint32_t)(R)))))+((uint32_t)(/*IC*/(T2)(r3code(&ds,r7item(&ds,C,_i))))));
ds.p=0x00E0900A/*l144c5/string.e*/;
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
ds.p=0x00E0910A/*l145c5/string.e*/;
_j=r2_ix_45(&ds,_j,/*IC*/(T2)(INT8_C(1)));
}
ds.p=0x00E0931C/*l147c14/string.e*/;
if(r2_ix_60(&ds,R,/*IC*/(T2)(INT8_C(0)))){
ds.p=0x00E0940A/*l148c5/string.e*/;
R=~(R);
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04E01638/*l22c28/hashable.e*/;
ac_ens(r2_ix_6261(&ds,R,/*IC*/(T2)(INT8_C(0))),"good_hash_value");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7make(se_dump_stack*caller,T7* C,T2 a1){
void**locals[1];
static se_frame_descriptor fd={"make"" STRING",1,1,"%R7%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E04404/*l68c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E0474E/*l71c39/string.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"non_negative_size");
fd.assertion_flag=1;
}
ds.p=0x00E0492E/*l73c23/string.e*/;
if(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0)))){
ds.p=0x00E04A22/*l74c17/string.e*/;
if(r2_ix_60(&ds,(/*RF2*/(C)->_capacity/*i3p*/),a1)){
ds.p=0x00E04B0C/*l75c6/string.e*/;
/*SFN*/(C->_storage/*i3p*/)=r9calloc(&ds,(/*RF2*/(C)->_storage/*i3p*/),a1);
ds.p=0x00E04C0C/*l76c6/string.e*/;
/*SFN*/(C->_capacity/*i3p*/)=a1;
}
}
ds.p=0x00E04F08/*l79c4/string.e*/;
/*SFN*/(C->_count/*i3p*/)=/*IC*/(T2)(INT8_C(0));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E05128/*l81c20/string.e*/;
ac_ens(r2_ix_6061(&ds,a1,(/*RF2*/(C)->_capacity/*i3p*/)),"needed_capacity <= capacity");
ds.p=0x00E05224/*l82c18/string.e*/;
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(INT8_C(0)),"empty_string");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7add_last(se_dump_stack*caller,T7* C,T3 a1){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"add_last"" STRING",1,1,"%R7%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E59A04/*l1434c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x00E5A528/*l1445c20/string.e*/;
tmp0/*old*/=(/*RF2*/(C)->_count/*i3p*/);
ds.p=0x00E59F0E/*l1439c7/string.e*/;
if(((/*RF2*/(C)->_count/*i3p*/))==((/*RF2*/(C)->_capacity/*i3p*/))){
ds.p=0x00E5A00A/*l1440c5/string.e*/;
r7ensure_capacity(&ds,C,r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1))));
}
ds.p=0x00E5A218/*l1442c12/string.e*/;
r9put(&ds,(/*RF2*/(C)->_storage/*i3p*/),a1,(/*RF2*/(C)->_count/*i3p*/));
ds.p=0x00E5A308/*l1443c4/string.e*/;
/*SFN*/(C->_count/*i3p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E5A508/*l1445c4/string.e*/;
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),tmp0/*old*/)),"count = 1 + old count");
ds.p=0x00E5A608/*l1446c4/string.e*/;
ac_ens((r7item(&ds,C,(/*RF2*/(C)->_count/*i3p*/)))==(a1),"item(count) = c");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7ensure_capacity(se_dump_stack*caller,T7* C,T2 a1){
T2 _new_capacity=0;
void**locals[2];
static se_frame_descriptor fd={"ensure_capacity"" STRING",1,2,"%R7%needed_capacity%E2%new_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E89804/*l2200c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E89A28/*l2202c20/string.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"needed_capacity >= 0");
fd.assertion_flag=1;
}
ds.p=0x00E89E1E/*l2206c15/string.e*/;
if(r9is_null(&ds,(/*RF2*/(C)->_storage/*i3p*/))){
ds.p=0x00E89F0A/*l2207c5/string.e*/;
_new_capacity=r2max(&ds,a1,/*IC*/(T2)(INT8_C(32)));
ds.p=0x00E8A00A/*l2208c5/string.e*/;
/*SFN*/(C->_storage/*i3p*/)=r9calloc(&ds,(/*RF2*/(C)->_storage/*i3p*/),_new_capacity);
ds.p=0x00E8A10A/*l2209c5/string.e*/;
/*SFN*/(C->_capacity/*i3p*/)=_new_capacity;
}
else{
ds.p=0x00E8A228/*l2210c20/string.e*/;
if(r2_ix_60(&ds,(/*RF2*/(C)->_capacity/*i3p*/),a1)){
ds.p=0x00E8A30A/*l2211c5/string.e*/;
_new_capacity=r2max(&ds,a1,(int32_t)(((uint32_t)((/*RF2*/(C)->_capacity/*i3p*/)))*((uint32_t)(/*IC*/(T2)(INT8_C(2))))));
ds.p=0x00E8A40A/*l2212c5/string.e*/;
/*SFN*/(C->_storage/*i3p*/)=r9realloc(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(C)->_capacity/*i3p*/),_new_capacity);
ds.p=0x00E8A50A/*l2213c5/string.e*/;
/*SFN*/(C->_capacity/*i3p*/)=_new_capacity;
}
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E8A81A/*l2216c13/string.e*/;
ac_ens(r2_ix_6261(&ds,(/*RF2*/(C)->_capacity/*i3p*/),a1),"capacity >= needed_capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7from_external_copy(se_dump_stack*caller,T7* C,T8 a1){
T9 _s=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"from_external_copy"" STRING",1,3,"%R7%p%E8%s%E9%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E82704/*l2087c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_s;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E82E0C/*l2094c6/string.e*/;
ac_req((NULL!=a1),"p.is_not_null");
fd.assertion_flag=1;
}
ds.p=0x00E8330A/*l2099c5/string.e*/;
_s=a1;
ds.p=0x00E8340A/*l2100c5/string.e*/;
/*SFN*/(C->_count/*i3p*/)=/*IC*/(T2)(INT8_C(0));
while(1){
ds.p=0x00E8360E/*l2102c7/string.e*/;
if((r9item(&ds,_s,_i))==(((T3)'\000'))){
break;
}
ds.p=0x00E8380A/*l2104c5/string.e*/;
r7add_last(&ds,C,r9item(&ds,_s,_i));
ds.p=0x00E8390A/*l2105c5/string.e*/;
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T8 r7to_external(se_dump_stack*caller,T7* C){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
/*INTERNAL_C_LOCAL list]*/
T8 R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"to_external"" STRING",1,1,"%R7%Result%E8%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E7FA04/*l2042c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x00E80B20/*l2059c16/string.e*/;
tmp0/*old*/=(/*RF2*/(C)->_count/*i3p*/);
ds.p=0x00E80020/*l2048c16/string.e*/;
if(r2_ix_62(&ds,(/*RF2*/(C)->_capacity/*i3p*/),(/*RF2*/(C)->_count/*i3p*/))){
ds.p=0x00E8010A/*l2049c5/string.e*/;
/*SFN*/(C->_count/*i3p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)));
ds.p=0x00E80210/*l2050c8/string.e*/;
if((r7item(&ds,C,(/*RF2*/(C)->_count/*i3p*/)))!=(((T3)'\000'))){
ds.p=0x00E8030C/*l2051c6/string.e*/;
r7put(&ds,C,((T3)'\000'),(/*RF2*/(C)->_count/*i3p*/));
}
}
else{
ds.p=0x00E8060A/*l2054c5/string.e*/;
r7add_last(&ds,C,((T3)'\000'));
}
ds.p=0x00E80808/*l2056c4/string.e*/;
/*SFN*/(C->_count/*i3p*/)=r2_ix_45(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)));
ds.p=0x00E80908/*l2057c4/string.e*/;
R=((void*)((/*RF2*/(C)->_storage/*i3p*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E80B08/*l2059c4/string.e*/;
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(tmp0/*old*/),"count = old count");
ds.p=0x00E80C16/*l2060c11/string.e*/;
ac_ens((NULL!=R),"Result.is_not_null");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T2 r7count(se_dump_stack*caller,T7* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count"" STRING",1,1,"%R7%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E02A04/*l42c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=C->_count/*i3p*/;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04803620/*l54c16/traversable.e*/;
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,r7upper(&ds,C),/*RF1lower*/INT32_C(1)),/*IC*/(T2)(INT8_C(1)))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T2 r7upper(se_dump_stack*caller,T7* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"upper"" STRING",1,1,"%R7%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E03804/*l56c2/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x00E03E08/*l62c4/string.e*/;
R=(/*RF2*/(C)->_count/*i3p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x00E04008/*l64c4/string.e*/;
ac_ens((R)==((/*RF2*/(C)->_count/*i3p*/)),"Result = count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/
se_frame_descriptor se_ifd7={"invariant STRING",1,0,"%R7%",1};

T7*se_i7(se_dump_stack*caller,T7*C){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
se_dump_stack ds;
ds.fd=&se_ifd7;
ds.current=((void*)&C);
ds.p=0x00E8C902/*l2249c1/string.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
ds.p=0x00E8CA08/*l2250c4/string.e*/;
ac_inv(r2_ix_6061(&ds,/*IC*/(T2)(INT8_C(0)),(/*RF2*/(C)->_count/*i3p*/)),"0 <= count");
ds.p=0x00E8CB10/*l2251c8/string.e*/;
ac_inv(r2_ix_6061(&ds,(/*RF2*/(C)->_count/*i3p*/),(/*RF2*/(C)->_capacity/*i3p*/)),"count <= capacity");
ds.p=0x00E8CC16/*l2252c11/string.e*/;
tmp0/*implies*/=((T6)(r2_ix_62(&ds,(/*RF2*/(C)->_capacity/*i3p*/),/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*implies*/){
ds.p=0x00E8CC3E/*l2252c31/string.e*/;
tmp0/*implies*/=((T6)(r9is_not_null(&ds,(/*RF2*/(C)->_storage/*i3p*/))));
}
else{
tmp0/*implies*/=((T6)(1));
}
ac_inv(tmp0/*implies*/,"capacity > 0 implies storage.is_not_null");
ds.fd->assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return C;
}/*--*/
T0*ms13_14150;
T0*ms25_1367916000;
T0*ms25_1097781507;

T0*se_ms(int c,char*e){
/* Allocate a Manifest STRING.*/
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

T0*se_string(char*e){
/* Allocate an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

void se_msi1(void){
ms13_14150=se_ms(4,s13_14150);
ms25_1367916000=se_ms(19,s25_1367916000);
ms25_1097781507=se_ms(16,s25_1097781507);
}/*--*/

void manifest_string_mark1(void){
gc_mark7((T7*)ms13_14150);
gc_mark7((T7*)ms25_1367916000);
gc_mark7((T7*)ms25_1097781507);
}/*--*/

void once_function_mark(void){
/*NON_VOID_NO_DISPATCH:*/
/*Ordinary once functions:*/
if(NULL!=oBC13tagged_out_memory)gc_mark7((T7*)(oBC13tagged_out_memory));
if(NULL!=oBC26command_arguments)gc_mark179((T179*)(oBC26command_arguments));
if(NULL!=oBC13std_output)gc_mark51((T51*)(oBC13std_output));
if(NULL!=oBC66cache)gc_mark98((T98*)(oBC66cache));
if(NULL!=oBC99singleton_memory_pool)gc_mark182((T182*)(oBC99singleton_memory_pool));
if(NULL!=oBC122common_free_nodes)gc_mark188((T188*)(oBC122common_free_nodes));
}/*--*/

void gc_start(void){
if(gc_is_off)return;
if(garbage_delayed())return;
handle(SE_HANDLE_ENTER_GC,NULL);
gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);
((gc25*)eiffel_root_object)->header.flag=FSOH_UNMARKED;
if(na_env194.store_left>0){
na_env194.store->header.size=na_env194.store_left;
na_env194.store->header.magic_flag=RSOH_FREE;
na_env194.store_left=0;
}
na_env194.chunk_list=NULL;
na_env194.store_chunk=NULL;
gc_free193=(void*)0;
gc_free192=(void*)0;
if(na_env191.store_left>0){
na_env191.store->header.size=na_env191.store_left;
na_env191.store->header.magic_flag=RSOH_FREE;
na_env191.store_left=0;
}
na_env191.chunk_list=NULL;
na_env191.store_chunk=NULL;
gc_free190=(void*)0;
gc_free189=(void*)0;
gc_free188=(void*)0;
gc_free187=(void*)0;
gc_free184=(void*)0;
if(na_env183.store_left>0){
na_env183.store->header.size=na_env183.store_left;
na_env183.store->header.magic_flag=RSOH_FREE;
na_env183.store_left=0;
}
na_env183.chunk_list=NULL;
na_env183.store_chunk=NULL;
gc_free182=(void*)0;
gc_free181=(void*)0;
if(na_env180.store_left>0){
na_env180.store->header.size=na_env180.store_left;
na_env180.store->header.magic_flag=RSOH_FREE;
na_env180.store_left=0;
}
na_env180.chunk_list=NULL;
na_env180.store_chunk=NULL;
gc_free98=(void*)0;
gc_free179=(void*)0;
gc_free51=(void*)0;
gc_free67=(void*)0;
gc_free59=(void*)0;
gc_free25=(void*)0;
if(na_env9.store_left>0){
na_env9.store->header.size=na_env9.store_left;
na_env9.store->header.magic_flag=RSOH_FREE;
na_env9.store_left=0;
}
na_env9.chunk_list=NULL;
na_env9.store_chunk=NULL;
gc_free7=(void*)0;
gc_mark25(eiffel_root_object);
manifest_string_mark1();
once_function_mark();
{int i=SE_MAXID-1;
while(i>=0){
if(g[i]!=NULL)gc_mark7(g[i]);
i--;}
}
{int i=SE_MAXID-1;
while(i>=0){
if(t[i]!=NULL)gc_mark7(t[i]);
i--;}
}
mark_stack_and_registers();
gc_sweep();
collector_counter++;
handle(SE_HANDLE_EXIT_GC,NULL);
}/*--*/
na_env na_env194={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark194};
gc193*store193=(void*)0;
int store_left193=0;
fsoc*store_chunk193=(void*)0;
gc193*gc_free193=(void*)0;
gc192*store192=(void*)0;
int store_left192=0;
fsoc*store_chunk192=(void*)0;
gc192*gc_free192=(void*)0;
na_env na_env191={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark191};
gc190*store190=(void*)0;
int store_left190=0;
fsoc*store_chunk190=(void*)0;
gc190*gc_free190=(void*)0;
gc189*store189=(void*)0;
int store_left189=0;
fsoc*store_chunk189=(void*)0;
gc189*gc_free189=(void*)0;
gc188*store188=(void*)0;
int store_left188=0;
fsoc*store_chunk188=(void*)0;
gc188*gc_free188=(void*)0;
gc187*store187=(void*)0;
int store_left187=0;
fsoc*store_chunk187=(void*)0;
gc187*gc_free187=(void*)0;
gc184*store184=(void*)0;
int store_left184=0;
fsoc*store_chunk184=(void*)0;
gc184*gc_free184=(void*)0;
na_env na_env183={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark183};
gc182*store182=(void*)0;
int store_left182=0;
fsoc*store_chunk182=(void*)0;
gc182*gc_free182=(void*)0;
gc181*store181=(void*)0;
int store_left181=0;
fsoc*store_chunk181=(void*)0;
gc181*gc_free181=(void*)0;
na_env na_env180={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark180};
gc98*store98=(void*)0;
int store_left98=0;
fsoc*store_chunk98=(void*)0;
gc98*gc_free98=(void*)0;
gc179*store179=(void*)0;
int store_left179=0;
fsoc*store_chunk179=(void*)0;
gc179*gc_free179=(void*)0;
gc51*store51=(void*)0;
int store_left51=0;
fsoc*store_chunk51=(void*)0;
gc51*gc_free51=(void*)0;
gc67*store67=(void*)0;
int store_left67=0;
fsoc*store_chunk67=(void*)0;
gc67*gc_free67=(void*)0;
gc59*store59=(void*)0;
int store_left59=0;
fsoc*store_chunk59=(void*)0;
gc59*gc_free59=(void*)0;
gc25*store25=(void*)0;
int store_left25=0;
fsoc*store_chunk25=(void*)0;
gc25*gc_free25=(void*)0;
na_env na_env9={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark9};
gc7*store7=(void*)0;
int store_left7=0;
fsoc*store_chunk7=(void*)0;
gc7*gc_free7=(void*)0;

void gc_mark194(T194 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark190((T190*)(e));
}}}}
}/*--*/

T194 new194(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env194.store_left)){
rsoh*r=na_env194.store;
na_env194.store_left-=size;
if(na_env194.store_left>sizeof(rsoh)){
r->header.size=size;
na_env194.store=((rsoh*)(((char*)(na_env194.store))+size));
}
else {
r->header.size=size+na_env194.store_left;
na_env194.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T194)(r+1));
}
return((T194)new_na(&na_env194,size));
}/*--*/

void gc_sweep193(fsoc*c){
gc193*o1,*o2;
o1=((gc193*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store193;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item193(&(o1->object));
}
else{
o1->header.next=gc_free193;
gc_free193=o1;
}
}
}
else{
int dead=1;
gc193* old_gc_free = gc_free193;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item193(&(o1->object));
dead=0;}
else{
o1->header.next=gc_free193;
gc_free193=o1;
}
}
if (dead){
gc_free193 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_update_weak_ref_item193(T193* wr){
gc192* obj_ptr = (gc192*)(wr->_item);
if (obj_ptr != NULL){
int swept = (((void*)obj_ptr) <= ((void*)wr));
if (swept != (obj_ptr->header.flag == FSOH_UNMARKED))
/* (already swept) xor marked */
wr->_item = NULL;
}
}/*--*/

void gc_mark193(T193*o){
se_gc_check_id(o,193);
{
((gc193*)o)->header.flag=FSOH_MARKED;
}
}/*--*/

void gc_align_mark193(fsoc*c,gc193*p){
gc193*b=((gc193*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store193)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T193*o=(&(p->object));
((gc193*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H193={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark193,
(void(*)(mch*))gc_sweep193},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc193))-1)};

T193*new193(void){
gc193*n;
fsoc*c;
if(store_left193>1){
store_left193--;
n=store193++;
}
else if(gc_free193!=NULL){
n=gc_free193;
gc_free193=n->header.next;
}
else if(store_left193==1){
store_left193=0;
store_chunk193->header.state_type=FSO_USED_CHUNK;
n=store193++;
}
else{
c=gc_fsoc_get1();
if(gc_free193!=NULL){
n=gc_free193;
gc_free193=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk193=c;
*store_chunk193=H193;
store193=((gc193*)(&(store_chunk193->first_object)));
store_left193=H193.count_minus_one;
n=store193++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M193;
return((T193*)n);
}/*--*/

void gc_sweep192(fsoc*c){
gc192*o1,*o2;
o1=((gc192*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store192;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free192;
gc_free192=o1;
}
}
}
else{
int dead=1;
gc192* old_gc_free = gc_free192;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free192;
gc_free192=o1;
}
}
if (dead){
gc_free192 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark192(T192*o){
se_gc_check_id(o,192);
{
begin:
if(((gc192*)o)->header.flag==FSOH_UNMARKED){
((gc192*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_key)gc_mark7((T7*)(o->_key));
o=(void*)o->_next;
if((o!=NULL))goto begin;
}
}
}/*--*/

void gc_align_mark192(fsoc*c,gc192*p){
gc192*b=((gc192*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store192)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T192*o=(&(p->object));
begin:
((gc192*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_key)gc_mark7((T7*)(o->_key));
o=(void*)o->_next;
if((o!=NULL)&&(((gc192*)o)->header.flag==FSOH_UNMARKED))goto begin;
}
}
}/*--*/
fsoc H192={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark192,
(void(*)(mch*))gc_sweep192},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc192))-1)};

T192*new192(void){
gc192*n;
fsoc*c;
if(store_left192>1){
store_left192--;
n=store192++;
}
else if(gc_free192!=NULL){
n=gc_free192;
gc_free192=n->header.next;
}
else if(store_left192==1){
store_left192=0;
store_chunk192->header.state_type=FSO_USED_CHUNK;
n=store192++;
}
else{
c=gc_fsoc_get1();
if(gc_free192!=NULL){
n=gc_free192;
gc_free192=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk192=c;
*store_chunk192=H192;
store192=((gc192*)(&(store_chunk192->first_object)));
store_left192=H192.count_minus_one;
n=store192++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M192;
return((T192*)n);
}/*--*/

void gc_mark191(T191 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark192((T192*)(e));
}}}}
}/*--*/

T191 new191(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env191.store_left)){
rsoh*r=na_env191.store;
na_env191.store_left-=size;
if(na_env191.store_left>sizeof(rsoh)){
r->header.size=size;
na_env191.store=((rsoh*)(((char*)(na_env191.store))+size));
}
else {
r->header.size=size+na_env191.store_left;
na_env191.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T191)(r+1));
}
return((T191)new_na(&na_env191,size));
}/*--*/

void gc_sweep190(fsoc*c){
gc190*o1,*o2;
o1=((gc190*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store190;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free190;
gc_free190=o1;
}
}
}
else{
int dead=1;
gc190* old_gc_free = gc_free190;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free190;
gc_free190=o1;
}
}
if (dead){
gc_free190 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark190(T190*o){
se_gc_check_id(o,190);
{
begin:
if(((gc190*)o)->header.flag==FSOH_UNMARKED){
((gc190*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_key)gc_mark7((T7*)(o->_key));
/*i3p*/if(NULL!=o->_item)Xgc_mark186((T0*)(o->_item));
o=(void*)o->_next;
if((o!=NULL))goto begin;
}
}
}/*--*/

void gc_align_mark190(fsoc*c,gc190*p){
gc190*b=((gc190*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store190)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T190*o=(&(p->object));
begin:
((gc190*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_key)gc_mark7((T7*)(o->_key));
/*i3p*/if(NULL!=o->_item)Xgc_mark186((T0*)(o->_item));
o=(void*)o->_next;
if((o!=NULL)&&(((gc190*)o)->header.flag==FSOH_UNMARKED))goto begin;
}
}
}/*--*/
fsoc H190={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark190,
(void(*)(mch*))gc_sweep190},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc190))-1)};

T190*new190(void){
gc190*n;
fsoc*c;
if(store_left190>1){
store_left190--;
n=store190++;
}
else if(gc_free190!=NULL){
n=gc_free190;
gc_free190=n->header.next;
}
else if(store_left190==1){
store_left190=0;
store_chunk190->header.state_type=FSO_USED_CHUNK;
n=store190++;
}
else{
c=gc_fsoc_get1();
if(gc_free190!=NULL){
n=gc_free190;
gc_free190=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk190=c;
*store_chunk190=H190;
store190=((gc190*)(&(store_chunk190->first_object)));
store_left190=H190.count_minus_one;
n=store190++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M190;
return((T190*)n);
}/*--*/

void gc_sweep189(fsoc*c){
gc189*o1,*o2;
o1=((gc189*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store189;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item189(&(o1->object));
}
else{
o1->header.next=gc_free189;
gc_free189=o1;
}
}
}
else{
int dead=1;
gc189* old_gc_free = gc_free189;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item189(&(o1->object));
dead=0;}
else{
o1->header.next=gc_free189;
gc_free189=o1;
}
}
if (dead){
gc_free189 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_update_weak_ref_item189(T189* wr){
gc190* obj_ptr = (gc190*)(wr->_item);
if (obj_ptr != NULL){
int swept = (((void*)obj_ptr) <= ((void*)wr));
if (swept != (obj_ptr->header.flag == FSOH_UNMARKED))
/* (already swept) xor marked */
wr->_item = NULL;
}
}/*--*/

void gc_mark189(T189*o){
se_gc_check_id(o,189);
{
((gc189*)o)->header.flag=FSOH_MARKED;
}
}/*--*/

void gc_align_mark189(fsoc*c,gc189*p){
gc189*b=((gc189*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store189)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T189*o=(&(p->object));
((gc189*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H189={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark189,
(void(*)(mch*))gc_sweep189},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc189))-1)};

T189*new189(void){
gc189*n;
fsoc*c;
if(store_left189>1){
store_left189--;
n=store189++;
}
else if(gc_free189!=NULL){
n=gc_free189;
gc_free189=n->header.next;
}
else if(store_left189==1){
store_left189=0;
store_chunk189->header.state_type=FSO_USED_CHUNK;
n=store189++;
}
else{
c=gc_fsoc_get1();
if(gc_free189!=NULL){
n=gc_free189;
gc_free189=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk189=c;
*store_chunk189=H189;
store189=((gc189*)(&(store_chunk189->first_object)));
store_left189=H189.count_minus_one;
n=store189++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M189;
return((T189*)n);
}/*--*/

void gc_sweep188(fsoc*c){
gc188*o1,*o2;
o1=((gc188*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store188;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free188;
gc_free188=o1;
}
}
}
else{
int dead=1;
gc188* old_gc_free = gc_free188;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free188;
gc_free188=o1;
}
}
if (dead){
gc_free188 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark188(T188*o){
se_gc_check_id(o,188);
{
if(((gc188*)o)->header.flag==FSOH_UNMARKED){
((gc188*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_free_nodes)gc_mark189((T189*)(o->_free_nodes));
/*i7p*/if(NULL!=o->_cache_node)gc_mark190((T190*)(o->_cache_node));
/*i7p*/if(NULL!=o->_buckets)gc_mark194((o->_buckets));
}
}
}/*--*/

void gc_align_mark188(fsoc*c,gc188*p){
gc188*b=((gc188*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store188)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T188*o=(&(p->object));
((gc188*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_free_nodes)gc_mark189((T189*)(o->_free_nodes));
/*i7p*/if(NULL!=o->_cache_node)gc_mark190((T190*)(o->_cache_node));
/*i7p*/if(NULL!=o->_buckets)gc_mark194((o->_buckets));
}
}
}/*--*/
fsoc H188={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark188,
(void(*)(mch*))gc_sweep188},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc188))-1)};

T188*new188(void){
gc188*n;
fsoc*c;
if(store_left188>1){
store_left188--;
n=store188++;
}
else if(gc_free188!=NULL){
n=gc_free188;
gc_free188=n->header.next;
}
else if(store_left188==1){
store_left188=0;
store_chunk188->header.state_type=FSO_USED_CHUNK;
n=store188++;
}
else{
c=gc_fsoc_get1();
if(gc_free188!=NULL){
n=gc_free188;
gc_free188=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk188=c;
*store_chunk188=H188;
store188=((gc188*)(&(store_chunk188->first_object)));
store_left188=H188.count_minus_one;
n=store188++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M188;
return((T188*)n);
}/*--*/

void gc_sweep187(fsoc*c){
gc187*o1,*o2;
o1=((gc187*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store187;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item187(&(o1->object));
}
else{
o1->header.next=gc_free187;
gc_free187=o1;
}
}
}
else{
int dead=1;
gc187* old_gc_free = gc_free187;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
gc_update_weak_ref_item187(&(o1->object));
dead=0;}
else{
o1->header.next=gc_free187;
gc_free187=o1;
}
}
if (dead){
gc_free187 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_update_weak_ref_item187(T187* wr){
gc184* obj_ptr = (gc184*)(wr->_item);
if (obj_ptr != NULL){
int swept = (((void*)obj_ptr) <= ((void*)wr));
if (swept != (obj_ptr->header.flag == FSOH_UNMARKED))
/* (already swept) xor marked */
wr->_item = NULL;
}
}/*--*/

void gc_mark187(T187*o){
se_gc_check_id(o,187);
{
((gc187*)o)->header.flag=FSOH_MARKED;
}
}/*--*/

void gc_align_mark187(fsoc*c,gc187*p){
gc187*b=((gc187*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store187)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T187*o=(&(p->object));
((gc187*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H187={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark187,
(void(*)(mch*))gc_sweep187},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc187))-1)};

T187*new187(void){
gc187*n;
fsoc*c;
if(store_left187>1){
store_left187--;
n=store187++;
}
else if(gc_free187!=NULL){
n=gc_free187;
gc_free187=n->header.next;
}
else if(store_left187==1){
store_left187=0;
store_chunk187->header.state_type=FSO_USED_CHUNK;
n=store187++;
}
else{
c=gc_fsoc_get1();
if(gc_free187!=NULL){
n=gc_free187;
gc_free187=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk187=c;
*store_chunk187=H187;
store187=((gc187*)(&(store_chunk187->first_object)));
store_left187=H187.count_minus_one;
n=store187++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M187;
return((T187*)n);
}/*--*/

void gc_sweep184(fsoc*c){
gc184*o1,*o2;
o1=((gc184*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store184;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free184;
gc_free184=o1;
}
}
}
else{
int dead=1;
gc184* old_gc_free = gc_free184;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free184;
gc_free184=o1;
}
}
if (dead){
gc_free184 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark184(T184*o){
se_gc_check_id(o,184);
{
begin:
if(((gc184*)o)->header.flag==FSOH_UNMARKED){
((gc184*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_item)gc_mark67((T67*)(o->_item));
o=(void*)o->_next;
if((o!=NULL))goto begin;
}
}
}/*--*/

void gc_align_mark184(fsoc*c,gc184*p){
gc184*b=((gc184*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store184)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T184*o=(&(p->object));
begin:
((gc184*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_item)gc_mark67((T67*)(o->_item));
o=(void*)o->_next;
if((o!=NULL)&&(((gc184*)o)->header.flag==FSOH_UNMARKED))goto begin;
}
}
}/*--*/
fsoc H184={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark184,
(void(*)(mch*))gc_sweep184},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc184))-1)};

T184*new184(void){
gc184*n;
fsoc*c;
if(store_left184>1){
store_left184--;
n=store184++;
}
else if(gc_free184!=NULL){
n=gc_free184;
gc_free184=n->header.next;
}
else if(store_left184==1){
store_left184=0;
store_chunk184->header.state_type=FSO_USED_CHUNK;
n=store184++;
}
else{
c=gc_fsoc_get1();
if(gc_free184!=NULL){
n=gc_free184;
gc_free184=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk184=c;
*store_chunk184=H184;
store184=((gc184*)(&(store_chunk184->first_object)));
store_left184=H184.count_minus_one;
n=store184++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M184;
return((T184*)n);
}/*--*/

void gc_mark183(T183 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark184((T184*)(e));
}}}}
}/*--*/

T183 new183(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env183.store_left)){
rsoh*r=na_env183.store;
na_env183.store_left-=size;
if(na_env183.store_left>sizeof(rsoh)){
r->header.size=size;
na_env183.store=((rsoh*)(((char*)(na_env183.store))+size));
}
else {
r->header.size=size+na_env183.store_left;
na_env183.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T183)(r+1));
}
return((T183)new_na(&na_env183,size));
}/*--*/

void gc_sweep182(fsoc*c){
gc182*o1,*o2;
o1=((gc182*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store182;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free182;
gc_free182=o1;
}
}
}
else{
int dead=1;
gc182* old_gc_free = gc_free182;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free182;
gc_free182=o1;
}
}
if (dead){
gc_free182 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark182(T182*o){
se_gc_check_id(o,182);
{
if(((gc182*)o)->header.flag==FSOH_UNMARKED){
((gc182*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_free_nodes)gc_mark193((T193*)(o->_free_nodes));
/*i7p*/if(NULL!=o->_cache_node)gc_mark192((T192*)(o->_cache_node));
/*i7p*/if(NULL!=o->_buckets)gc_mark191((o->_buckets));
}
}
}/*--*/

void gc_align_mark182(fsoc*c,gc182*p){
gc182*b=((gc182*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store182)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T182*o=(&(p->object));
((gc182*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_free_nodes)gc_mark193((T193*)(o->_free_nodes));
/*i7p*/if(NULL!=o->_cache_node)gc_mark192((T192*)(o->_cache_node));
/*i7p*/if(NULL!=o->_buckets)gc_mark191((o->_buckets));
}
}
}/*--*/
fsoc H182={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark182,
(void(*)(mch*))gc_sweep182},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc182))-1)};

T182*new182(void){
gc182*n;
fsoc*c;
if(store_left182>1){
store_left182--;
n=store182++;
}
else if(gc_free182!=NULL){
n=gc_free182;
gc_free182=n->header.next;
}
else if(store_left182==1){
store_left182=0;
store_chunk182->header.state_type=FSO_USED_CHUNK;
n=store182++;
}
else{
c=gc_fsoc_get1();
if(gc_free182!=NULL){
n=gc_free182;
gc_free182=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk182=c;
*store_chunk182=H182;
store182=((gc182*)(&(store_chunk182->first_object)));
store_left182=H182.count_minus_one;
n=store182++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M182;
return((T182*)n);
}/*--*/

void gc_sweep181(fsoc*c){
gc181*o1,*o2;
o1=((gc181*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store181;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free181;
gc_free181=o1;
}
}
}
else{
int dead=1;
gc181* old_gc_free = gc_free181;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free181;
gc_free181=o1;
}
}
if (dead){
gc_free181 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark181(T181*o){
se_gc_check_id(o,181);
{
if(((gc181*)o)->header.flag==FSOH_UNMARKED){
((gc181*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_free_nodes)gc_mark187((T187*)(o->_free_nodes));
/*i7p*/if(NULL!=o->_cache_node)gc_mark184((T184*)(o->_cache_node));
/*i7p*/if(NULL!=o->_buckets)gc_mark183((o->_buckets));
}
}
}/*--*/

void gc_align_mark181(fsoc*c,gc181*p){
gc181*b=((gc181*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store181)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T181*o=(&(p->object));
((gc181*)o)->header.flag=FSOH_MARKED;
/*i7p*/if(NULL!=o->_free_nodes)gc_mark187((T187*)(o->_free_nodes));
/*i7p*/if(NULL!=o->_cache_node)gc_mark184((T184*)(o->_cache_node));
/*i7p*/if(NULL!=o->_buckets)gc_mark183((o->_buckets));
}
}
}/*--*/
fsoc H181={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark181,
(void(*)(mch*))gc_sweep181},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc181))-1)};

T181*new181(void){
gc181*n;
fsoc*c;
if(store_left181>1){
store_left181--;
n=store181++;
}
else if(gc_free181!=NULL){
n=gc_free181;
gc_free181=n->header.next;
}
else if(store_left181==1){
store_left181=0;
store_chunk181->header.state_type=FSO_USED_CHUNK;
n=store181++;
}
else{
c=gc_fsoc_get1();
if(gc_free181!=NULL){
n=gc_free181;
gc_free181=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk181=c;
*store_chunk181=H181;
store181=((gc181*)(&(store_chunk181->first_object)));
store_left181=H181.count_minus_one;
n=store181++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M181;
return((T181*)n);
}/*--*/

void gc_mark180(T180 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark7((T7*)(e));
}}}}
}/*--*/

T180 new180(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env180.store_left)){
rsoh*r=na_env180.store;
na_env180.store_left-=size;
if(na_env180.store_left>sizeof(rsoh)){
r->header.size=size;
na_env180.store=((rsoh*)(((char*)(na_env180.store))+size));
}
else {
r->header.size=size+na_env180.store_left;
na_env180.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T180)(r+1));
}
return((T180)new_na(&na_env180,size));
}/*--*/

void gc_sweep98(fsoc*c){
gc98*o1,*o2;
o1=((gc98*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store98;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free98;
gc_free98=o1;
}
}
}
else{
int dead=1;
gc98* old_gc_free = gc_free98;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free98;
gc_free98=o1;
}
}
if (dead){
gc_free98 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark98(T98*o){
se_gc_check_id(o,98);
{
if(((gc98*)o)->header.flag==FSOH_UNMARKED){
((gc98*)o)->header.flag=FSOH_MARKED;
/*ip*/if(NULL!=o->_wrappers)gc_mark181((T181*)(o->_wrappers));
}
}
}/*--*/

void gc_align_mark98(fsoc*c,gc98*p){
gc98*b=((gc98*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store98)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T98*o=(&(p->object));
((gc98*)o)->header.flag=FSOH_MARKED;
/*ip*/if(NULL!=o->_wrappers)gc_mark181((T181*)(o->_wrappers));
}
}
}/*--*/
fsoc H98={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark98,
(void(*)(mch*))gc_sweep98},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc98))-1)};

T98*new98(void){
gc98*n;
fsoc*c;
if(store_left98>1){
store_left98--;
n=store98++;
}
else if(gc_free98!=NULL){
n=gc_free98;
gc_free98=n->header.next;
}
else if(store_left98==1){
store_left98=0;
store_chunk98->header.state_type=FSO_USED_CHUNK;
n=store98++;
}
else{
c=gc_fsoc_get1();
if(gc_free98!=NULL){
n=gc_free98;
gc_free98=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk98=c;
*store_chunk98=H98;
store98=((gc98*)(&(store_chunk98->first_object)));
store_left98=H98.count_minus_one;
n=store98++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M98;
return((T98*)n);
}/*--*/

void gc_sweep179(fsoc*c){
gc179*o1,*o2;
o1=((gc179*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store179;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free179;
gc_free179=o1;
}
}
}
else{
int dead=1;
gc179* old_gc_free = gc_free179;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free179;
gc_free179=o1;
}
}
if (dead){
gc_free179 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark179(T179*o){
se_gc_check_id(o,179);
{
if(((gc179*)o)->header.flag==FSOH_UNMARKED){
((gc179*)o)->header.flag=FSOH_MARKED;
/*i3p*/{
T180 na=o->_storage;
if(gc_find_chunk(na)!=NULL){/* non external NA */
   rsoh*h=((rsoh*)na)-1;
   if((h->header.magic_flag)==RSOH_UNMARKED){
      h->header.magic_flag=RSOH_MARKED;
r179mark_native_arrays(NULL,o);
}
}
}}
}
}/*--*/

void gc_align_mark179(fsoc*c,gc179*p){
gc179*b=((gc179*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store179)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T179*o=(&(p->object));
((gc179*)o)->header.flag=FSOH_MARKED;
/*i3p*/{
T180 na=o->_storage;
if(gc_find_chunk(na)!=NULL){/* non external NA */
   rsoh*h=((rsoh*)na)-1;
   if((h->header.magic_flag)==RSOH_UNMARKED){
      h->header.magic_flag=RSOH_MARKED;
r179mark_native_arrays(NULL,o);
}
}
}}
}
}/*--*/
fsoc H179={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark179,
(void(*)(mch*))gc_sweep179},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc179))-1)};

T179*new179(void){
gc179*n;
fsoc*c;
if(store_left179>1){
store_left179--;
n=store179++;
}
else if(gc_free179!=NULL){
n=gc_free179;
gc_free179=n->header.next;
}
else if(store_left179==1){
store_left179=0;
store_chunk179->header.state_type=FSO_USED_CHUNK;
n=store179++;
}
else{
c=gc_fsoc_get1();
if(gc_free179!=NULL){
n=gc_free179;
gc_free179=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk179=c;
*store_chunk179=H179;
store179=((gc179*)(&(store_chunk179->first_object)));
store_left179=H179.count_minus_one;
n=store179++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M179;
return((T179*)n);
}/*--*/

void gc_sweep51(fsoc*c){
gc51*o1,*o2;
o1=((gc51*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store51;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
if((o1->header.flag)==FSOH_UNMARKED){
se_frame_descriptor gcd={"Garbage Collector at work.\n"
"dispose called (during sweep phase)",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&gcd;
ds.caller=se_dst;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r51dispose(&ds,(T51*)o1);
set_dump_stack_top(ds.caller);/*unlink*/
}o1->header.next=gc_free51;
gc_free51=o1;
}
}
}
else{
int dead=1;
gc51* old_gc_free = gc_free51;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
if((o1->header.flag)==FSOH_UNMARKED){
se_frame_descriptor gcd={"Garbage Collector at work.\n"
"dispose called (during sweep phase)",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&gcd;
ds.caller=se_dst;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r51dispose(&ds,(T51*)o1);
set_dump_stack_top(ds.caller);/*unlink*/
}o1->header.next=gc_free51;
gc_free51=o1;
}
}
if (dead){
gc_free51 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark51(T51*o){
se_gc_check_id(o,51);
{
if(((gc51*)o)->header.flag==FSOH_UNMARKED){
((gc51*)o)->header.flag=FSOH_MARKED;
/*i4p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
/*i4p*/}
}
}/*--*/

void gc_align_mark51(fsoc*c,gc51*p){
gc51*b=((gc51*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store51)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T51*o=(&(p->object));
((gc51*)o)->header.flag=FSOH_MARKED;
/*i4p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
/*i4p*/}
}
}/*--*/
fsoc H51={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark51,
(void(*)(mch*))gc_sweep51},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc51))-1)};

T51*new51(void){
gc51*n;
fsoc*c;
if(store_left51>1){
store_left51--;
n=store51++;
}
else if(gc_free51!=NULL){
n=gc_free51;
gc_free51=n->header.next;
}
else if(store_left51==1){
store_left51=0;
store_chunk51->header.state_type=FSO_USED_CHUNK;
n=store51++;
}
else{
c=gc_fsoc_get1();
if(gc_free51!=NULL){
n=gc_free51;
gc_free51=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk51=c;
*store_chunk51=H51;
store51=((gc51*)(&(store_chunk51->first_object)));
store_left51=H51.count_minus_one;
n=store51++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M51;
return((T51*)n);
}/*--*/

void gc_sweep67(fsoc*c){
gc67*o1,*o2;
o1=((gc67*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store67;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
if((o1->header.flag)==FSOH_UNMARKED){
se_frame_descriptor gcd={"Garbage Collector at work.\n"
"dispose called (during sweep phase)",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&gcd;
ds.caller=se_dst;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r67dispose(&ds,(T67*)o1);
set_dump_stack_top(ds.caller);/*unlink*/
}o1->header.next=gc_free67;
gc_free67=o1;
}
}
}
else{
int dead=1;
gc67* old_gc_free = gc_free67;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
if((o1->header.flag)==FSOH_UNMARKED){
se_frame_descriptor gcd={"Garbage Collector at work.\n"
"dispose called (during sweep phase)",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&gcd;
ds.caller=se_dst;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r67dispose(&ds,(T67*)o1);
set_dump_stack_top(ds.caller);/*unlink*/
}o1->header.next=gc_free67;
gc_free67=o1;
}
}
if (dead){
gc_free67 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark67(T67*o){
se_gc_check_id(o,67);
{
((gc67*)o)->header.flag=FSOH_MARKED;
}
}/*--*/

void gc_align_mark67(fsoc*c,gc67*p){
gc67*b=((gc67*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store67)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T67*o=(&(p->object));
((gc67*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H67={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark67,
(void(*)(mch*))gc_sweep67},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc67))-1)};

T67*new67(void){
gc67*n;
fsoc*c;
if(store_left67>1){
store_left67--;
n=store67++;
}
else if(gc_free67!=NULL){
n=gc_free67;
gc_free67=n->header.next;
}
else if(store_left67==1){
store_left67=0;
store_chunk67->header.state_type=FSO_USED_CHUNK;
n=store67++;
}
else{
c=gc_fsoc_get1();
if(gc_free67!=NULL){
n=gc_free67;
gc_free67=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk67=c;
*store_chunk67=H67;
store67=((gc67*)(&(store_chunk67->first_object)));
store_left67=H67.count_minus_one;
n=store67++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M67;
return((T67*)n);
}/*--*/

void gc_sweep59(fsoc*c){
gc59*o1,*o2;
o1=((gc59*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store59;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
if((o1->header.flag)==FSOH_UNMARKED){
se_frame_descriptor gcd={"Garbage Collector at work.\n"
"dispose called (during sweep phase)",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&gcd;
ds.caller=se_dst;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r59dispose(&ds,(T59*)o1);
set_dump_stack_top(ds.caller);/*unlink*/
}o1->header.next=gc_free59;
gc_free59=o1;
}
}
}
else{
int dead=1;
gc59* old_gc_free = gc_free59;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
if((o1->header.flag)==FSOH_UNMARKED){
se_frame_descriptor gcd={"Garbage Collector at work.\n"
"dispose called (during sweep phase)",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&gcd;
ds.caller=se_dst;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r59dispose(&ds,(T59*)o1);
set_dump_stack_top(ds.caller);/*unlink*/
}o1->header.next=gc_free59;
gc_free59=o1;
}
}
if (dead){
gc_free59 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark59(T59*o){
se_gc_check_id(o,59);
{
((gc59*)o)->header.flag=FSOH_MARKED;
}
}/*--*/

void gc_align_mark59(fsoc*c,gc59*p){
gc59*b=((gc59*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store59)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T59*o=(&(p->object));
((gc59*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H59={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark59,
(void(*)(mch*))gc_sweep59},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc59))-1)};

T59*new59(void){
gc59*n;
fsoc*c;
if(store_left59>1){
store_left59--;
n=store59++;
}
else if(gc_free59!=NULL){
n=gc_free59;
gc_free59=n->header.next;
}
else if(store_left59==1){
store_left59=0;
store_chunk59->header.state_type=FSO_USED_CHUNK;
n=store59++;
}
else{
c=gc_fsoc_get1();
if(gc_free59!=NULL){
n=gc_free59;
gc_free59=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk59=c;
*store_chunk59=H59;
store59=((gc59*)(&(store_chunk59->first_object)));
store_left59=H59.count_minus_one;
n=store59++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M59;
return((T59*)n);
}/*--*/

void gc_sweep25(fsoc*c){
gc25*o1,*o2;
o1=((gc25*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store25;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free25;
gc_free25=o1;
}
}
}
else{
int dead=1;
gc25* old_gc_free = gc_free25;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free25;
gc_free25=o1;
}
}
if (dead){
gc_free25 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark25(T25*o){
se_gc_check_id(o,25);
{
if(((gc25*)o)->header.flag==FSOH_UNMARKED){
((gc25*)o)->header.flag=FSOH_MARKED;
/*ip*/if(NULL!=o->_doc)gc_mark59((T59*)(o->_doc));
}
}
}/*--*/

void gc_align_mark25(fsoc*c,gc25*p){
gc25*b=((gc25*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store25)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T25*o=(&(p->object));
((gc25*)o)->header.flag=FSOH_MARKED;
/*ip*/if(NULL!=o->_doc)gc_mark59((T59*)(o->_doc));
}
}
}/*--*/
fsoc H25={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark25,
(void(*)(mch*))gc_sweep25},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc25))-1)};

T25*new25(void){
gc25*n;
fsoc*c;
if(store_left25>1){
store_left25--;
n=store25++;
}
else if(gc_free25!=NULL){
n=gc_free25;
gc_free25=n->header.next;
}
else if(store_left25==1){
store_left25=0;
store_chunk25->header.state_type=FSO_USED_CHUNK;
n=store25++;
}
else{
c=gc_fsoc_get1();
if(gc_free25!=NULL){
n=gc_free25;
gc_free25=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk25=c;
*store_chunk25=H25;
store25=((gc25*)(&(store_chunk25->first_object)));
store_left25=H25.count_minus_one;
n=store25++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M25;
return((T25*)n);
}/*--*/

void gc_mark9(T9 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;
}/*--*/

T9 new9(unsigned int size){
size=(size*sizeof(T3))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env9.store_left)){
rsoh*r=na_env9.store;
na_env9.store_left-=size;
if(na_env9.store_left>sizeof(rsoh)){
r->header.size=size;
na_env9.store=((rsoh*)(((char*)(na_env9.store))+size));
}
else {
r->header.size=size+na_env9.store_left;
na_env9.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T9)(r+1));
}
return((T9)new_na(&na_env9,size));
}/*--*/

void gc_sweep7(fsoc*c){
gc7*o1,*o2;
o1=((gc7*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store7;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
}
else{
int dead=1;
gc7* old_gc_free = gc_free7;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
if (dead){
gc_free7 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark7(T7*o){
se_gc_check_id(o,7);
{
if(((gc7*)o)->header.flag==FSOH_UNMARKED){
((gc7*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_storage)gc_mark9((o->_storage));
}
}
}/*--*/

void gc_align_mark7(fsoc*c,gc7*p){
gc7*b=((gc7*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store7)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T7*o=(&(p->object));
((gc7*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_storage)gc_mark9((o->_storage));
}
}
}/*--*/
fsoc H7={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark7,
(void(*)(mch*))gc_sweep7},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc7))-1)};

T7*new7(void){
gc7*n;
fsoc*c;
if(store_left7>1){
store_left7--;
n=store7++;
}
else if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else if(store_left7==1){
store_left7=0;
store_chunk7->header.state_type=FSO_USED_CHUNK;
n=store7++;
}
else{
c=gc_fsoc_get1();
if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk7=c;
*store_chunk7=H7;
store7=((gc7*)(&(store_chunk7->first_object)));
store_left7=H7.count_minus_one;
n=store7++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M7;
return((T7*)n);
}/*--*/

void Xgc_mark186(T0*o){
{int i=o->id;
if (i <= 189) {
if (i <= 187) {
gc_mark187((T187*)o);
}
else{
gc_mark189((T189*)o);
}}
else{
gc_mark193((T193*)o);
}}}/*--*/
T25*eiffel_root_object=(void*)0;
int se_argc;
char**se_argv;
T7*g[195];
T7*t[195];
char*p[195];
void(*se_prinT[195])(FILE*,void*);
int se_strucT[195]={0,sizeof(T1),sizeof(T2),sizeof(T3),0,0,sizeof(T6),sizeof(T7),sizeof(T8),sizeof(T9),sizeof(T10),0,0,0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T25),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T51),
0,
0,
0,
0,
0,
0,
0,
sizeof(T59),
0,
0,
0,
0,
0,
0,
0,
sizeof(T67),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T98),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T179),
sizeof(T180),
sizeof(T181),
sizeof(T182),
sizeof(T183),
sizeof(T184),
0,
0,
sizeof(T187),
sizeof(T188),
sizeof(T189),
sizeof(T190),
sizeof(T191),
sizeof(T192),
sizeof(T193),
sizeof(T194)};

void se_atexit(void){
se_frame_descriptor fd={"<atexit wrapper>",0,0,"",1};
se_dump_stack ds;
ds.fd=&fd;
ds.p=0;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
r51se_atexit(&ds,NULL/*Unused Target*/);
}/*--*/

void initialize_eiffel_runtime(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
se_frame_descriptor irfd={"<runtime init>",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&irfd;
set_dump_stack_top(&ds);/*link*/
se_argc=argc;
se_argv=argv;
atexit(se_atexit);
gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));
#ifdef FIXED_STACK_BOTTOM
if (!stack_bottom) stack_bottom=((void**)(void*)(&argc));
#endif
p[0]="???";
p[25]="/media/FLASH/eiffel-libraries/trunk/xml/examples/xml2_example.e";
p[59]="/media/FLASH/eiffel-libraries/trunk/xml/library/xml2_doc.e";
p[66]="/media/FLASH/eiffel-libraries/trunk/xml/library/shared_xml2_node_cache.e";
p[27]="/media/FLASH/eiffel-libraries/trunk/xml/library/xml2_parser.e";
p[67]="/media/FLASH/eiffel-libraries/trunk/xml/library/xml2_node.e";
p[98]="/media/FLASH/eiffel-libraries/trunk/xml/library/xml2_node_cache.e";
p[28]="/media/FLASH/eiffel-libraries/trunk/xml/library/externals/libxml2_externals.e";
p[60]="/media/FLASH/eiffel-libraries/trunk/common/library/eiffel_owned.e";
p[68]="/media/FLASH/eiffel-libraries/trunk/common/library/mixed_memory_handling.e";
p[61]="/media/FLASH/eiffel-libraries/trunk/common/library/wrapper.e";
p[100]="/media/FLASH/eiffel-libraries/trunk/common/library/caching_factory.e";
p[65]="/media/FLASH/eiffel-libraries/trunk/common/library/c_struct.e";
p[101]="/media/FLASH/eiffel-libraries/trunk/common/library/wrapper_factory.e";
p[62]="/media/FLASH/eiffel-libraries/trunk/common/library/pointer_handling.e";
p[63]="/media/FLASH/eiffel-libraries/trunk/common/library/wrapper_handler.e";
p[114]="/home/paolo/SmartEiffel/lib/kernel/procedure.e";
p[118]="/home/paolo/SmartEiffel/lib/kernel/memory.e";
p[15]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[16]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[90]="/home/paolo/SmartEiffel/lib/kernel/routine.e";
p[17]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[18]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[19]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[20]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[21]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[22]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[64]="/home/paolo/SmartEiffel/lib/kernel/exceptions.e";
p[23]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[14]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[24]="/home/paolo/SmartEiffel/lib/kernel/tuple.e";
p[8]="/home/paolo/SmartEiffel/lib/kernel/pointer.e";
p[102]="/home/paolo/SmartEiffel/lib/kernel/reference.e";
p[26]="/home/paolo/SmartEiffel/lib/kernel/arguments.e";
p[89]="/home/paolo/SmartEiffel/lib/kernel/function.e";
p[6]="/home/paolo/SmartEiffel/lib/kernel/boolean.e";
p[71]="/home/paolo/SmartEiffel/lib/kernel/safe_equal.e";
p[13]="/home/paolo/SmartEiffel/lib/kernel/any.e";
p[138]="/home/paolo/SmartEiffel/lib/kernel/weak_reference.e";
p[40]="/home/paolo/SmartEiffel/lib/kernel/platform.e";
p[96]="/home/paolo/SmartEiffel/lib/kernel/internal/internals_handler.e";
p[121]="/home/paolo/SmartEiffel/lib/kernel/internal/native_array_internals.e";
p[49]="/home/paolo/SmartEiffel/lib/kernel/internal/typed_internals.e";
p[55]="/home/paolo/SmartEiffel/lib/kernel/internal/native_array_collector.e";
p[50]="/home/paolo/SmartEiffel/lib/kernel/internal/internals.e";
p[54]="/home/paolo/SmartEiffel/lib/storage/collection.e";
p[110]="/home/paolo/SmartEiffel/lib/storage/stack.e";
p[123]="/home/paolo/SmartEiffel/lib/storage/simple_dictionary.e";
p[124]="/home/paolo/SmartEiffel/lib/storage/dictionary.e";
p[53]="/home/paolo/SmartEiffel/lib/storage/collection/fast_array.e";
p[91]="/home/paolo/SmartEiffel/lib/storage/collection/array.e";
p[122]="/home/paolo/SmartEiffel/lib/storage/dictionary/hashed_dictionary.e";
p[70]="/home/paolo/SmartEiffel/lib/storage/low_level/native_array.e";
p[130]="/home/paolo/SmartEiffel/lib/storage/low_level/string_recycling_item.e";
p[109]="/home/paolo/SmartEiffel/lib/storage/low_level/recycling_pool.e";
p[117]="/home/paolo/SmartEiffel/lib/storage/low_level/string_recycling_pool.e";
p[156]="/home/paolo/SmartEiffel/lib/storage/low_level/string_recycling_item_sorter.e";
p[137]="/home/paolo/SmartEiffel/lib/storage/internal/any_hashed_dictionary_node.e";
p[56]="/home/paolo/SmartEiffel/lib/storage/internal/arrayed_collection.e";
p[136]="/home/paolo/SmartEiffel/lib/storage/internal/hashed_dictionary_node.e";
p[125]="/home/paolo/SmartEiffel/lib/storage/internal/hash_table_size.e";
p[146]="/home/paolo/SmartEiffel/lib/io/directory_notation.e";
p[69]="/home/paolo/SmartEiffel/lib/io/filter.e";
p[29]="/home/paolo/SmartEiffel/lib/io/output_stream.e";
p[164]="/home/paolo/SmartEiffel/lib/io/path_name.e";
p[94]="/home/paolo/SmartEiffel/lib/io/filter_input_stream.e";
p[42]="/home/paolo/SmartEiffel/lib/io/terminal_output_stream.e";
p[169]="/home/paolo/SmartEiffel/lib/io/file_tools.e";
p[46]="/home/paolo/SmartEiffel/lib/io/terminal_input_stream.e";
p[45]="/home/paolo/SmartEiffel/lib/io/terminal_input_output_stream.e";
p[86]="/home/paolo/SmartEiffel/lib/io/filter_output_stream.e";
p[47]="/home/paolo/SmartEiffel/lib/io/input_stream.e";
p[30]="/home/paolo/SmartEiffel/lib/io/stream.e";
p[81]="/home/paolo/SmartEiffel/lib/io/terminal/file.e";
p[80]="/home/paolo/SmartEiffel/lib/io/terminal/text_file_read.e";
p[142]="/home/paolo/SmartEiffel/lib/io/terminal/text_file_read_write.e";
p[44]="/home/paolo/SmartEiffel/lib/io/terminal/std_input_output.e";
p[41]="/home/paolo/SmartEiffel/lib/io/terminal/std_error.e";
p[140]="/home/paolo/SmartEiffel/lib/io/terminal/text_file_write.e";
p[52]="/home/paolo/SmartEiffel/lib/io/terminal/std_input.e";
p[51]="/home/paolo/SmartEiffel/lib/io/terminal/std_output.e";
p[48]="/home/paolo/SmartEiffel/lib/io/low_level/input_stream_tools.e";
p[34]="/home/paolo/SmartEiffel/lib/io/low_level/output_stream_tools.e";
p[43]="/home/paolo/SmartEiffel/lib/io/low_level/redirection_tools.e";
p[163]="/home/paolo/SmartEiffel/lib/io/low_level/basic_directory.e";
p[166]="/home/paolo/SmartEiffel/lib/io/internal/unixish_path_name.e";
p[33]="/home/paolo/SmartEiffel/lib/io/internal/filterable.e";
p[145]="/home/paolo/SmartEiffel/lib/io/internal/path_joiner.e";
p[165]="/home/paolo/SmartEiffel/lib/io/path_name/posix_path_name.e";
p[144]="/home/paolo/SmartEiffel/lib/io/path_name/path_name_notation.e";
p[172]="/home/paolo/SmartEiffel/lib/io/path_name/macintosh_directory_notation.e";
p[173]="/home/paolo/SmartEiffel/lib/io/path_name/openvms_directory_notation.e";
p[176]="/home/paolo/SmartEiffel/lib/io/path_name/microsoft_path_name.e";
p[175]="/home/paolo/SmartEiffel/lib/io/path_name/windows_directory_notation.e";
p[143]="/home/paolo/SmartEiffel/lib/io/path_name/unix_directory_notation.e";
p[174]="/home/paolo/SmartEiffel/lib/io/path_name/amiga_directory_notation.e";
p[177]="/home/paolo/SmartEiffel/lib/io/path_name/cygwin_directory_notation.e";
p[171]="/home/paolo/SmartEiffel/lib/unicode/unicode_string_handler.e";
p[88]="/home/paolo/SmartEiffel/lib/iterator/iterator.e";
p[97]="/home/paolo/SmartEiffel/lib/iterator/internal/iterator_on_traversable.e";
p[111]="/home/paolo/SmartEiffel/lib/iterator/internal/iterator_on_unicode_string.e";
p[135]="/home/paolo/SmartEiffel/lib/iterator/internal/iterator_on_dictionary_items.e";
p[93]="/home/paolo/SmartEiffel/lib/iterator/internal/iterator_on_string.e";
p[139]="/home/paolo/SmartEiffel/lib/iterator/internal/iterator_on_dictionary_keys.e";
p[157]="/home/paolo/SmartEiffel/lib/sorting/abstract_sorter.e";
p[120]="/home/paolo/SmartEiffel/lib/misc/mini_parser_buffer.e";
p[119]="/home/paolo/SmartEiffel/lib/sequencer/events_set.e";
p[84]="/home/paolo/SmartEiffel/lib/sequencer/event_descriptor.e";
p[95]="/home/paolo/SmartEiffel/lib/sequencer/events/can_read_data_from_stream.e";
p[162]="/home/paolo/SmartEiffel/lib/sequencer/events/network_connection_occurred.e";
p[85]="/home/paolo/SmartEiffel/lib/sequencer/events/stream_exception.e";
p[87]="/home/paolo/SmartEiffel/lib/sequencer/events/can_write_data_to_stream.e";
p[32]="/home/paolo/SmartEiffel/lib/abilities/recyclable.e";
p[31]="/home/paolo/SmartEiffel/lib/abilities/disposable.e";
p[36]="/home/paolo/SmartEiffel/lib/abilities/traversable.e";
p[39]="/home/paolo/SmartEiffel/lib/abilities/hashable.e";
p[37]="/home/paolo/SmartEiffel/lib/abilities/storable.e";
p[38]="/home/paolo/SmartEiffel/lib/abilities/comparable.e";
p[12]="/home/paolo/SmartEiffel/lib/numeric/real_extended.e";
p[74]="/home/paolo/SmartEiffel/lib/numeric/real_general.e";
p[77]="/home/paolo/SmartEiffel/lib/numeric/natural_64.e";
p[2]="/home/paolo/SmartEiffel/lib/numeric/integer_32.e";
p[78]="/home/paolo/SmartEiffel/lib/numeric/number.e";
p[4]="/home/paolo/SmartEiffel/lib/numeric/real_32.e";
p[1]="/home/paolo/SmartEiffel/lib/numeric/integer_8.e";
p[105]="/home/paolo/SmartEiffel/lib/numeric/mutable_big_integer.e";
p[11]="/home/paolo/SmartEiffel/lib/numeric/integer_64.e";
p[92]="/home/paolo/SmartEiffel/lib/numeric/number_tools.e";
p[57]="/home/paolo/SmartEiffel/lib/numeric/integer_general.e";
p[5]="/home/paolo/SmartEiffel/lib/numeric/real_64.e";
p[72]="/home/paolo/SmartEiffel/lib/numeric/natural_16.e";
p[58]="/home/paolo/SmartEiffel/lib/numeric/numeric.e";
p[76]="/home/paolo/SmartEiffel/lib/numeric/natural_32.e";
p[75]="/home/paolo/SmartEiffel/lib/numeric/natural_8.e";
p[73]="/home/paolo/SmartEiffel/lib/numeric/natural_general.e";
p[10]="/home/paolo/SmartEiffel/lib/numeric/integer_16.e";
p[106]="/home/paolo/SmartEiffel/lib/numeric/internal/fraction_with_big_integer_number.e";
p[103]="/home/paolo/SmartEiffel/lib/numeric/internal/integer_64_number.e";
p[104]="/home/paolo/SmartEiffel/lib/numeric/internal/integer_general_number.e";
p[107]="/home/paolo/SmartEiffel/lib/numeric/internal/fraction_general_number.e";
p[108]="/home/paolo/SmartEiffel/lib/numeric/internal/big_integer_number.e";
p[79]="/home/paolo/SmartEiffel/lib/string/unicode_string.e";
p[3]="/home/paolo/SmartEiffel/lib/string/character.e";
p[7]="/home/paolo/SmartEiffel/lib/string/string.e";
p[35]="/home/paolo/SmartEiffel/lib/string/low_level/string_handler.e";
p[178]="/home/paolo/SmartEiffel/lib/time/time_formatter.e";
p[158]="/home/paolo/SmartEiffel/lib/time/time.e";
p[131]="/home/paolo/SmartEiffel/lib/time/microsecond_time.e";
p[159]="/home/paolo/SmartEiffel/lib/time/low_level/time_handler.e";
p[82]="/home/paolo/SmartEiffel/lib/net/url.e";
p[152]="/home/paolo/SmartEiffel/lib/net/address.e";
p[113]="/home/paolo/SmartEiffel/lib/net/protocol.e";
p[116]="/home/paolo/SmartEiffel/lib/net/resource_locator.e";
p[150]="/home/paolo/SmartEiffel/lib/net/access.e";
p[148]="/home/paolo/SmartEiffel/lib/net/socket_input_output_stream.e";
p[112]="/home/paolo/SmartEiffel/lib/net/protocols.e";
p[83]="/home/paolo/SmartEiffel/lib/net/url_validity.e";
p[151]="/home/paolo/SmartEiffel/lib/net/address/host.e";
p[168]="/home/paolo/SmartEiffel/lib/net/address/ip_address.e";
p[149]="/home/paolo/SmartEiffel/lib/net/access/tcp_access.e";
p[132]="/home/paolo/SmartEiffel/lib/net/low_level/socket_server.e";
p[167]="/home/paolo/SmartEiffel/lib/net/low_level/client_socket_input_output_stream.e";
p[161]="/home/paolo/SmartEiffel/lib/net/low_level/server_socket_input_output_stream.e";
p[133]="/home/paolo/SmartEiffel/lib/net/low_level/socket_plug_in.e";
p[134]="/home/paolo/SmartEiffel/lib/net/low_level/socket_handler.e";
p[160]="/home/paolo/SmartEiffel/lib/net/low_level/socket.e";
p[115]="/home/paolo/SmartEiffel/lib/net/protocols/stream_protocol.e";
p[154]="/home/paolo/SmartEiffel/lib/net/protocols/http_client_input_stream.e";
p[126]="/home/paolo/SmartEiffel/lib/net/protocols/file_protocol.e";
p[127]="/home/paolo/SmartEiffel/lib/net/protocols/http_protocol.e";
p[128]="/home/paolo/SmartEiffel/lib/net/protocols/tcp_protocol.e";
p[153]="/home/paolo/SmartEiffel/lib/net/protocols/http_proxy.e";
p[155]="/home/paolo/SmartEiffel/lib/net/protocols/http_client_output_stream.e";
p[141]="/home/paolo/SmartEiffel/lib/net/resource_locators/file_resource_locator.e";
p[129]="/home/paolo/SmartEiffel/lib/net/resource_locators/network_resource_validity.e";
p[147]="/home/paolo/SmartEiffel/lib/net/resource_locators/network_resource_locator.e";
p[170]="/home/paolo/SmartEiffel/lib/exec/system.e";
p[99]="/home/paolo/SmartEiffel/lib/design_patterns/singleton.e";
se_prinT[194]=((void(*)(FILE*,void*))se_prinT194);
p[194]=p[70];
se_prinT[193]=((void(*)(FILE*,void*))se_prinT193);
p[193]=p[138];
se_prinT[192]=((void(*)(FILE*,void*))se_prinT192);
p[192]=p[136];
se_prinT[191]=((void(*)(FILE*,void*))se_prinT191);
p[191]=p[70];
se_prinT[190]=((void(*)(FILE*,void*))se_prinT190);
p[190]=p[136];
se_prinT[189]=((void(*)(FILE*,void*))se_prinT189);
p[189]=p[138];
se_prinT[188]=((void(*)(FILE*,void*))se_prinT188);
p[188]=p[122];
se_prinT[187]=((void(*)(FILE*,void*))se_prinT187);
p[187]=p[138];
se_prinT[184]=((void(*)(FILE*,void*))se_prinT184);
p[184]=p[136];
se_prinT[183]=((void(*)(FILE*,void*))se_prinT183);
p[183]=p[70];
se_prinT[182]=((void(*)(FILE*,void*))se_prinT182);
p[182]=p[122];
se_prinT[181]=((void(*)(FILE*,void*))se_prinT181);
p[181]=p[122];
se_prinT[180]=((void(*)(FILE*,void*))se_prinT180);
p[180]=p[70];
se_prinT[179]=((void(*)(FILE*,void*))se_prinT179);
p[179]=p[53];
se_prinT[98]=((void(*)(FILE*,void*))se_prinT98);
se_prinT[67]=((void(*)(FILE*,void*))se_prinT67);
se_prinT[59]=((void(*)(FILE*,void*))se_prinT59);
se_prinT[51]=((void(*)(FILE*,void*))se_prinT51);
se_prinT[25]=((void(*)(FILE*,void*))se_prinT25);
se_prinT[10]=((void(*)(FILE*,void*))se_prinT10);
se_prinT[9]=((void(*)(FILE*,void*))se_prinT9);
p[9]=p[70];
se_prinT[8]=((void(*)(FILE*,void*))se_prinT8);
se_prinT[7]=((void(*)(FILE*,void*))se_prinT7);
se_prinT[6]=((void(*)(FILE*,void*))se_prinT6);
se_prinT[3]=((void(*)(FILE*,void*))se_prinT3);
se_prinT[2]=((void(*)(FILE*,void*))se_prinT2);
se_prinT[1]=((void(*)(FILE*,void*))se_prinT1);
g[25]=(T7*)se_string("XML2_EXAMPLE");
g[59]=(T7*)se_string("XML2_DOC");
g[66]=(T7*)se_string("SHARED_XML2_NODE_CACHE");
g[27]=(T7*)se_string("XML2_PARSER");
g[67]=(T7*)se_string("XML2_NODE");
g[98]=(T7*)se_string("XML2_NODE_CACHE");
g[28]=(T7*)se_string("LIBXML2_EXTERNALS");
g[60]=(T7*)se_string("EIFFEL_OWNED");
g[68]=(T7*)se_string("MIXED_MEMORY_HANDLING");
g[61]=(T7*)se_string("WRAPPER");
g[100]=(T7*)se_string("CACHING_FACTORY");
g[65]=(T7*)se_string("C_STRUCT");
g[101]=(T7*)se_string("WRAPPER_FACTORY");
g[62]=(T7*)se_string("POINTER_HANDLING");
g[63]=(T7*)se_string("WRAPPER_HANDLER");
g[114]=(T7*)se_string("PROCEDURE");
g[118]=(T7*)se_string("MEMORY");
g[15]=(T7*)se_string("TUPLE 1");
g[16]=(T7*)se_string("TUPLE 2");
g[90]=(T7*)se_string("ROUTINE");
g[17]=(T7*)se_string("TUPLE 3");
g[18]=(T7*)se_string("TUPLE 4");
g[19]=(T7*)se_string("TUPLE 5");
g[20]=(T7*)se_string("TUPLE 6");
g[21]=(T7*)se_string("TUPLE 7");
g[22]=(T7*)se_string("TUPLE 8");
g[64]=(T7*)se_string("EXCEPTIONS");
g[23]=(T7*)se_string("TUPLE 9");
g[14]=(T7*)se_string("TUPLE");
g[24]=(T7*)se_string("TUPLE 10");
g[8]=(T7*)se_string("POINTER");
g[102]=(T7*)se_string("REFERENCE");
g[26]=(T7*)se_string("ARGUMENTS");
g[89]=(T7*)se_string("FUNCTION");
g[6]=(T7*)se_string("BOOLEAN");
g[71]=(T7*)se_string("SAFE_EQUAL");
g[13]=(T7*)se_string("ANY");
g[138]=(T7*)se_string("WEAK_REFERENCE");
g[40]=(T7*)se_string("PLATFORM");
g[96]=(T7*)se_string("INTERNALS_HANDLER");
g[121]=(T7*)se_string("NATIVE_ARRAY_INTERNALS");
g[49]=(T7*)se_string("TYPED_INTERNALS");
g[55]=(T7*)se_string("NATIVE_ARRAY_COLLECTOR");
g[50]=(T7*)se_string("INTERNALS");
g[54]=(T7*)se_string("COLLECTION");
g[110]=(T7*)se_string("STACK");
g[123]=(T7*)se_string("SIMPLE_DICTIONARY");
g[124]=(T7*)se_string("DICTIONARY");
g[53]=(T7*)se_string("FAST_ARRAY");
g[91]=(T7*)se_string("ARRAY");
g[122]=(T7*)se_string("HASHED_DICTIONARY");
g[70]=(T7*)se_string("NATIVE_ARRAY");
g[130]=(T7*)se_string("STRING_RECYCLING_ITEM");
g[109]=(T7*)se_string("RECYCLING_POOL");
g[117]=(T7*)se_string("STRING_RECYCLING_POOL");
g[156]=(T7*)se_string("STRING_RECYCLING_ITEM_SORTER");
g[137]=(T7*)se_string("ANY_HASHED_DICTIONARY_NODE");
g[56]=(T7*)se_string("ARRAYED_COLLECTION");
g[136]=(T7*)se_string("HASHED_DICTIONARY_NODE");
g[125]=(T7*)se_string("HASH_TABLE_SIZE");
g[146]=(T7*)se_string("DIRECTORY_NOTATION");
g[69]=(T7*)se_string("FILTER");
g[29]=(T7*)se_string("OUTPUT_STREAM");
g[164]=(T7*)se_string("PATH_NAME");
g[94]=(T7*)se_string("FILTER_INPUT_STREAM");
g[42]=(T7*)se_string("TERMINAL_OUTPUT_STREAM");
g[169]=(T7*)se_string("FILE_TOOLS");
g[46]=(T7*)se_string("TERMINAL_INPUT_STREAM");
g[45]=(T7*)se_string("TERMINAL_INPUT_OUTPUT_STREAM");
g[86]=(T7*)se_string("FILTER_OUTPUT_STREAM");
g[47]=(T7*)se_string("INPUT_STREAM");
g[30]=(T7*)se_string("STREAM");
g[81]=(T7*)se_string("FILE");
g[80]=(T7*)se_string("TEXT_FILE_READ");
g[142]=(T7*)se_string("TEXT_FILE_READ_WRITE");
g[44]=(T7*)se_string("STD_INPUT_OUTPUT");
g[41]=(T7*)se_string("STD_ERROR");
g[140]=(T7*)se_string("TEXT_FILE_WRITE");
g[52]=(T7*)se_string("STD_INPUT");
g[51]=(T7*)se_string("STD_OUTPUT");
g[48]=(T7*)se_string("INPUT_STREAM_TOOLS");
g[34]=(T7*)se_string("OUTPUT_STREAM_TOOLS");
g[43]=(T7*)se_string("REDIRECTION_TOOLS");
g[163]=(T7*)se_string("BASIC_DIRECTORY");
g[166]=(T7*)se_string("UNIXISH_PATH_NAME");
g[33]=(T7*)se_string("FILTERABLE");
g[145]=(T7*)se_string("PATH_JOINER");
g[165]=(T7*)se_string("POSIX_PATH_NAME");
g[144]=(T7*)se_string("PATH_NAME_NOTATION");
g[172]=(T7*)se_string("MACINTOSH_DIRECTORY_NOTATION");
g[173]=(T7*)se_string("OPENVMS_DIRECTORY_NOTATION");
g[176]=(T7*)se_string("MICROSOFT_PATH_NAME");
g[175]=(T7*)se_string("WINDOWS_DIRECTORY_NOTATION");
g[143]=(T7*)se_string("UNIX_DIRECTORY_NOTATION");
g[174]=(T7*)se_string("AMIGA_DIRECTORY_NOTATION");
g[177]=(T7*)se_string("CYGWIN_DIRECTORY_NOTATION");
g[171]=(T7*)se_string("UNICODE_STRING_HANDLER");
g[88]=(T7*)se_string("ITERATOR");
g[97]=(T7*)se_string("ITERATOR_ON_TRAVERSABLE");
g[111]=(T7*)se_string("ITERATOR_ON_UNICODE_STRING");
g[135]=(T7*)se_string("ITERATOR_ON_DICTIONARY_ITEMS");
g[93]=(T7*)se_string("ITERATOR_ON_STRING");
g[139]=(T7*)se_string("ITERATOR_ON_DICTIONARY_KEYS");
g[157]=(T7*)se_string("ABSTRACT_SORTER");
g[120]=(T7*)se_string("MINI_PARSER_BUFFER");
g[119]=(T7*)se_string("EVENTS_SET");
g[84]=(T7*)se_string("EVENT_DESCRIPTOR");
g[95]=(T7*)se_string("CAN_READ_DATA_FROM_STREAM");
g[162]=(T7*)se_string("NETWORK_CONNECTION_OCCURRED");
g[85]=(T7*)se_string("STREAM_EXCEPTION");
g[87]=(T7*)se_string("CAN_WRITE_DATA_TO_STREAM");
g[32]=(T7*)se_string("RECYCLABLE");
g[31]=(T7*)se_string("DISPOSABLE");
g[36]=(T7*)se_string("TRAVERSABLE");
g[39]=(T7*)se_string("HASHABLE");
g[37]=(T7*)se_string("STORABLE");
g[38]=(T7*)se_string("COMPARABLE");
g[12]=(T7*)se_string("REAL_EXTENDED");
g[74]=(T7*)se_string("REAL_GENERAL");
g[77]=(T7*)se_string("NATURAL_64");
g[2]=(T7*)se_string("INTEGER_32");
g[78]=(T7*)se_string("NUMBER");
g[4]=(T7*)se_string("REAL_32");
g[1]=(T7*)se_string("INTEGER_8");
g[105]=(T7*)se_string("MUTABLE_BIG_INTEGER");
g[11]=(T7*)se_string("INTEGER_64");
g[92]=(T7*)se_string("NUMBER_TOOLS");
g[57]=(T7*)se_string("INTEGER_GENERAL");
g[5]=(T7*)se_string("REAL_64");
g[72]=(T7*)se_string("NATURAL_16");
g[58]=(T7*)se_string("NUMERIC");
g[76]=(T7*)se_string("NATURAL_32");
g[75]=(T7*)se_string("NATURAL_8");
g[73]=(T7*)se_string("NATURAL_GENERAL");
g[10]=(T7*)se_string("INTEGER_16");
g[106]=(T7*)se_string("FRACTION_WITH_BIG_INTEGER_NUMBER");
g[103]=(T7*)se_string("INTEGER_64_NUMBER");
g[104]=(T7*)se_string("INTEGER_GENERAL_NUMBER");
g[107]=(T7*)se_string("FRACTION_GENERAL_NUMBER");
g[108]=(T7*)se_string("BIG_INTEGER_NUMBER");
g[79]=(T7*)se_string("UNICODE_STRING");
g[3]=(T7*)se_string("CHARACTER");
g[7]=(T7*)se_string("STRING");
g[35]=(T7*)se_string("STRING_HANDLER");
g[178]=(T7*)se_string("TIME_FORMATTER");
g[158]=(T7*)se_string("TIME");
g[131]=(T7*)se_string("MICROSECOND_TIME");
g[159]=(T7*)se_string("TIME_HANDLER");
g[82]=(T7*)se_string("URL");
g[152]=(T7*)se_string("ADDRESS");
g[113]=(T7*)se_string("PROTOCOL");
g[116]=(T7*)se_string("RESOURCE_LOCATOR");
g[150]=(T7*)se_string("ACCESS");
g[148]=(T7*)se_string("SOCKET_INPUT_OUTPUT_STREAM");
g[112]=(T7*)se_string("PROTOCOLS");
g[83]=(T7*)se_string("URL_VALIDITY");
g[151]=(T7*)se_string("HOST");
g[168]=(T7*)se_string("IP_ADDRESS");
g[149]=(T7*)se_string("TCP_ACCESS");
g[132]=(T7*)se_string("SOCKET_SERVER");
g[167]=(T7*)se_string("CLIENT_SOCKET_INPUT_OUTPUT_STREAM");
g[161]=(T7*)se_string("SERVER_SOCKET_INPUT_OUTPUT_STREAM");
g[133]=(T7*)se_string("SOCKET_PLUG_IN");
g[134]=(T7*)se_string("SOCKET_HANDLER");
g[160]=(T7*)se_string("SOCKET");
g[115]=(T7*)se_string("STREAM_PROTOCOL");
g[154]=(T7*)se_string("HTTP_CLIENT_INPUT_STREAM");
g[126]=(T7*)se_string("FILE_PROTOCOL");
g[127]=(T7*)se_string("HTTP_PROTOCOL");
g[128]=(T7*)se_string("TCP_PROTOCOL");
g[153]=(T7*)se_string("HTTP_PROXY");
g[155]=(T7*)se_string("HTTP_CLIENT_OUTPUT_STREAM");
g[141]=(T7*)se_string("FILE_RESOURCE_LOCATOR");
g[129]=(T7*)se_string("NETWORK_RESOURCE_VALIDITY");
g[147]=(T7*)se_string("NETWORK_RESOURCE_LOCATOR");
g[170]=(T7*)se_string("SYSTEM");
g[99]=(T7*)se_string("SINGLETON");
g[194]=g[70];
g[193]=g[138];
g[192]=g[136];
g[191]=g[70];
g[190]=g[136];
g[189]=g[138];
g[188]=g[122];
g[187]=g[138];
g[184]=g[136];
g[183]=g[70];
g[182]=g[122];
g[181]=g[122];
g[180]=g[70];
g[179]=g[53];
g[9]=g[70];
t[194]=(T7*)se_string("NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]");
t[193]=(T7*)se_string("WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]]");
t[192]=(T7*)se_string("HASHED_DICTIONARY_NODE[POINTER,STRING]");
t[191]=(T7*)se_string("NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]");
t[190]=(T7*)se_string("HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]");
t[189]=(T7*)se_string("WEAK_REFERENCE[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]");
t[188]=(T7*)se_string("HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]");
t[187]=(T7*)se_string("WEAK_REFERENCE[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]");
t[184]=(T7*)se_string("HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]");
t[183]=(T7*)se_string("NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]");
t[182]=(T7*)se_string("HASHED_DICTIONARY[POINTER,STRING]");
t[181]=(T7*)se_string("HASHED_DICTIONARY[XML2_NODE,POINTER]");
t[180]=(T7*)se_string("NATIVE_ARRAY[STRING]");
t[179]=(T7*)se_string("FAST_ARRAY[STRING]");
t[98]=g[98];
t[67]=g[67];
t[59]=g[59];
t[51]=g[51];
t[25]=g[25];
t[10]=g[10];
t[9]=(T7*)se_string("NATIVE_ARRAY[CHARACTER]");
t[8]=g[8];
t[7]=g[7];
t[6]=g[6];
t[3]=g[3];
t[2]=g[2];
t[1]=g[1];
#ifdef SIGINT
signal(SIGINT,se_signal_handler);
#endif
#ifdef SIGTERM
signal(SIGTERM,se_signal_handler);
#endif
#ifdef SIGQUIT
signal(SIGQUIT,se_signal_handler);
#endif
#ifdef SIGILL
signal(SIGILL,se_signal_handler);
#endif
#ifdef SIGABRT
signal(SIGABRT,se_signal_handler);
#endif
#ifdef SIGFPE
signal(SIGFPE,se_signal_handler);
#endif
#ifdef SIGSEGV
signal(SIGSEGV,se_signal_handler);
#endif
#ifdef SIGBUS
signal(SIGBUS,se_signal_handler);
#endif
#ifdef SIGSYS
signal(SIGSYS,se_signal_handler);
#endif
#ifdef SIGTRAP
signal(SIGTRAP,se_signal_handler);
#endif
#ifdef SIGXCPU
signal(SIGXCPU,se_signal_handler);
#endif
#ifdef SIGXFSZ
signal(SIGXFSZ,se_signal_handler);
#endif
se_msi1();
gc_is_off=0;
tmp0/*root*/=((T0*)(new25()));
eiffel_root_object=((T25*)tmp0/*root*/);
/*tmp0.unlock*/
set_dump_stack_top((void*)0);/*unlink*/
}/*--*/

int main(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
se_frame_descriptor root={"<system root>",1,0,"%R25%",1};
se_dump_stack ds;
stack_bottom=((void**)(void*)(&argc));
initialize_eiffel_runtime(argc,argv);
tmp0/*prof*/=((T0*)eiffel_root_object);
ds.fd=&root;
ds.current=((void*)(&tmp0/*prof*/));
ds.p=0x03200B04/*l11c2/xml2_example.e*/;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r25make(&ds,((T25*)tmp0/*prof*/));
gc_dispose_before_exit();
handle(SE_HANDLE_NORMAL_EXIT, NULL);
set_dump_stack_top(NULL);/*unlink*/
/*tmp0.unlock*/
exit(0);
return 0;
}/*--*/

#ifdef __cplusplus
}
#endif
