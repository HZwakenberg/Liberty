#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.4 (svn snaphsot 9297) [????]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/

#ifdef __cplusplus
}
#endif
#include "xml2_example.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (malloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (calloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
    handle(SE_HANDLE_NO_MORE_MEMORY, NULL);
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory (realloc failed).\n");
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/* ---------------------------------------------------------------------- */

void se_die (int code) {
  handle(SE_HANDLE_DIE_WITH_CODE, &code);
  exit(code);
}

/*
    Runtime hooks
 */

static se_runtime_handler_t** handlers = NULL;
int handlers_count=0;

void register_handler(se_runtime_handler_t*handler) {
  int new_count = handlers_count + 1;
  handlers = (se_runtime_handler_t**)se_realloc(handlers, (new_count) * sizeof(void*));
  handlers[handlers_count] = handler;
  handlers_count = new_count;
}

void _handle(se_handler_action_t action, void*data) {
  int i;
  for (i = 0; i < handlers_count; i++) {
    handlers[i](action, data);
    /* *** Check type of this array. Function pointer may have different size from data pointer. (PH 17/07/08) */
  }
}
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of read_stdin */

void io_copy (char*source, char*target) {
  /* We use the low-level descriptor functions rather than stream-oriented functions.
   * This allows us to copy the file's permissions. */

  int src;
  int tgt;
  struct stat info;
  static char *buffer = NULL;
  static int bufsize = 0;
  int read_count, write_count, written;

  src=open (source, O_RDONLY);
  if (fstat (src, &info))
    return; /* Ooops */
  if (bufsize < info.st_blksize)
    buffer=se_realloc (buffer, info.st_blksize);
  tgt=creat (target, info.st_mode);
  do {
    read_count = read (src, buffer, info.st_blksize);
    write_count = 0; written = 0;
    while  ((write_count < read_count) && (written >= 0))
      {
	written = write (tgt, buffer + write_count, read_count - write_count);
	write_count += written;
      }
  } while ((read_count > 0) && (written >= 0));
  close (src);
  close (tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  struct stat info1, info2;
  if (stat(path1, &info1))
    return 0; /* oops */
  if (stat(path2, &info2))
    return 0; /* oops */
  return (info1.st_dev == info2.st_dev) && (info1.st_ino == info2.st_ino);
}

#else
#define IO_COPY_BUFSIZE 4096

int read_stdin(EIF_CHARACTER *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (EIF_CHARACTER)c;
  return 1;
}

void io_copy(char*source, char*target) {
  static char *buffer = NULL;
  int read_count;
  FILE*src=fopen(source, "rb");
  FILE*tgt=fopen(target, "wb");

  if(!buffer)
    buffer = (char*)se_malloc(IO_COPY_BUFSIZE);

  while ((read_count = fread(buffer, 1, IO_COPY_BUFSIZE, src)), read_count) {
    fwrite(buffer, 1, read_count, tgt);
  }
  fclose(src);
  fclose(tgt);
}

int io_same_physical_file(char*path1,char*path2) {
  /* default implementation returns true only if the paths are the same */
  return !strcmp(path1, path2);
}
#endif

int io_file_exists(char*source) {
  FILE*src=fopen(source, "rb");
  if (src!=NULL) {
    fclose(src);
    return 1;
  }
  else {
    return (errno != ENOENT);
  }
}
inline xmlChar *xml_node_get_name (xmlNode *a_node) {
	return a_node->name;
}

inline xmlNode *xml_node_get_children (xmlNode *a_node) {
	return a_node->children;
}

inline xmlNode *xml_node_get_last (xmlNode *a_node) {
	return a_node->last;
}

inline xmlNode *xml_node_get_parent (xmlNode *a_node) {
	return a_node->parent;
}

inline xmlNode *xml_node_get_next (xmlNode *a_node) {
	return a_node->next;
}

inline xmlNode *xml_node_get_prev (xmlNode *a_node) {
	return a_node->prev;
}



void se_prinT194(FILE* file,T194*o){
fprintf(file,"NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T193 M193={193,(void*)0};

void se_prinT193(FILE* file,T193**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"item = ");
se_prinT0(file,(T0**)(&((*o)->_item)));
fprintf(file,"\n\t]");
}/*--*/
T192 M192={192,(void*)0,(void*)0,(void*)0};

void se_prinT192(FILE* file,T192**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"HASHED_DICTIONARY_NODE[POINTER,STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"item = ");
se_prinT8(file,(&((*o)->_item)));
fprintf(file,"\n\t  ");
fprintf(file,"key = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_key)));
fprintf(file,"\n\t  ");
fprintf(file,"next = ");
se_prinT0(file,(T0**)(&((*o)->_next)));
fprintf(file,"\n\t]");
}/*--*/

void se_prinT191(FILE* file,T191*o){
fprintf(file,"NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T190 M190={190,(void*)0,(void*)0,(void*)0};

void se_prinT190(FILE* file,T190**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"item = ");
se_prinT0(file,(T0**)(&((*o)->_item)));
fprintf(file,"\n\t  ");
fprintf(file,"key = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_key)));
fprintf(file,"\n\t  ");
fprintf(file,"next = ");
se_prinT0(file,(T0**)(&((*o)->_next)));
fprintf(file,"\n\t]");
}/*--*/
T189 M189={189,(void*)0};

void se_prinT189(FILE* file,T189**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"WEAK_REFERENCE[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"item = ");
se_prinT0(file,(T0**)(&((*o)->_item)));
fprintf(file,"\n\t]");
}/*--*/
T188 M188={188,(void*)0,0,0,0,(void*)0,0,(void*)0};

void se_prinT188(FILE* file,T188**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"buckets = ");
se_prinT194(file,(&((*o)->_buckets)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"count = ");
se_prinT2(file,(&((*o)->_count)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_user = ");
se_prinT2(file,(&((*o)->_cache_user)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_node = ");
se_prinT0(file,(T0**)(&((*o)->_cache_node)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_buckets = ");
se_prinT2(file,(&((*o)->_cache_buckets)));
fprintf(file,"\n\t  ");
fprintf(file,"free_nodes = ");
se_prinT0(file,(T0**)(&((*o)->_free_nodes)));
fprintf(file,"\n\t]");
}/*--*/
T187 M187={187,(void*)0};

void se_prinT187(FILE* file,T187**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"WEAK_REFERENCE[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"item = ");
se_prinT0(file,(T0**)(&((*o)->_item)));
fprintf(file,"\n\t]");
}/*--*/
T184 M184={184,(void*)0,(void*)0,(void*)0};

void se_prinT184(FILE* file,T184**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"item = ");
se_prinT0(file,(T0**)(&((*o)->_item)));
fprintf(file,"\n\t  ");
fprintf(file,"key = ");
se_prinT8(file,(&((*o)->_key)));
fprintf(file,"\n\t  ");
fprintf(file,"next = ");
se_prinT0(file,(T0**)(&((*o)->_next)));
fprintf(file,"\n\t]");
}/*--*/

void se_prinT183(FILE* file,T183*o){
fprintf(file,"NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T182 M182={182,(void*)0,0,0,0,(void*)0,0,(void*)0};

void se_prinT182(FILE* file,T182**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"HASHED_DICTIONARY[POINTER,STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"buckets = ");
se_prinT191(file,(&((*o)->_buckets)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"count = ");
se_prinT2(file,(&((*o)->_count)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_user = ");
se_prinT2(file,(&((*o)->_cache_user)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_node = ");
se_prinT0(file,(T0**)(&((*o)->_cache_node)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_buckets = ");
se_prinT2(file,(&((*o)->_cache_buckets)));
fprintf(file,"\n\t  ");
fprintf(file,"free_nodes = ");
se_prinT0(file,(T0**)(&((*o)->_free_nodes)));
fprintf(file,"\n\t]");
}/*--*/
T181 M181={181,(void*)0,0,0,0,(void*)0,0,(void*)0};

void se_prinT181(FILE* file,T181**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"HASHED_DICTIONARY[XML2_NODE,POINTER]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"buckets = ");
se_prinT183(file,(&((*o)->_buckets)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"count = ");
se_prinT2(file,(&((*o)->_count)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_user = ");
se_prinT2(file,(&((*o)->_cache_user)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_node = ");
se_prinT0(file,(T0**)(&((*o)->_cache_node)));
fprintf(file,"\n\t  ");
fprintf(file,"cache_buckets = ");
se_prinT2(file,(&((*o)->_cache_buckets)));
fprintf(file,"\n\t  ");
fprintf(file,"free_nodes = ");
se_prinT0(file,(T0**)(&((*o)->_free_nodes)));
fprintf(file,"\n\t]");
}/*--*/

void se_prinT180(FILE* file,T180*o){
fprintf(file,"NATIVE_ARRAY[STRING]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T98 M98={98,(void*)0};

void se_prinT98(FILE* file,T98**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"XML2_NODE_CACHE");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"wrappers = ");
se_prinT0(file,(T0**)(&((*o)->_wrappers)));
fprintf(file,"\n\t]");
}/*--*/
T179 M179={179,(void*)0,0,0};

void se_prinT179(FILE* file,T179**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"FAST_ARRAY[STRING]");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"storage = ");
se_prinT180(file,(&((*o)->_storage)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t  ");
fprintf(file,"upper = ");
se_prinT2(file,(&((*o)->_upper)));
fprintf(file,"\n\t]");
}/*--*/
T51 M51={51,(void*)0,0,(void*)0,0};

void se_prinT51(FILE* file,T51**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"STD_OUTPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"filter = ");
se_prinT0(file,(T0**)(&((*o)->_filter)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t]");
}/*--*/
T67 M67={67,(void*)0,0};

void se_prinT67(FILE* file,T67**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"XML2_NODE");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"handle = ");
se_prinT8(file,(&((*o)->_handle)));
fprintf(file,"\n\t  ");
fprintf(file,"is_shared = ");
se_prinT6(file,(&((*o)->_is_shared)));
fprintf(file,"\n\t]");
}/*--*/
T59 M59={59,(void*)0};

void se_prinT59(FILE* file,T59**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"XML2_DOC");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"handle = ");
se_prinT8(file,(&((*o)->_handle)));
fprintf(file,"\n\t]");
}/*--*/
T25 M25={25,(void*)0};

void se_prinT25(FILE* file,T25**o){
if(*o==NULL){
   fprintf(file, "void");
   return;}
fprintf(file,"XML2_EXAMPLE");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"doc = ");
se_prinT0(file,(T0**)(&((*o)->_doc)));
fprintf(file,"\n\t]");
}/*--*/

void se_prinT9(FILE* file,T9*o){
fprintf(file,"NATIVE_ARRAY[CHARACTER]");
fprintf(file,"#%p",(void*)*o);
}/*--*/
T7 M7={7,(void*)0,0,0};
/*Aliased storage area or unicode storage.*/
char*s25_1097781507="Got a void root\n";
char*s25_1367916000="Provide a document\n";
char*s13_14150="Void";
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.c) is automatically included
  when `ace.no_check' is true (ie. all modes except -boost).
*/

int assertion_depth=1;

/*
   To print object into the trace-stack :
*/
void se_prinT0(FILE* file, T0** o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	fprintf(file,"#%p",(void*)*o);
    }
}

void se_prinT1(FILE* file, EIF_INTEGER_8* o) {
    fprintf(file,"%"PRId8,*o);
}

void se_prinT2(FILE* file, EIF_INTEGER* o) {
    fprintf(file,"%"PRId32,*o);
}

void se_prinT10(FILE* file, EIF_INTEGER_16* o) {
    fprintf(file,"%"PRId16,*o);
}

void se_prinT11(FILE* file,EIF_INTEGER_64* o) {
    fprintf(file,"%"PRId64,*o);
}

static void se_print_character(FILE* file, char c) {
    /* Produce a visible output of `c' using an Eiffelish notation.
     */
    if ((' ' <= c)&&(c <= '~')&&(c != '\'')&&(c != '\"')&&(c != '%')) {
	putc(c,file);
    }
    else {
	switch (c) {
	    case '\b': fprintf(file,"%%B"); break;
	    case '\f': fprintf(file,"%%F"); break;
	    case '\n': fprintf(file,"%%N"); break;
	    case '\r': fprintf(file,"%%R"); break;
	    case '\t': fprintf(file,"%%T"); break;
	    case '\0': fprintf(file,"%%U"); break;
	    case '\'': fprintf(file,"%%\'"); break;
	    case '\"': fprintf(file,"%%\""); break;
	    case '%':  fprintf(file,"%%%%"); break;
	    default:
		fprintf(file,"%%/%d/", (int) ((unsigned char) c));
	}
    }
}

void se_prinT3(FILE* file,EIF_CHARACTER* o) {
    putc('\'',file);
    se_print_character(file, *o);
    putc('\'',file);
}

void se_prinT4(FILE* file, EIF_REAL_32* o) {
    fprintf(file, "%.7e", ((real64_t)*o));
}

void se_prinT5(FILE* file, EIF_REAL_64* o) {
    fprintf(file, "%.16e", *o);
}

void se_prinT12(FILE* file, EIF_REAL_EXTENDED* o) {
    fprintf(file, "%.19Le", *o);
}

void se_prinT6(FILE* file, EIF_BOOLEAN* o) {
    if (*o) {
	fprintf(file,"True");
    }
    else {
	fprintf(file,"False");
    }
}

void se_prinT7(FILE* file, EIF_STRING* o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	T3* storage = (*o)->_storage;
	int count = (*o)->_count;
	int i = 0;
	putc('\"',file);
	while (i < count) {
	    se_print_character(file, storage[i++]);
	}
	putc('\"',file);
    }
}

void se_prinT8(FILE* file, EIF_POINTER* o) {
    if (*o == NULL) {
	fprintf(file,"NULL");
    }
    else {
	fprintf(file,"POINTER#%p",(void*)*o);
    }
}


/*
  The upper most context (SmartEiffel Dump stack Top) :
*/
se_dump_stack* se_dst=NULL;

int se_stack_size(se_dump_stack* ds) {
  int result = 0;
  while (ds != NULL) {
    ds = ds->caller;
    result ++;
  }
  return result;
}

void se_print_run_time_stack(void) {
  se_print_run_time_stack_in(SE_ERR);
}

void se_print_run_time_stack_in(FILE* file) {
  /* ANY.print_run_time_stack */
  se_dump_stack* origin;
  se_dump_stack* ds;
  se_dump_stack* ds2;
  int frame_count = 1;
  int rescue = 0;

  handle(SE_HANDLE_ENTER_PRINT_STACK, NULL);
  origin = se_dst;
  if (origin == NULL) {
    fprintf(file,"Empty stack.\n");
    return ;
  }
  else {
    while (origin->exception_origin != NULL) {
      origin = origin->exception_origin;
    }

    ds = origin;
    while (ds->caller != NULL) {
      ds = ds->caller;
      frame_count++;
    }
  }
  fprintf(file,"%d frames in current stack.\n",frame_count);
  fprintf(file,"=====  Bottom of run-time stack  =====\n");
  while (ds != NULL) {
    se_print_one_frame_in(file,ds);
    /* Next frame : */
    if (ds == origin) {
      ds = NULL;
    }
    else if (ds->exception_origin != NULL) {
      rescue = 1;
      ds = ds->exception_origin;
    }
    else {
      ds2 = se_dst;
      while (ds2->caller != ds) {
	ds2 = ds2->caller;
      }
      ds = ds2;
    }
    if (--frame_count) {
      if (!rescue) {
        fprintf(file,"======================================\n");
      }
      else {
        fprintf(file,"====   Rescue stack  =================\n");
      }
    }
  }
  fprintf(file,"=====   Top of run-time stack    =====\n");

  handle(SE_HANDLE_EXIT_PRINT_STACK, NULL);
}

int se_print_one_frame(se_dump_stack* ds) {
  return se_print_one_frame_in(SE_ERR, ds);
}

int se_print_one_frame_in(FILE* file, se_dump_stack* ds) {
  /* Return 1 for an ordinary frame (not a cecil frame or some dynamic
     dispatch extra frame). */
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;

  if (fd == NULL) {
    fprintf(file,"External CECIL call.\n");
    return 0;
  }
  fprintf(file,"%s\n",fd->name);
  if (ds->p == 0) return 0;
  local_format = fd->local_format;
  if (fd->use_current) {
    fprintf(file,"Current = ");
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    (se_prinT[id])(file, ds->current);
    fprintf(file,"\n");
  }
  while (local_count < fd->local_count) {
    while (local_format[i] != '%') {
      fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (ds->locals == NULL) {
      fprintf(file,"<unavailable>");
    }
    else {
      var = (ds->locals)[local_count];
      if (expanded) {
        (se_prinT[id])(file, (void**)(var));
      }
      else if (*var == NULL) {
        fprintf(file,"Void");
      }
      else {
        (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
      }
    }
    fprintf(file,"\n");
    local_count++;
  }
  fprintf(file,"line %d ",se_position2line(ds->p));
  fflush(file);
  fprintf(file,"column %d ",se_position2column(ds->p));
  fflush(file);
  fprintf(file,"file %s \n",p[se_position2path_id(ds->p)]);
  fflush(file);
  return 1;
}

int se_rci(se_dump_stack*caller,void*C) {
  /* Where `caller' is supposed to be reference type non Void Current
     object. This function return 1 if the class invariant must be
     checked for `C' before leaving the routine.
  */
  if (caller != NULL) {
    se_frame_descriptor* fd = caller->fd;
    if (fd == NULL) {
      /* As for example when coming via CECIL. */
      return 0;
    }
    else {
      if (fd->use_current) {
	if (fd->local_format[1] == 'R') {
	  if ((*((void**)caller->current)) == C) {
	    return 0;
	  }
	}
      }
    }
  }
  return 1;
}

void error0(char* m, char* vv) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  static char*f="*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f,m);
  if (vv!=NULL) fprintf(SE_ERR,f,vv);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,0);
#else
  handle(SE_HANDLE_RUNTIME_ERROR, m);
  se_print_run_time_stack();
  fprintf(SE_ERR,f,m);
  if (vv!=NULL)
    fprintf(SE_ERR,f,vv);
  exit(EXIT_FAILURE);
#endif
}

void error1(char*m,se_position position) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  int l = se_position2line(position);
  int c = se_position2column(position);
  int f = se_position2path_id(position);
  char* f1 = "Line : %d column %d in %s.\n";
  char* f2 = "*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,position);
#else
  handle(SE_HANDLE_RUNTIME_ERROR, m);
  se_print_run_time_stack();
  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
  exit(EXIT_FAILURE);
#endif
}

void se_print_string(FILE*stream, EIF_STRING s) {
  /* To print some Eiffel STRING. */
  if (s == NULL) {
    fprintf(stream,"Void");
  }
  else {
    int count = s->_count;
    EIF_CHARACTER* storage = s->_storage;
    int i = 0;
    fprintf(stream,"\"");
    while (count != 0) {
      fprintf(stream,"%c",storage[i]);
      i++;
      count--;
    }
    fprintf(stream,"\"");
  }
}

void se_print_bad_target(FILE*stream, int id, T0* o, int l, int c, int f) {
  /* Print Bad Target Type Error Message. */
  if (l != 0) {
    fprintf(stream,"Line : %d column %d in %s.\n",l,c,p[f]);
  }
  fprintf(stream,"*** Error at Run Time *** :\n");
  fprintf(stream,"   Target is not valid (not the good type).\n");
  fprintf(stream,"   Expected: ");
  se_print_string(stream,t[id]);
  fprintf(stream,", Actual: ");
  se_print_string(stream,t[o->id]);
  fprintf(stream,".\n");
}

void error2(T0*o, se_position position) {
  fprintf(SE_ERR,"Target Type ");
  se_print_string(SE_ERR,t[o->id]);
  fprintf(SE_ERR," is not valid.\n");
  error1("Bad target.",position);
}

T0* vc(T0* o, se_position position) {
  /*
    Void check for reference target.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Void_call_target);
#else
    error1("Call with a Void target.",position);
#endif
    return NULL;
  }
}

T0* se_string_inspect_check(T0* o, se_position position) {
  /*
    Void check for expression of type STRING in inspect.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Incorrect_inspect_value);
#else
    error1("Expression just after \"inspect\" is Void.",position);
#endif
    return NULL;
  }
}

T0* ci(int id, T0* o, se_position position) {
  /*
    Check Id for reference target.
  */
  if ( vc(o,position) != NULL) {
    if ( id == (o->id) ) {
      return o;
    }
    else {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(System_level_type_error);
#else
      int l = se_position2line(position);
      int c = se_position2column(position);
      int f = se_position2path_id(position);

      se_print_bad_target(SE_ERR,id,o,l,c,f);
      se_print_run_time_stack();
      se_print_bad_target(SE_ERR,id,o,l,c,f);
#ifdef SE_SEDB
      sedb_break(se_dst,0);
#else
      exit(EXIT_FAILURE);
#endif
#endif
    }
  }
  return o;
}

void ac_req(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Precondition);
#else
    error0("Require Assertion Violated.",vv);
#endif
  }
}

void ac_ens(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Postcondition);
#else
    error0("Ensure Assertion Violated.",vv);
#endif
  }
}

void ac_inv(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Class_invariant);
#else
    error0("Class Invariant Violation.",vv);
#endif
  }
}

void ac_liv(int v,char*vv) {
  /* Assertion Check : Loop Invariant check. */
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_invariant);
#else
    error0("Loop Invariant Violation.",vv);
#endif
  }
}

int ac_lvc(int lc,int lv1,int lv2) {
  /* Assertion Check : Loop Variant check. */
  if (lc == 0) {
    if (lv2 < 0) {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(Loop_variant);
#else
      {
	char msg [64];
	sprintf(msg,"Bad First Variant Value = %d\n",lv2);
	error0(msg,NULL);
      }
#endif
    }
    else {
      return lv2;
    }
  }
  else if ((lv2 < 0) || (lv2 >= lv1)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_variant);
#else
    {
      char msg [512];
      sprintf(msg,
	      "Bad loop variant.\nLoop body counter = %d (done)\n"
	      "Previous Variant = %d\nNew Variant = %d\n",
	      lc,lv1,lv2);
      error0(msg,NULL);
    }
#endif
  }
  return lv2;
}

void ac_civ(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Check_instruction);
#else
    error0("Check Assertion Violated.",vv);
#endif
  }
}

T0* se_evobt(T0* o, se_position position) {
    /*
      Error Void Or Bad Type.
    */
    if (!o) {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(Void_call_target);
#else
	error1("Target is Void.",position);
#endif
    }
    else {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(System_level_type_error);
#else
	error2(o,position);
#endif
    }
    return o; /* Dummy return to avoid C warnings. */
}

void se_signal_handler(int sig) {
  printf("Received signal %d.\n",sig);
#ifdef SE_SEDB
  signal(sig,se_signal_handler);
  sedb_signal_handler(sig);
#else
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

void se_gc_check_id(void*o,int id) {
  if (id != (((T0*)o)->id)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#else
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    se_print_run_time_stack();
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    exit(EXIT_FAILURE);
#endif
  }
}

se_dump_stack* se_new_dump_stack(se_dump_stack* copy) {
  se_dump_stack* result = NULL;
  se_frame_descriptor* fd;
  int i, j, o, p, n;
  int local_count;
  char* local_format;
  int id;
  void** var;
  int local_size;
  int expanded;

  void*** _i;
  void** _ref;
  char*  _exp;

  if (copy != NULL) {
    fd = copy->fd;
    result = (se_dump_stack*)se_malloc(sizeof(se_dump_stack));
    if (result != NULL) {
      result->fd               = fd;
      result->p                = copy->p;
      result->caller           = copy->caller;
      result->current          = NULL;
      result->locals           = NULL;
      result->exception_origin = NULL;

      if (fd != NULL) {
	local_format = fd->local_format;
	i = 0;
	if (fd->use_current) {
	  result->current = copy->current;
	  /* Place i after the Current definition: */
	  i = 2;
	  id = 0;
	  while (local_format[i] != '%') {
	    id = (id * 10) + (local_format[i++] - '0');
	  }
	  i++;
	}

	/*
	 *
	 * p: sum of the number of pointers ("indirections") per local
	 *    -> 1 for an expanded
	 *    -> 2 for a reference
	 *
	 * o: total malloc'ed size
	 *
	 * _i: access to the first indirection pointer
	 *
	 * _ref: access to the second indirection pointer of a reference object
	 *       _ref == (T0*)(*_i)
	 *
	 * _exp: access to a copy of the expanded object
	 *       _exp == *((char*)_i)
	 *
	 *
	 *
	 * For instance, if "0" is the first local, a reference and "4" is the
	 * second local, an expanded type (say, a 6-byte structure noted
	 * "XXXXXXXXXXX", with 64-bit padding "/"):
	 *
	 *
	 *
	 * result->locals
	 *       |                ------------
	 *       |               |            |
	 *       |    -----------|------------v--------------
	 *        -->| | | | |===+===|===+===|XXXXXXXXXXX|/|/|
	 *           |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|0|1|2|3|
	 *           |===+===| | | | |===+===| | | | | | | | |
	 *            ---|------------^--|-------------------
	 *               |            |  |
	 *                ------------    --------------------------> object
	 *
	 *           |-> _i          |-> _ref         _exp <-|
	 *
	 *
	 *
	 * Note: Those "|->" denote the start value and way of
	 *       progression of the pointers
	 *
	 *
	 * result->locals is defined as a (void***) but its real "type" depends on
	 * which element is accessed (as in the live stack; but in the live stack,
	 * only the first indirection is in the struct; the remaining data is on
	 * the native stack).
	 *
	 */

	if (copy->locals != NULL) {
	  j = i;

	  local_count = local_size = p = o = 0;

	  while (local_count < fd->local_count) {
	    while (local_format[i++] != '%');
	    expanded = ((local_format[i++] == 'E')?1:0);
	    id = 0;
	    while (local_format[i] != '%') {
	      id = (id * 10) + (local_format[i++] - '0');
	    }
	    i++;
	    if (expanded) {
	      p++;
	      o = se_strucT[id];
	      o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
	      local_size += o;
	    }
	    else {
	      p+=2;
	    }
	    local_count++;
	  }

	  o = p * sizeof(void*) + local_size;
	  result->locals = (void***)se_malloc(o);
	  _i   = result->locals;
	  _exp = (char*)_i + o;
	  _ref = (void**)_i + local_count;

	  i = j;
	  local_count = 0;
	  while (local_count < fd->local_count) {
	    while (local_format[i++] != '%');
	    expanded = ((local_format[i++] == 'E')?1:0);
	    id = 0;
	    while (local_format[i] != '%') {
	      id = (id * 10) + (local_format[i++] - '0');
	    }
	    i++;
	    var = (copy->locals)[local_count];
	    if (expanded) {
	      o = n = se_strucT[id];
	      o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
	      _exp -= o;
	      *(char**)_i = _exp;
	      memset(_exp, 0, o);
	      memcpy(_exp, var, n);
	    }
	    else {
	      *_i = _ref;
	      *_ref = *var;
	      _ref++;
	    }
	    local_count++;
	    _i++;
	  }
	}
      }
    }
  }
  return result;
}

void se_delete_dump_stack(se_dump_stack* ds) {
  if (ds != NULL) {
    if (ds->locals != NULL) free(ds->locals);
    free(ds);
  }
}


void se_print_locals_in(FILE* file, se_dump_stack* ds, int enter) {
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;
  int printed = 0;
  int display;

  if (ds->p == 0) return;
  local_format = fd->local_format;
  if (fd->use_current) {
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      i++;
    }
    i++;
  }
  while (local_count < fd->local_count) {
    display = (strncmp(local_format+i, "Result%", 7)==0) != enter;
    if (display) {
      if (printed)
	fprintf(file,", ");
      else
	fprintf(file,"(");
      printed++;
    }
    
    while (local_format[i] != '%') {
      if (display) fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    if (display) fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (display) {
      if (ds->locals == NULL) {
	fprintf(file,"<unavailable>");
      }
      else {
	var = (ds->locals)[local_count];
	if (expanded) {
	  (se_prinT[id])(file, (void**)(var));
	}
	else if (*var == NULL) {
	  fprintf(file,"Void");
	}
	else {
	  (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
	}
      }
    }
    local_count++;
  }
  if (printed)
    fprintf(file,")\n");
  else
    fprintf(file,"\n");

}

#ifdef SE_TRACE
static int se_call_depth=0;

void se_print_call_trace(se_dump_stack *ds) {
  int i;
  if (ds) {
    int enter = ds->caller == se_dst;
    
    if (enter)
      se_call_depth++;

    if (se_call_depth < 0)
      se_call_depth=0;

    for(i=se_call_depth<<1; i; i--)
      putchar(' ');

    if (enter) {
      printf("enter ");
      printf("%s", ds->fd->name);
      se_print_locals_in(stdout, ds, 1);
    } else {
      if (se_dst) {
	printf("leave ");
	printf("%s", se_dst->fd->name);
	se_print_locals_in(stdout, se_dst, 0);
	se_call_depth--;
      }
    }
  } else {
    for(i=se_call_depth<<1; i; i--)
      putchar(' ');
    printf("leave ");
    printf("%s", se_dst->fd->name);
    se_print_locals_in(stdout, se_dst, 0);
    se_call_depth--;
  }
}
#endif
/*
-- ------------------------------------------------------------------------------------------------------------
-- Copyright notice below. Please read.
--
-- Copyright(C) 1994-2002: INRIA - LORIA (INRIA Lorraine) - ESIAL U.H.P.       - University of Nancy 1 - FRANCE
-- Copyright(C) 2003-2005: INRIA - LORIA (INRIA Lorraine) - I.U.T. Charlemagne - University of Nancy 2 - FRANCE
--
-- Authors: Dominique COLNET, Philippe RIBET, Cyril ADRIAN, Vincent CROIZIER, Frederic MERIZEN
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
-- documentation files (the "Software"), to deal in the Software without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
-- conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial
-- portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
-- LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
-- EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-- AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
-- http://SmartEiffel.loria.fr - SmartEiffel@loria.fr
-- ------------------------------------------------------------------------------------------------------------
*/

/*
   This file (SmartEiffel/sys/runtime/gc_lib.c) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has been
   selected).
*/
/*
   The `mark_stack_and_registers' C function is called by the Garbage
   Collector (GC) of SmartEiffel. It has to be customized for some systems,
   but also for some C compilers. This file provides some definitions in the
   end and has to be completed for systems which need specific work.

   On some architectures, addresses increase as the stack grows; or,
   conversely, addresses decrease as the stack grows. A C compiler may be
   clever enough to hide some root object inside registers. Unfortunately all
   registers are not always accessible via the C `setjmp' function!

   Thus, in order to be able to use the GC on your architecture/C-compiler,
   you have to provide the correct `mark_stack_and_registers' function.

   What is the `mark_stack_and_registers' function supposed to do?  The
   `mark_stack_and_registers' function is supposed to notify the GC with all
   the possible roots one can find in the C stack and registers by calling the
   `gc_mark' function. A root is an object which must not be collected.  The
   SmartEiffel GC already knows about some root objects like once function
   results or manifest strings. The `mark_stack_and_registers' function has to
   notify the other possible roots. Obviously, one can find in the C stack any
   kind of adresses, but the `gc_mark' function is clever enough to determine
   if the passed pointer is an Eiffel object or not.  When the passed pointer
   reaches some Eiffel object, this object as well as its descendant(s) are
   automatically marked as un-collectable.

   In order to provide the most appropriate `mark_stack_and_registers'
   function, the very first question is to know about the way the C stack is
   managed (addresses of the stack may increase or decrease as the C stack
   grows). The DEFAULT BEHAVIOUR FOR UNKNOWN SYSTEMS is to consider ADDRESSES
   DECREASE AS THE STACK GROWS, as it's the most common case.  The global C
   variable `stack_bottom' is set with some pointer which is supposed to be
   the bottom of the stack (this variable is automatically initialized in the
   C main function).  Note: using the current stack pointer inside
   `mark_stack_and_registers', it is quite obvious to determine if addresses
   increase or not as the C stack grows.  Note2: on some systems, the stack is
   not in contiguous addresses. In such case, `mark_stack_and_registers' has
   to go through all the stack fragments.

   Some roots may be stored only in registers and not in the C stack.  In
   order to reach the registers as well, the first attempt is to use setjmp,
   in the hope that setjmp will save registers in the stack!  Note: this
   technique do not work on processors using windows registers (such as sparc
   processors).

*/

int se_gc_strategy = SE_GC_DEFAULT_MEMORY_STRATEGY;

int collector_counter = 0;

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom=NULL;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

/* Return the index where chunk `c' is (or is to be) in the `gcmt', 
   between `min' and `max' indexes. */
static unsigned int binary_search_in_gcmt(register unsigned int min, 
					  register unsigned int max, 
					  register mch* c){
  register unsigned int mid;
  while (min<max){
    mid=(min+max)>>1;
    if (gcmt[mid]<c)
      min=mid+1;
    else
      max=mid;
  }
  if (gcmt[min]<c)
    return min+1;
  else
    return min;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List)
     in some circumstances.
  */
  rsoc* next; register rsoc *current;
  unsigned int count = rsocfl_count();
  register unsigned int where = gcmt_used;
  register unsigned int how_many;

  if ((count > 50) && (count > (rsoc_count >> 1))) {
    current=rsocfl;
    rsocfl=NULL;
    while (NULL != current) {
      next=current->next;
      if (current->isize == current->header.size) {
	where = binary_search_in_gcmt(0, where-1, (mch*)current);
	how_many = gcmt_used - 1 - where;
	if (how_many > 0)
	  memmove(gcmt+where, gcmt+where+1, how_many*sizeof(mch*));
	free(current); gcmt_used--; rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

int gc_memory_used(void) {
  int i;
  int result = 0;
  mch* mch;
  for (i = gcmt_used; i --> 0; ) {
    mch = gcmt[i];
    switch(mch->state_type) {
    case RSO_USED_CHUNK:
    case FSO_USED_CHUNK:
    case FSO_STORE_CHUNK:
      result += mch->size;
      break;
    default:
      break;
    }
  }
  return result;
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if ( (((rsoc*)*p1)->isize==0) && ((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

/* return the mch containing p or NULL if p is not 
 * a valid address or was externally allocated 
 */
mch * gc_find_chunk(void * p){
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if((char*)p<(char*)c+c->size)   /* check for upper bound */
      if (!(FREE_CHUNK(c->state_type))){
	return c;
      }
  }
  return NULL;
}

void gc_mark(void*p) {
  mch * c;
  c = gc_find_chunk(p);
  if(NULL != c) {
    (c->amfp)(c,p);
  }
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10))

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  /* This function is automatically called after each collection
     cycle.
  */
  if (se_gc_strategy == SE_GC_LOW_MEMORY_STRATEGY) {
    fsoc_count_ceil = fsoc_count;
    rsoc_count_ceil = rsoc_count;
    /* Todo: we should also consider to free unused chunks here. */
    return;
  }
  if (se_gc_strategy == SE_GC_HIGH_MEMORY_STRATEGY) {
    fsoc_count_ceil = (256 + fsoc_count) << 2;
    rsoc_count_ceil = (256 + rsoc_count) << 2;
    return;
  }
  /* The SE_GC_DEFAULT_MEMORY_STRATEGY. */
  /* Compute fsoc_count_ceil: */

  /* The lines commented out with --perf-- were killing performance under certain circumstances, *
   * especially with gcc -O3 <FM-15/04/2005>                                                     */

  /* --perf-- if (fsocfl == NULL) { */
  if (fsoc_count >= fsoc_count_ceil) {
    if (fsoc_count_ceil < FSOC_LIMIT) {
      fsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = fsoc_count + (fsoc_count/3);
      if (fsoc_count_ceil < c)
	fsoc_count_ceil = c;
    }
  }
  /* --perf-- }
     else {
     if (fsoc_count_ceil < fsoc_count) {
     fsoc_count_ceil = fsoc_count;
     }
     }
  */
  /* Compute rsoc_count_ceil: */
  /* --perf-- if (rsocfl == NULL) {*/
  if (rsoc_count >= rsoc_count_ceil) {
    if (rsoc_count_ceil < RSOC_LIMIT) {
      rsoc_count_ceil <<= 1;
    }
    else {
      unsigned int c = rsoc_count + (rsoc_count / 3);
      if (rsoc_count_ceil < c) {
	rsoc_count_ceil = c;
      }
    }
  }
  /* --perf -- }
     else {
     if (rsoc_count_ceil < rsoc_count) {
     rsoc_count_ceil = rsoc_count;
     }
     }
  */
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the
     new `mch' (Memory Chunk Header).`gcmt_used' is updated.
  */
  unsigned int where=0;
  unsigned how_many;
  if (gcmt_used>0){
    where=binary_search_in_gcmt(0, gcmt_used-1, c);
    if (gcmt_used == gcmt_max) {
      gcmt_max <<= 1;
      gcmt = ((mch**)(se_realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
    }
    how_many = gcmt_used - where;
    if (how_many > 0)    
      memmove(gcmt+where+1, gcmt+where, how_many*sizeof(mch*));
  }
  gcmt[where]=c;
  gcmt_used++;
}

static char*rso_from_store(na_env*nae,unsigned int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	/* No need to register chunks with no free_list_of_large
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	*/
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >=
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0;
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

/* *** To be removed */
#ifdef __TINYC__
static rsoc MRSOC = {
#else
static const rsoc MRSOC = {
#endif
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(unsigned int size) {
  register unsigned int best_size = 0;
  unsigned int acceptable_loss;
  register rsoc *pc, *best_pc, *best_c, *c;
  if (NULL==rsocfl)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  if (SE_GC_DEFAULT_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = (size >> 4);
  else if (SE_GC_LOW_MEMORY_STRATEGY == se_gc_strategy)
    acceptable_loss = 0;
  else /* SE_GC_HIGH_MEMORY_STRATEGY == se_gc_strategy */
    acceptable_loss = (size >> 2);

  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (NULL != best_pc)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  if ((best_size - size) > acceptable_loss){
    do {
      if ((c->header.size >= size) && (c->header.size < best_size)) {
	best_c = c;
	best_pc = pc;
	best_size = c->header.size;
	if ((best_size - size) <= acceptable_loss) break;
      }
      pc=c;
      c=c->next;
    }
    while(NULL!=c);
  }
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,unsigned int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,unsigned int size) {
  rsoc*c=nae->chunk_list;
  unsigned int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if (c->header.size > RSOC_SIZE) {
      if (c->header.size-csize > RSOC_MIN_STORE*4) {
	int csize_left=c->header.size-csize;
	if ((csize_left%sizeof(double))!=0) {
	  csize_left-=(csize_left%sizeof(double));
	  csize=c->header.size-csize_left;
	}
	c->header.size=csize_left;
	c->next=rsocfl;
	rsocfl=c;
	c=(rsoc*)(((char*)c)+csize_left);
	c->isize=0; /* c split from a larger chunk */
	gc_add_into_gcmt((mch*)c);      
	c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
	c->header.swfp=(void(*)(mch*))rsoc_sweep;
      }
      /* since objects bigger than RSOC_SIZE must be the only object in their chunk, we do not want to have
	 some store left after them. Therefore, we do not set csize to c->header.size in an else block
	 here. */
      c->header.size=csize;
    }
    else {
      csize=c->header.size;
    }
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    return rso_from_store(nae,size);
  }
  return NULL;
}

/* size in bytes, including header size */
char*new_na(na_env*nae,unsigned int size) {
  if (size == 0) {
#ifdef SE_BOOST
    handle(SE_HANDLE_RUNTIME_ERROR, NULL);
    se_print_run_time_stack();
    exit(EXIT_FAILURE);
#else
    char msg[512];
    sprintf(msg, "Bad native array size: %d.\n", size);
    error0(msg, NULL);
#endif
  }
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      unsigned int rounded_size= chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      /* No need to register chunks with no free_list_of_large
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      */
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    unsigned int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    /* No need to register chunks with no free_list_of_large
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    */
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);

  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  }
}

unsigned int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  register unsigned int r=0;
  register rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

unsigned int fsocfl_count(void) {
  register unsigned int r=0;
  register fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;

  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) ||
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not
     yet reached. Otherwise, call the `gc_start()' function and
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a
     new `fsoc' (using the `se_malloc' function). Update various ceils
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    fsoc_count++;
    gc_update_ceils();
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

#if defined(__sparc__) || defined(sparc) || defined(__sparc)
/* For SPARC architecture.
   As this part contains assembly code (asm), you must not use
   the flag -ansi of gcc compiler.
*/

void mark_loop(void) {
  void** max = stack_bottom;
  void** stack_pointer;
  void* stack_top[2]={NULL,NULL};
  stack_pointer = stack_top;
  /* Addresses decrease as the stack grows. */
  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}

void mark_stack_and_registers(void) {
#  if defined(__sparcv9)
  asm(" flushw");
#  else
  asm(" ta      0x3   ! ST_FLUSH_WINDOWS");
#  endif
  mark_loop();
}

#elif defined(__ELATE__) || defined(ELATE)
/* GNU Eiffel's VP (Virtual Processor) garbage collector for Elate.
   (c) 2000 Rudi Chiarito <rudi@amiga.com>

   Thanks to Andy Stout and Kevin Croombs at Tao Group for their
   precious help!

   ChangeLog:
   - 2000-06-12 Rudi Chiarito <rudi@amiga.com>
     * Version 1.0
   - 2001-01-01 Joseph Kiniry <kiniry@acm.org>
     * Integrated with new SE 0.75b
   - 2001-08-10 Rudi Chiarito <rudi@amiga.com>
     * Inlined and optimised range marking
     * Added some more comments
     * Added conditional breakpoint in mark_stack_and_registers
   - 2002-09-21 Rudi Chiarito <rudi@amiga.com>
     * Removed redundant 'ret'
*/

__inline__ void mark_stack_and_registers(void)
{

  void *pointer_to_gc_mark = &gc_mark;

  __asm__ __volatile__
  (
    /*
      WARNING: funky code ahead!
      \t and \n are needed to make the final output easier to read
      while debugging. Hopefully you'll never have to bother with all
      of this.

      Registers:
        p0  pointer to stack block
        p1  pointer to gc_mark()
        p2  scratch pointer
        i0  length of current stack block
        i1  scratch register
    */

#  ifdef __ELATE_SE_DEBUG_GC
   "\tqcall sys/cii/breakpt,(-:-)\n"
#  endif

   "\tsync\n"                          /* spill all the registers */
   "\tsyncreg\n"                       /* to the stack */

   "\tcpy.p %0,p1\n"                   /* pointer to gc_mark() */

   /* pointer to the current stack block */
   "\tcpy.p [gp+PROC_STACK],p0\n"

   /* point to last location in the block, before the descriptor */
   "\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

   /* mark the contents of the current stack block */
   "\twhile p2>=sp\n"
      "\t\tgos p1,(p2 : -)\n"
      "\t\tsub.p 4,p2\n"
   "\tendwhile\n"

   /* now scan other blocks (if any) */

   "\tloop\n"
      "\t\tcpy.p [p0 - STK_SIZE + STK_LINK],p0\n" /* get next block */
      "\t\tbreakif p0=NULL\n"

      /* point to last location in the block, before the descriptor */
      "\t\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

      /* mark this block */
      "\t\twhile p2>=p0\n"

         "\t\t\tgos p1,(p2 : -)\n"
         "\t\t\tsub.p 4,p2\n"
      "\t\tendwhile\n"
   "\tendloop\n"

   : /* no output */
   : "p" (pointer_to_gc_mark)
   : "p0", "p1", "p2", "i0" 
   );
}

#elif defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)

/****************************************************************************
 * Generic code for architectures where addresses increase as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers) + ((sizeof(JMP_BUF)/sizeof(void*))-1);
  /* stack_pointer will traverse the JMP_BUF as well (jmp_buf size is added, 
     otherwise stack_pointer would be below the registers structure). */

#  if !defined(SE_BOOST)
  if (stack_pointer < max) {
    fprintf(stderr, "Wrong stack direction: your stack decrease as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer >= max) {
    gc_mark(*(stack_pointer--));
  }
}
#else

/****************************************************************************
 * Generic code for architectures where addresses decrease as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(void*)(&registers);

#  if !defined(SE_BOOST)
  if (stack_pointer > max) {
    fprintf(stderr, "Wrong stack direction: the stack addresses increase as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}
#endif

unsigned int fsoc_count_ceil=88;
unsigned int rsoc_count_ceil=15;

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/T0* r194item(se_dump_stack*caller,T194 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]",1,2,"%E194%index%E2%Result%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C02504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C02914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/void r194put(se_dump_stack*caller,T194 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]",1,2,"%E194%element%R190%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C02D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C03214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C03508/*l53c4/native_array.e*/;
ac_ens((r194item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/T6 r194all_default(se_dump_stack*caller,T194 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]",1,4,"%E194%upper%E2%Result%E6%i%E2%v%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C2CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C2D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x08C2D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x08C2D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x08C2D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x08C2D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x08C2DA0A/*l730c5/native_array.e*/;
_v=r194item(&ds,C,_i);
ds.p=0x08C2DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x08C2DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x08C2DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x08C2DC20/*l732c16/native_array.e*/);
}
R=((T6)(r190is_default(&ds,((T190*)_v))));
}
ds.p=0x08C2DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/void r194clear_all(se_dump_stack*caller,T194 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]",1,3,"%E194%upper%E2%v%R190%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C20A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C20D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x08C2120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x08C2140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08C2160A/*l534c5/native_array.e*/;
r194put(&ds,C,_v,_i);
ds.p=0x08C2170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C21A08/*l538c4/native_array.e*/;
ac_ens(r194all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/T194 r194calloc(se_dump_stack*caller,T194 C,T2 a1){
T194 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]",1,2,"%E194%nb_elements%E2%Result%E194%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C01B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C01F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new194(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C02216/*l34c11/native_array.e*/;
ac_ens(r194all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/void r193set_item(se_dump_stack*caller,T193* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"set_item"" WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]]",1,1,"%R193%i%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11401A04/*l26c2/weak_reference.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11401D08/*l29c4/weak_reference.e*/;
/*SFN*/(C->_item/*ip*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11401F08/*l31c4/weak_reference.e*/;
ac_ens(((/*RF2*/(C)->_item/*ip*/))==((void*)(a1)),"item = i");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/T6 r192is_default(se_dump_stack*caller,T192* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default"" HASHED_DICTIONARY_NODE[POINTER,STRING]",1,1,"%R192%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A08404/*l132c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x01A08D08/*l141c4/any.e*/;
R=((T6)((C)==((void*)(r192default(&ds,C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/T0* r192default(se_dump_stack*caller,T192* C){
T0* R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"default"" HASHED_DICTIONARY_NODE[POINTER,STRING]",1,1,"%R192%Result%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A07D12/*l125c9/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/void r192make(se_dump_stack*caller,T192* C,T8 a1,T0* a2,T0* a3){
void**locals[3];
static se_frame_descriptor fd={"make"" HASHED_DICTIONARY_NODE[POINTER,STRING]",1,3,"%R192%i%E8%k%R7%n%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11002404/*l36c2/hashed_dictionary_node.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11002608/*l38c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_item/*i3p*/)=a1;
ds.p=0x11002708/*l39c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_key/*i3p*/)=a2;
ds.p=0x11002808/*l40c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_next/*i3p*/)=a3;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11002A08/*l42c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_item/*i3p*/))==(a1),"item = i");
ds.p=0x11002B08/*l43c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_key/*i3p*/))==((void*)(a2)),"key = k");
ds.p=0x11002C08/*l44c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_next/*i3p*/))==((void*)(a3)),"next = n");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY_NODE[POINTER,STRING]*/void r192set_next(se_dump_stack*caller,T192* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"set_next"" HASHED_DICTIONARY_NODE[POINTER,STRING]",1,1,"%R192%n%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11001D04/*l29c2/hashed_dictionary_node.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11001F08/*l31c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_next/*i3p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11002108/*l33c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_next/*i3p*/))==((void*)(a1)),"next = n");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/T0* r191item(se_dump_stack*caller,T191 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]",1,2,"%E191%index%E2%Result%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C02504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C02914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/void r191put(se_dump_stack*caller,T191 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]",1,2,"%E191%element%R192%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C02D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C03214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C03508/*l53c4/native_array.e*/;
ac_ens((r191item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/T6 r191all_default(se_dump_stack*caller,T191 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]",1,4,"%E191%upper%E2%Result%E6%i%E2%v%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C2CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C2D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x08C2D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x08C2D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x08C2D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x08C2D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x08C2DA0A/*l730c5/native_array.e*/;
_v=r191item(&ds,C,_i);
ds.p=0x08C2DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x08C2DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x08C2DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x08C2DC20/*l732c16/native_array.e*/);
}
R=((T6)(r192is_default(&ds,((T192*)_v))));
}
ds.p=0x08C2DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/void r191clear_all(se_dump_stack*caller,T191 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]",1,3,"%E191%upper%E2%v%R192%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C20A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C20D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x08C2120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x08C2140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08C2160A/*l534c5/native_array.e*/;
r191put(&ds,C,_v,_i);
ds.p=0x08C2170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C21A08/*l538c4/native_array.e*/;
ac_ens(r191all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/T191 r191calloc(se_dump_stack*caller,T191 C,T2 a1){
T191 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[POINTER,STRING]]",1,2,"%E191%nb_elements%E2%Result%E191%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C01B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C01F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new191(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C02216/*l34c11/native_array.e*/;
ac_ens(r191all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r190is_default(se_dump_stack*caller,T190* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default"" HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,1,"%R190%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A08404/*l132c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x01A08D08/*l141c4/any.e*/;
R=((T6)((C)==((void*)(r190default(&ds,C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r190default(se_dump_stack*caller,T190* C){
T0* R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"default"" HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,1,"%R190%Result%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A07D12/*l125c9/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r190make(se_dump_stack*caller,T190* C,T0* a1,T0* a2,T0* a3){
void**locals[3];
static se_frame_descriptor fd={"make"" HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,3,"%R190%i%R186%k%R7%n%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11002404/*l36c2/hashed_dictionary_node.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11002608/*l38c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_item/*i3p*/)=a1;
ds.p=0x11002708/*l39c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_key/*i3p*/)=a2;
ds.p=0x11002808/*l40c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_next/*i3p*/)=a3;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11002A08/*l42c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_item/*i3p*/))==((void*)(a1)),"item = i");
ds.p=0x11002B08/*l43c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_key/*i3p*/))==((void*)(a2)),"key = k");
ds.p=0x11002C08/*l44c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_next/*i3p*/))==((void*)(a3)),"next = n");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r190set_next(se_dump_stack*caller,T190* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"set_next"" HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,1,"%R190%n%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11001D04/*l29c2/hashed_dictionary_node.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11001F08/*l31c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_next/*i3p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11002108/*l33c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_next/*i3p*/))==((void*)(a1)),"next = n");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]*/void r189set_item(se_dump_stack*caller,T189* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"set_item"" WEAK_REFERENCE[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]]",1,1,"%R189%i%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11401A04/*l26c2/weak_reference.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11401D08/*l29c4/weak_reference.e*/;
/*SFN*/(C->_item/*ip*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11401F08/*l31c4/weak_reference.e*/;
ac_ens(((/*RF2*/(C)->_item/*ip*/))==((void*)(a1)),"item = i");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188new_node(se_dump_stack*caller,T188* C,T0* a1,T0* a2,T0* a3){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"new_node"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,4,"%R188%v%R186%k%R7%next%R190%Result%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F422404/*l548c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
locals[3]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F422708/*l551c4/hashed_dictionary.e*/;
if(((/*RF2*/(C)->_free_nodes/*i7p*/))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F42271C/*l551c14/hashed_dictionary.e*/);
}
if(((((/*RF2*/(C)->_free_nodes/*i7p*/))->id))!=(INT16_C(189))){
error1("Bad target type. The expected type is WEAK_REFERENCE[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]].",0x0F42271C/*l551c14/hashed_dictionary.e*/);
}
R=(/*RF2*/((T189*)((/*RF2*/(C)->_free_nodes/*i7p*/)))->_item/*ip*/);
ds.p=0x0F42280E/*l552c7/hashed_dictionary.e*/;
if((R)==((void*)((void*)0))){
ds.p=0x0F422930/*l553c24/hashed_dictionary.e*/;
tmp0/*new*/=((T0*)(new190()));
r190make(&ds,((T190*)tmp0/*new*/),a1,a2,a3);
R=tmp0/*new*/;
/*tmp0.unlock*/
}
else{
ds.p=0x0F422B20/*l555c16/hashed_dictionary.e*/;
if(((/*RF2*/(C)->_free_nodes/*i7p*/))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F422B0A/*l555c5/hashed_dictionary.e*/);
}
if(((((/*RF2*/(C)->_free_nodes/*i7p*/))->id))!=(INT16_C(189))){
error1("Bad target type. The expected type is WEAK_REFERENCE[HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]].",0x0F422B0A/*l555c5/hashed_dictionary.e*/);
}
ds.p=0x0F422B40/*l555c32/hashed_dictionary.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F422B32/*l555c25/hashed_dictionary.e*/);
}
if((((R)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F422B32/*l555c25/hashed_dictionary.e*/);
}
r189set_item(&ds,(T189*)((/*RF2*/(C)->_free_nodes/*i7p*/)),(/*RF2*/(((T190*)R))->_next/*i3p*/));
ds.p=0x0F422C18/*l556c12/hashed_dictionary.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F422C0A/*l556c5/hashed_dictionary.e*/);
}
if((((R)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F422C0A/*l556c5/hashed_dictionary.e*/);
}
ds.p=0x0F422C22/*l556c17/hashed_dictionary.e*/;
r190make(&ds,((T190*)R),a1,a2,a3);
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r188special_common_dictionary(se_dump_stack*caller,T188* C,T0* a1){
T2 _new_capacity=0;
void**locals[2];
static se_frame_descriptor fd={"special_common_dictionary"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,2,"%R188%fn%R189%new_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F425B04/*l603c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F425E08/*l606c4/hashed_dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"fn /= Void");
fd.assertion_flag=1;
}
ds.p=0x0F426508/*l613c4/hashed_dictionary.e*/;
_new_capacity=/*RF1Default_size*/INT32_C(53);
ds.p=0x0F426608/*l614c4/hashed_dictionary.e*/;
/*SFN*/(C->_buckets/*i7p*/)=r194calloc(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_new_capacity);
ds.p=0x0F426708/*l615c4/hashed_dictionary.e*/;
/*SFN*/(C->_capacity/*i7p*/)=_new_capacity;
ds.p=0x0F426808/*l616c4/hashed_dictionary.e*/;
/*SFN*/(C->_cache_user/*i7p*/)=/*IC*/(T2)(INT8_C(-1));
ds.p=0x0F426908/*l617c4/hashed_dictionary.e*/;
/*SFN*/(C->_count/*i7p*/)=/*IC*/(T2)(INT8_C(0));
ds.p=0x0F426A08/*l618c4/hashed_dictionary.e*/;
/*SFN*/(C->_free_nodes/*i7p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F426F08/*l623c4/hashed_dictionary.e*/;
ac_ens(((/*RF2*/(C)->_count/*i7p*/))==(INT8_C(0)),"count = 0");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r188increase_capacity(se_dump_stack*caller,T188* C){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
T2 tmp1;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
T2 _idx=0;
T2 _new_capacity=0;
T194 _old_buckets=(void*)0;
T0* _node1=(void*)0;
T0* _node2=(void*)0;
void**locals[6];
static se_frame_descriptor fd={"increase_capacity"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,6,"%R188%i%E2%idx%E2%new_capacity%E2%old_buckets%E194%node1%R190%node2%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F41AF04/*l431c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_i;
locals[1]=(void**)&_idx;
locals[2]=(void**)&_new_capacity;
locals[3]=(void**)&_old_buckets;
locals[4]=(void**)&_node1;
locals[5]=(void**)&_node2;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F41CE20/*l462c16/hashed_dictionary.e*/;
tmp0/*old*/=(/*RF2*/(C)->_count/*i7p*/);
ds.p=0x0F41CF26/*l463c19/hashed_dictionary.e*/;
tmp1/*old*/=(/*RF2*/(C)->_capacity/*i7p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F41B208/*l434c4/hashed_dictionary.e*/;
ac_req(r188should_increase_capacity(&ds,C,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/)),"should_increase_capacity(capacity, count)");
fd.assertion_flag=1;
}
ds.p=0x0F41B70A/*l439c5/hashed_dictionary.e*/;
_new_capacity=r188prime_capacity(&ds,C,r2_ix_43(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(1))));
ds.p=0x0F41B80A/*l440c5/hashed_dictionary.e*/;
_old_buckets=(/*RF2*/(C)->_buckets/*i7p*/);
ds.p=0x0F41B90A/*l441c5/hashed_dictionary.e*/;
/*SFN*/(C->_buckets/*i7p*/)=r194calloc(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_new_capacity);
ds.p=0x0F41BA0A/*l442c5/hashed_dictionary.e*/;
_i=r2_ix_45(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(1)));
ds.p=0x0F41BB0A/*l443c5/hashed_dictionary.e*/;
/*SFN*/(C->_capacity/*i7p*/)=_new_capacity;
while(1){
ds.p=0x0F41BD0E/*l445c7/hashed_dictionary.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0F41C00C/*l448c6/hashed_dictionary.e*/;
_node1=r194item(&ds,_old_buckets,_i);
while(1){
ds.p=0x0F41C20C/*l450c6/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
break;
}
ds.p=0x0F41C40C/*l452c6/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C41E/*l452c15/hashed_dictionary.e*/);
}
if((((_node1)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F41C41E/*l452c15/hashed_dictionary.e*/);
}
_node2=(/*RF2*/(((T190*)_node1))->_next/*i3p*/);
ds.p=0x0F41C50C/*l453c6/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C51A/*l453c13/hashed_dictionary.e*/);
}
if((((_node1)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F41C51A/*l453c13/hashed_dictionary.e*/);
}
if(((/*RF2*/(((T190*)_node1))->_key/*i3p*/))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C526/*l453c19/hashed_dictionary.e*/);
}
if(((((/*RF2*/(((T190*)_node1))->_key/*i3p*/))->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F41C526/*l453c19/hashed_dictionary.e*/);
}
ds.p=0x0F41C54A/*l453c37/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)((T7*)((/*RF2*/(((T190*)_node1))->_key/*i3p*/)))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F41C618/*l454c12/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C60C/*l454c6/hashed_dictionary.e*/);
}
if((((_node1)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F41C60C/*l454c6/hashed_dictionary.e*/);
}
ds.p=0x0F41C63A/*l454c29/hashed_dictionary.e*/;
r190set_next(&ds,((T190*)_node1),r194item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx));
ds.p=0x0F41C71C/*l455c14/hashed_dictionary.e*/;
r194put(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_node1,_idx);
ds.p=0x0F41C80C/*l456c6/hashed_dictionary.e*/;
_node1=_node2;
}
ds.p=0x0F41CA0A/*l458c5/hashed_dictionary.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
ds.p=0x0F41CC08/*l460c4/hashed_dictionary.e*/;
/*SFN*/(C->_cache_user/*i7p*/)=/*IC*/(T2)(INT8_C(-1));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F41CE08/*l462c4/hashed_dictionary.e*/;
ac_ens(((/*RF2*/(C)->_count/*i7p*/))==(tmp0/*old*/),"count = old count");
ds.p=0x0F41CF1A/*l463c13/hashed_dictionary.e*/;
ac_ens(r2_ix_62(&ds,(/*RF2*/(C)->_capacity/*i7p*/),tmp1/*old*/),"capacity > old capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/void r188add(se_dump_stack*caller,T188* C,T0* a1,T0* a2){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
/*INTERNAL_C_LOCAL list]*/
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"add"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,4,"%R188%v%R186%k%R7%idx%E2%node%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F40C304/*l195c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F808A28/*l138c20/dictionary.e*/;
tmp0/*old*/=(/*RF2*/(C)->_count/*i7p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F808708/*l135c4/dictionary.e*/;
ac_req(r6_px_not(&ds,(T6)(r188has(&ds,C,a2))),"not has(k)");
fd.assertion_flag=1;
}
ds.p=0x0F40C708/*l199c4/hashed_dictionary.e*/;
/*SFN*/(C->_cache_user/*i7p*/)=/*IC*/(T2)(INT8_C(-1));
ds.p=0x0F40C80E/*l200c7/hashed_dictionary.e*/;
if(r188should_increase_capacity(&ds,C,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/))){
ds.p=0x0F40C90A/*l201c5/hashed_dictionary.e*/;
r188increase_capacity(&ds,C);
}
ds.p=0x0F40CB08/*l203c4/hashed_dictionary.e*/;
if((a2)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40CB16/*l203c11/hashed_dictionary.e*/);
}
if((((a2)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F40CB16/*l203c11/hashed_dictionary.e*/);
}
ds.p=0x0F40CB36/*l203c27/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a2))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F40CC08/*l204c4/hashed_dictionary.e*/;
_node=r188new_node(&ds,C,a1,a2,r194item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx));
ds.p=0x0F40CD18/*l205c12/hashed_dictionary.e*/;
r194put(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_node,_idx);
ds.p=0x0F40CE08/*l206c4/hashed_dictionary.e*/;
/*SFN*/(C->_count/*i7p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i7p*/),/*IC*/(T2)(INT8_C(1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F808A08/*l138c4/dictionary.e*/;
ac_ens(((/*RF2*/(C)->_count/*i7p*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),tmp0/*old*/)),"count = 1 + old count");
ds.p=0x0F808B08/*l139c4/dictionary.e*/;
ac_ens((a1)==((void*)(r188at(&ds,C,a2))),"v = at(k)");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188at(se_dump_stack*caller,T188* C,T0* a1){
T0* R=(void*)0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"at"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,4,"%R188%k%R7%Result%R186%idx%E2%node%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F403704/*l55c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F802A08/*l42c4/dictionary.e*/;
ac_req(r188has(&ds,C,a1),"has(k)");
fd.assertion_flag=1;
}
ds.p=0x0F403C0A/*l60c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F403C18/*l60c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F403C18/*l60c12/hashed_dictionary.e*/);
}
ds.p=0x0F403C38/*l60c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F403D0A/*l61c5/hashed_dictionary.e*/;
_node=r194item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F403F0A/*l63c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F403F28/*l63c20/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F403F28/*l63c20/hashed_dictionary.e*/);
}
ds.p=0x0F403F3C/*l63c30/hashed_dictionary.e*/;
if(r188key_safe_equal(&ds,C,(/*RF2*/(((T190*)_node))->_key/*i3p*/),a1)){
break;
}
ds.p=0x0F40410A/*l65c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40411A/*l65c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F40411A/*l65c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T190*)_node))->_next/*i3p*/);
}
ds.p=0x0F404308/*l67c4/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40431C/*l67c14/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F40431C/*l67c14/hashed_dictionary.e*/);
}
R=(/*RF2*/(((T190*)_node))->_item/*i3p*/);
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188fast_has(se_dump_stack*caller,T188* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"fast_has"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,4,"%R188%k%R7%Result%E6%idx%E2%node%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F405704/*l87c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F804C08/*l76c4/dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"k /= Void");
fd.assertion_flag=1;
}
ds.p=0x0F405C0A/*l92c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F405C18/*l92c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F405C18/*l92c12/hashed_dictionary.e*/);
}
ds.p=0x0F405C38/*l92c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F405D0A/*l93c5/hashed_dictionary.e*/;
_node=r194item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F405F0A/*l95c5/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)((_node)==((void*)((void*)0))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0F405F3C/*l95c30/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F405F32/*l95c25/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F405F32/*l95c25/hashed_dictionary.e*/);
}
ds.p=0x0F405F48/*l95c36/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)(((/*RF2*/(((T190*)_node))->_key/*i3p*/))==((void*)(a1))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0F40610A/*l97c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40611A/*l97c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F40611A/*l97c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T190*)_node))->_next/*i3p*/);
}
ds.p=0x0F406308/*l99c4/hashed_dictionary.e*/;
R=((T6)((_node)!=((void*)((void*)0))));
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188has(se_dump_stack*caller,T188* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"has"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,4,"%R188%k%R7%Result%E6%idx%E2%node%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F402804/*l40c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F802108/*l33c4/dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"k /= Void");
fd.assertion_flag=1;
}
ds.p=0x0F402D0A/*l45c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F402D18/*l45c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F402D18/*l45c12/hashed_dictionary.e*/);
}
ds.p=0x0F402D38/*l45c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F402E0A/*l46c5/hashed_dictionary.e*/;
_node=r194item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F40300A/*l48c5/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)((_node)==((void*)((void*)0))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0F403032/*l48c25/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F403050/*l48c40/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F403050/*l48c40/hashed_dictionary.e*/);
}
ds.p=0x0F403064/*l48c50/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)(r188key_safe_equal(&ds,C,(/*RF2*/(((T190*)_node))->_key/*i3p*/),a1)));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0F40320A/*l50c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40321A/*l50c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F40321A/*l50c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T190*)_node))->_next/*i3p*/);
}
ds.p=0x0F403408/*l52c4/hashed_dictionary.e*/;
R=((T6)((_node)!=((void*)((void*)0))));
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188prime_capacity(se_dump_stack*caller,T188* C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"prime_capacity"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,2,"%R188%a_capacity%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0FA08604/*l134c2/hash_table_size.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA0881E/*l136c15/hash_table_size.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"a_capacity > 0");
fd.assertion_flag=1;
}
ds.p=0x0FA08A08/*l138c4/hash_table_size.e*/;
R=(int32_t)(((uint32_t)(a1))+((uint32_t)(r2_ix_354747(&ds,a1,/*IC*/(T2)(INT8_C(2))))));
ds.p=0x0FA08B1C/*l139c14/hash_table_size.e*/;
if(r2_ix_62(&ds,R,/*IC*/(T2)(INT8_C(0)))){
ds.p=0x0FA08C0A/*l140c5/hash_table_size.e*/;
R=r188prime_number_ceiling(&ds,C,R);
}
else{
ds.p=0x0FA08E0A/*l142c5/hash_table_size.e*/;
R=r188prime_number_ceiling(&ds,C,/*RF1Maximum_integer*/INT32_C(2147483647));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA09116/*l145c11/hash_table_size.e*/;
ac_ens(r2_ix_6261(&ds,R,a1),"Result >= a_capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188prime_number_ceiling(se_dump_stack*caller,T188* C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"prime_number_ceiling"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,2,"%R188%integer%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0FA00F04/*l15c2/hash_table_size.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA01232/*l18c25/hash_table_size.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"is_positive");
fd.assertion_flag=1;
}
ds.p=0x0FA0141E/*l20c15/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(98317))){
ds.p=0x0FA01520/*l21c16/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(769)))){
ds.p=0x0FA01622/*l22c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(53)))){
ds.p=0x0FA01724/*l23c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(11)))){
ds.p=0x0FA01810/*l24c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(11));
}
else{
ds.p=0x0FA0192C/*l25c22/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(23)))){
ds.p=0x0FA01A10/*l26c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(23));
}
else{
ds.p=0x0FA01C10/*l28c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(53));
}
}
}
else{
ds.p=0x0FA01F24/*l31c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(193)))){
ds.p=0x0FA02026/*l32c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(97)))){
ds.p=0x0FA02112/*l33c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(97));
}
else{
ds.p=0x0FA02312/*l35c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(193));
}
}
else{
ds.p=0x0FA02626/*l38c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(389)))){
ds.p=0x0FA02712/*l39c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(389));
}
else{
ds.p=0x0FA02912/*l41c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(769));
}
}
}
}
else{
ds.p=0x0FA02E22/*l46c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(12289)))){
ds.p=0x0FA02F24/*l47c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(3079)))){
ds.p=0x0FA03026/*l48c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(1543)))){
ds.p=0x0FA03112/*l49c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(1543));
}
else{
ds.p=0x0FA03312/*l51c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(3079));
}
}
else{
ds.p=0x0FA03626/*l54c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(6151)))){
ds.p=0x0FA03712/*l55c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(6151));
}
else{
ds.p=0x0FA03912/*l57c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(12289));
}
}
}
else{
ds.p=0x0FA03D24/*l61c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(24593)))){
ds.p=0x0FA03E10/*l62c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(24593));
}
else{
ds.p=0x0FA03F2C/*l63c22/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(49157))){
ds.p=0x0FA04010/*l64c8/hash_table_size.e*/;
R=INT32_C(49157);
}
else{
ds.p=0x0FA04210/*l66c8/hash_table_size.e*/;
R=INT32_C(98317);
}
}
}
}
}
else{
ds.p=0x0FA04720/*l71c16/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(12582917))){
ds.p=0x0FA04822/*l72c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(1572869))){
ds.p=0x0FA04924/*l73c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(393241))){
ds.p=0x0FA04A26/*l74c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(196613))){
ds.p=0x0FA04B12/*l75c9/hash_table_size.e*/;
R=INT32_C(196613);
}
else{
ds.p=0x0FA04D12/*l77c9/hash_table_size.e*/;
R=INT32_C(393241);
}
}
else{
ds.p=0x0FA05026/*l80c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(786433))){
ds.p=0x0FA05112/*l81c9/hash_table_size.e*/;
R=INT32_C(786433);
}
else{
ds.p=0x0FA05312/*l83c9/hash_table_size.e*/;
R=INT32_C(1572869);
}
}
}
else{
ds.p=0x0FA05724/*l87c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(3145739))){
ds.p=0x0FA05810/*l88c8/hash_table_size.e*/;
R=INT32_C(3145739);
}
else{
ds.p=0x0FA0592C/*l89c22/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(6291469))){
ds.p=0x0FA05A10/*l90c8/hash_table_size.e*/;
R=INT32_C(6291469);
}
else{
ds.p=0x0FA05C10/*l92c8/hash_table_size.e*/;
R=INT32_C(12582917);
}
}
}
}
else{
ds.p=0x0FA06022/*l96c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(201326611))){
ds.p=0x0FA06124/*l97c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(50331653))){
ds.p=0x0FA06226/*l98c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(25165843))){
ds.p=0x0FA06312/*l99c9/hash_table_size.e*/;
R=INT32_C(25165843);
}
else{
ds.p=0x0FA06512/*l101c9/hash_table_size.e*/;
R=INT32_C(50331653);
}
}
else{
ds.p=0x0FA06826/*l104c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(100663319))){
ds.p=0x0FA06912/*l105c9/hash_table_size.e*/;
R=INT32_C(100663319);
}
else{
ds.p=0x0FA06B12/*l107c9/hash_table_size.e*/;
R=INT32_C(201326611);
}
}
}
else{
ds.p=0x0FA06F24/*l111c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(805306457))){
ds.p=0x0FA07026/*l112c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(402653189))){
ds.p=0x0FA07112/*l113c9/hash_table_size.e*/;
R=INT32_C(402653189);
}
else{
ds.p=0x0FA07312/*l115c9/hash_table_size.e*/;
R=INT32_C(805306457);
}
}
else{
ds.p=0x0FA07626/*l118c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(1610612741))){
ds.p=0x0FA07712/*l119c9/hash_table_size.e*/;
R=INT32_C(1610612741);
}
else{
ds.p=0x0FA07B12/*l123c9/hash_table_size.e*/;
R=INT32_C(2147483647);
}
}
}
}
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA08216/*l130c11/hash_table_size.e*/;
ac_ens(r2_ix_6261(&ds,R,r2max(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result >= integer.max(1)");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188should_increase_capacity(se_dump_stack*caller,T188* C,T2 a1,T2 a2){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"should_increase_capacity"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,3,"%R188%a_capacity%E2%a_count%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0FA09404/*l148c2/hash_table_size.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0FA09608/*l150c4/hash_table_size.e*/;
tmp0/*and then*/=((T6)(r2_ix_62(&ds,a2,(int32_t)(((uint32_t)(r2_ix_354747(&ds,a1,/*IC*/(T2)(INT8_C(3)))))*((uint32_t)(/*IC*/(T2)(INT8_C(2))))))));
if(tmp0/*and then*/){
ds.p=0x0FA0968C/*l150c70/hash_table_size.e*/;
tmp0/*and then*/=((T6)(r2_ix_60(&ds,a1,/*RF1Maximum_integer*/INT32_C(2147483647))));
}
R=((T6)(tmp0/*and then*/));
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T6 r188key_safe_equal(se_dump_stack*caller,T188* C,T0* a1,T0* a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"key_safe_equal"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,3,"%R188%k1%R7%k2%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F822E04/*l558c2/dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F823108/*l561c4/dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"k1 /= Void");
ds.p=0x0F823208/*l562c4/dictionary.e*/;
ac_req((a2)!=((void*)((void*)0)),"k2 /= Void");
fd.assertion_flag=1;
}
ds.p=0x0F82340E/*l564c7/dictionary.e*/;
if((a1)==((void*)(a2))){
ds.p=0x0F82350A/*l565c5/dictionary.e*/;
R=((T6)(1));
}
else{
ds.p=0x0F82361C/*l566c14/dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F823616/*l566c11/dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F823616/*l566c11/dictionary.e*/);
}
ds.p=0x0F823640/*l566c32/dictionary.e*/;
if(r7same_dynamic_type(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),a2)){
ds.p=0x0F82370A/*l567c5/dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F82371E/*l567c15/dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F82371E/*l567c15/dictionary.e*/);
}
ds.p=0x0F823736/*l567c27/dictionary.e*/;
R=((T6)(r7is_equal(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),a2)));
}
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188fast_at(se_dump_stack*caller,T188* C,T0* a1){
T0* R=(void*)0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"fast_at"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,4,"%R188%k%R7%Result%R186%idx%E2%node%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F406604/*l102c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F805508/*l85c4/dictionary.e*/;
ac_req(r188fast_has(&ds,C,a1),"fast_has(k)");
fd.assertion_flag=1;
}
ds.p=0x0F406B0A/*l107c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F406B18/*l107c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F406B18/*l107c12/hashed_dictionary.e*/);
}
ds.p=0x0F406B38/*l107c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F406C0A/*l108c5/hashed_dictionary.e*/;
_node=r194item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F406E14/*l110c10/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F406E0A/*l110c5/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F406E0A/*l110c5/hashed_dictionary.e*/);
}
ds.p=0x0F406E20/*l110c16/hashed_dictionary.e*/;
if(((/*RF2*/(((T190*)_node))->_key/*i3p*/))==((void*)(a1))){
break;
}
ds.p=0x0F40700A/*l112c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40701A/*l112c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F40701A/*l112c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T190*)_node))->_next/*i3p*/);
}
ds.p=0x0F407208/*l114c4/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40721C/*l114c14/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F40721C/*l114c14/hashed_dictionary.e*/);
}
R=(/*RF2*/(((T190*)_node))->_item/*i3p*/);
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188count(se_dump_stack*caller,T188* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,1,"%R188%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F402604/*l38c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=C->_count/*i7p*/;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04803620/*l54c16/traversable.e*/;
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,r188upper(&ds,C),/*RF1lower*/INT32_C(1)),/*IC*/(T2)(INT8_C(1)))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T0* r188fast_reference_at(se_dump_stack*caller,T188* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"fast_reference_at"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,4,"%R188%k%R7%Result%R186%idx%E2%node%R190%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F407504/*l117c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F805E08/*l94c4/dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"k /= Void");
ds.p=0x0F805F34/*l95c26/dictionary.e*/;
ac_req((R)==((void*)((void*)0)),"values_are_reference");
fd.assertion_flag=1;
}
ds.p=0x0F407A0A/*l122c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F407A18/*l122c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F407A18/*l122c12/hashed_dictionary.e*/);
}
ds.p=0x0F407A38/*l122c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F407B0A/*l123c5/hashed_dictionary.e*/;
_node=r194item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F407D0A/*l125c5/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)((_node)==((void*)((void*)0))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0F407D3C/*l125c30/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F407D32/*l125c25/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F407D32/*l125c25/hashed_dictionary.e*/);
}
ds.p=0x0F407D48/*l125c36/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)(((/*RF2*/(((T190*)_node))->_key/*i3p*/))==((void*)(a1))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0F407F0A/*l127c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F407F1A/*l127c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F407F1A/*l127c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T190*)_node))->_next/*i3p*/);
}
ds.p=0x0F40810E/*l129c7/hashed_dictionary.e*/;
if((_node)!=((void*)((void*)0))){
ds.p=0x0F40820A/*l130c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40821E/*l130c15/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(190))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F40821E/*l130c15/hashed_dictionary.e*/);
}
R=(/*RF2*/(((T190*)_node))->_item/*i3p*/);
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F806208/*l98c4/dictionary.e*/;
/*auto-unlock tmp0*/tmp0/*implies*/=((T6)(r188fast_has(&ds,C,a1)));
if(tmp0/*implies*/){
ds.p=0x0F806230/*l98c24/dictionary.e*/;
tmp0/*implies*/=((T6)((R)==((void*)(r188fast_at(&ds,C,a1)))));
}
else{
tmp0/*implies*/=((T6)(1));
}
ac_ens(tmp0/*implies*/,"fast_has(k) implies Result = fast_at(k)");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]*/T2 r188upper(se_dump_stack*caller,T188* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"upper"" HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,1,"%R188%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F811D04/*l285c2/dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F811F08/*l287c4/dictionary.e*/;
R=(/*RF2*/(C)->_count/*i7p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F812108/*l289c4/dictionary.e*/;
ac_ens((R)==((/*RF2*/(C)->_count/*i7p*/)),"Result = count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i188(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/
se_frame_descriptor se_ifd188={"invariant HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING]",1,0,"%R188%",1};

T188*se_i188(se_dump_stack*caller,T188*C){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
T6 tmp1;
/*INTERNAL_C_LOCAL list]*/
se_dump_stack ds;
ds.fd=&se_ifd188;
ds.current=((void*)&C);
ds.p=0x0F427202/*l626c1/hashed_dictionary.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
ds.p=0x0F427316/*l627c11/hashed_dictionary.e*/;
ac_inv(r2_ix_62(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(0))),"capacity > 0");
ds.p=0x0F427416/*l628c11/hashed_dictionary.e*/;
ac_inv(r2_ix_6261(&ds,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/)),"capacity >= count");
ds.p=0x0F42751A/*l629c13/hashed_dictionary.e*/;
ac_inv(r2in_range(&ds,(/*RF2*/(C)->_cache_user/*i7p*/),/*IC*/(T2)(INT8_C(-1)),(/*RF2*/(C)->_count/*i7p*/)),"cache_user.in_range(-1, count)");
ds.p=0x0F42761A/*l630c13/hashed_dictionary.e*/;
tmp0/*implies*/=((T6)(r2_ix_62(&ds,(/*RF2*/(C)->_cache_user/*i7p*/),/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*implies*/){
ds.p=0x0F427632/*l630c25/hashed_dictionary.e*/;
tmp0/*implies*/=((T6)(((/*RF2*/(C)->_cache_node/*i7p*/))!=((void*)((void*)0))));
}
else{
tmp0/*implies*/=((T6)(1));
}
ac_inv(tmp0/*implies*/,"cache_user > 0 implies cache_node /= Void");
ds.p=0x0F42771A/*l631c13/hashed_dictionary.e*/;
tmp1/*implies*/=((T6)(r2_ix_62(&ds,(/*RF2*/(C)->_cache_user/*i7p*/),/*IC*/(T2)(INT8_C(0)))));
if(tmp1/*implies*/){
ds.p=0x0F42774E/*l631c39/hashed_dictionary.e*/;
tmp1/*implies*/=((T6)(r2in_range(&ds,(/*RF2*/(C)->_cache_buckets/*i7p*/),/*IC*/(T2)(INT8_C(0)),r2_ix_45(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(1))))));
}
else{
tmp1/*implies*/=((T6)(1));
}
ac_inv(tmp1/*implies*/,"cache_user > 0 implies cache_buckets.in_range(0, capacity - 1)");
ds.p=0x0F427804/*l632c2/hashed_dictionary.e*/;
ac_inv(((/*RF2*/(C)->_free_nodes/*i7p*/))!=((void*)((void*)0)),"free_nodes /= Void");
ds.p=0x0F823C16/*l572c11/dictionary.e*/;
ac_inv(r2_ix_6261(&ds,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/)),"capacity >= count");
ds.fd->assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return C;
}/*--*/

/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/void r187set_item(se_dump_stack*caller,T187* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"set_item"" WEAK_REFERENCE[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]",1,1,"%R187%i%R184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11401A04/*l26c2/weak_reference.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11401D08/*l29c4/weak_reference.e*/;
/*SFN*/(C->_item/*ip*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11401F08/*l31c4/weak_reference.e*/;
ac_ens(((/*RF2*/(C)->_item/*ip*/))==((void*)(a1)),"item = i");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/T6 r184is_default(se_dump_stack*caller,T184* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default"" HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]",1,1,"%R184%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A08404/*l132c2/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x01A08D08/*l141c4/any.e*/;
R=((T6)((C)==((void*)(r184default(&ds,C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/T0* r184default(se_dump_stack*caller,T184* C){
T0* R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"default"" HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]",1,1,"%R184%Result%R184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A07D12/*l125c9/any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/void r184make(se_dump_stack*caller,T184* C,T0* a1,T8 a2,T0* a3){
void**locals[3];
static se_frame_descriptor fd={"make"" HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]",1,3,"%R184%i%R67%k%E8%n%R184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11002404/*l36c2/hashed_dictionary_node.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11002608/*l38c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_item/*i3p*/)=a1;
ds.p=0x11002708/*l39c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_key/*i3p*/)=a2;
ds.p=0x11002808/*l40c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_next/*i3p*/)=a3;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11002A08/*l42c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_item/*i3p*/))==((void*)(a1)),"item = i");
ds.p=0x11002B08/*l43c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_key/*i3p*/))==(a2),"key = k");
ds.p=0x11002C08/*l44c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_next/*i3p*/))==((void*)(a3)),"next = n");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/void r184set_next(se_dump_stack*caller,T184* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"set_next"" HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]",1,1,"%R184%n%R184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11001D04/*l29c2/hashed_dictionary_node.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11001F08/*l31c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_next/*i3p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11002108/*l33c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_next/*i3p*/))==((void*)(a1)),"next = n");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]*/void r184set_item(se_dump_stack*caller,T184* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"set_item"" HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]",1,1,"%R184%i%R67%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x11001604/*l22c2/hashed_dictionary_node.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
ds.p=0x11001808/*l24c4/hashed_dictionary_node.e*/;
/*SFN*/(C->_item/*i3p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x11001A08/*l26c4/hashed_dictionary_node.e*/;
ac_ens(((/*RF2*/(C)->_item/*i3p*/))==((void*)(a1)),"item = i");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/T0* r183item(se_dump_stack*caller,T183 C,T2 a1){
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"item"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]",1,2,"%E183%index%E2%Result%R184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C02504/*l37c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C02914/*l41c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
R=(C)[a1];
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/void r183put(se_dump_stack*caller,T183 C,T0* a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]",1,2,"%E183%element%R184%index%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C02D04/*l45c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C03214/*l50c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a2,/*IC*/(T2)(INT8_C(0))),"index >= 0");
fd.assertion_flag=1;
}
(C)[a2]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C03508/*l53c4/native_array.e*/;
ac_ens((r183item(&ds,C,a2))==((void*)(a1)),"item(index) = element");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/T6 r183all_default(se_dump_stack*caller,T183 C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _i=0;
T0* _v=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"all_default"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]",1,4,"%E183%upper%E2%Result%E6%i%E2%v%R184%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C2CC04/*l716c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C2D014/*l720c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x08C2D50A/*l725c5/native_array.e*/;
R=((T6)(1));
ds.p=0x08C2D60A/*l726c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x08C2D80E/*l728c7/native_array.e*/;
tmp0/*or else*/=((T6)(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*or else*/){
}
else{
ds.p=0x08C2D826/*l728c19/native_array.e*/;
tmp0/*or else*/=((T6)(r6_px_not(&ds,(T6)(R))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x08C2DA0A/*l730c5/native_array.e*/;
_v=r183item(&ds,C,_i);
ds.p=0x08C2DB10/*l731c8/native_array.e*/;
if((_v)!=((void*)((void*)0))){
ds.p=0x08C2DC0C/*l732c6/native_array.e*/;
if((_v)==((void*)((void*)0))){
error1("Call on a Void target.",0x08C2DC20/*l732c16/native_array.e*/);
}
if((((_v)->id))!=(INT16_C(184))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[XML2_NODE,POINTER].",0x08C2DC20/*l732c16/native_array.e*/);
}
R=((T6)(r184is_default(&ds,((T184*)_v))));
}
ds.p=0x08C2DE0A/*l734c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/void r183clear_all(se_dump_stack*caller,T183 C,T2 a1){
T0* _v=(void*)0;
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"clear_all"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]",1,3,"%E183%upper%E2%v%R184%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C20A04/*l522c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_v;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C20D14/*l525c10/native_array.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(-1))),"upper >= -1");
fd.assertion_flag=1;
}
ds.p=0x08C2120A/*l530c5/native_array.e*/;
_i=a1;
while(1){
ds.p=0x08C2140E/*l532c7/native_array.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x08C2160A/*l534c5/native_array.e*/;
r183put(&ds,C,_v,_i);
ds.p=0x08C2170A/*l535c5/native_array.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C21A08/*l538c4/native_array.e*/;
ac_ens(r183all_default(&ds,C,a1),"all_default(upper)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]*/T183 r183calloc(se_dump_stack*caller,T183 C,T2 a1){
T183 R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"calloc"" NATIVE_ARRAY[HASHED_DICTIONARY_NODE[XML2_NODE,POINTER]]",1,2,"%E183%nb_elements%E2%Result%E183%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x08C01B04/*l27c2/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C01F20/*l31c16/native_array.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"nb_elements > 0");
fd.assertion_flag=1;
}
R=new183(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x08C02216/*l34c11/native_array.e*/;
ac_ens(r183all_default(&ds,R,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result.all_default(nb_elements - 1)");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T0* r182new_node(se_dump_stack*caller,T182* C,T8 a1,T0* a2,T0* a3){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"new_node"" HASHED_DICTIONARY[POINTER,STRING]",1,4,"%R182%v%E8%k%R7%next%R192%Result%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F422404/*l548c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
locals[3]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F422708/*l551c4/hashed_dictionary.e*/;
if(((/*RF2*/(C)->_free_nodes/*i7p*/))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F42271C/*l551c14/hashed_dictionary.e*/);
}
if(((((/*RF2*/(C)->_free_nodes/*i7p*/))->id))!=(INT16_C(193))){
error1("Bad target type. The expected type is WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]].",0x0F42271C/*l551c14/hashed_dictionary.e*/);
}
R=(/*RF2*/((T193*)((/*RF2*/(C)->_free_nodes/*i7p*/)))->_item/*ip*/);
ds.p=0x0F42280E/*l552c7/hashed_dictionary.e*/;
if((R)==((void*)((void*)0))){
ds.p=0x0F422930/*l553c24/hashed_dictionary.e*/;
tmp0/*new*/=((T0*)(new192()));
r192make(&ds,((T192*)tmp0/*new*/),a1,a2,a3);
R=tmp0/*new*/;
/*tmp0.unlock*/
}
else{
ds.p=0x0F422B20/*l555c16/hashed_dictionary.e*/;
if(((/*RF2*/(C)->_free_nodes/*i7p*/))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F422B0A/*l555c5/hashed_dictionary.e*/);
}
if(((((/*RF2*/(C)->_free_nodes/*i7p*/))->id))!=(INT16_C(193))){
error1("Bad target type. The expected type is WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]].",0x0F422B0A/*l555c5/hashed_dictionary.e*/);
}
ds.p=0x0F422B40/*l555c32/hashed_dictionary.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F422B32/*l555c25/hashed_dictionary.e*/);
}
if((((R)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F422B32/*l555c25/hashed_dictionary.e*/);
}
r193set_item(&ds,(T193*)((/*RF2*/(C)->_free_nodes/*i7p*/)),(/*RF2*/(((T192*)R))->_next/*i3p*/));
ds.p=0x0F422C18/*l556c12/hashed_dictionary.e*/;
if((R)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F422C0A/*l556c5/hashed_dictionary.e*/);
}
if((((R)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F422C0A/*l556c5/hashed_dictionary.e*/);
}
ds.p=0x0F422C22/*l556c17/hashed_dictionary.e*/;
r192make(&ds,((T192*)R),a1,a2,a3);
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182is_empty(se_dump_stack*caller,T182* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty"" HASHED_DICTIONARY[POINTER,STRING]",1,1,"%R182%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F801504/*l21c2/dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F801808/*l24c4/dictionary.e*/;
R=((T6)(((/*RF2*/(C)->_count/*i7p*/))==(INT8_C(0))));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04803F20/*l63c16/traversable.e*/;
ac_ens((R)==(((/*RF2*/(C)->_count/*i7p*/))==(INT8_C(0))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/void r182create_with_capacity(se_dump_stack*caller,T182* C,T2 a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
T0* tmp1;
/*INTERNAL_C_LOCAL list]*/
void**locals[1];
static se_frame_descriptor fd={"create_with_capacity"" HASHED_DICTIONARY[POINTER,STRING]",1,1,"%R182%new_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F423004/*l560c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F423222/*l562c17/hashed_dictionary.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"new_capacity > 0");
fd.assertion_flag=1;
}
ds.p=0x0F423408/*l564c4/hashed_dictionary.e*/;
if(((tmp0/*ddt1*/=(r182common_free_nodes(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F423426/*l564c19/hashed_dictionary.e*/);
}
if((((tmp0/*ddt1*/)->id))!=(INT16_C(188))){
error1("Bad target type. The expected type is HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F423426/*l564c19/hashed_dictionary.e*/);
}
ds.p=0x0F42346E/*l564c55/hashed_dictionary.e*/;
/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]] ::= WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE]*//*SFN*/(C->_free_nodes/*i7p*/)=((void*)r188fast_reference_at(&ds,((T188*)tmp0/*ddt1*/),(T0*)(t[(C)->id])));
if(NULL!=(/*SFN*/(C->_free_nodes/*i7p*/))){
switch(((T0*)/*SFN*/(C->_free_nodes/*i7p*/))->id){
case 193:/*WEAK_REFERENCE[HASHED_DICTIONARY_NODE[POINTER,STRING]]*/
break;
default:
error1("Invalid ::= assignment (inserted type).",0x0F423408/*l564c4/hashed_dictionary.e*/);
}}
ds.p=0x0F42350E/*l565c7/hashed_dictionary.e*/;
if(((/*RF2*/(C)->_free_nodes/*i7p*/))==((void*)((void*)0))){
tmp1/*new*/=((T0*)(new193()));
r193set_item(&ds,((T193*)tmp1/*new*/),(void*)0);
/*SFN*/(C->_free_nodes/*i7p*/)=tmp1/*new*/;
/*tmp1.unlock*/
ds.p=0x0F42372E/*l567c23/hashed_dictionary.e*/;
if((/*reusing tmp1*/(tmp1/*ddt1*/=(r182common_free_nodes(&ds,C))))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F42370A/*l567c5/hashed_dictionary.e*/);
}
if((((tmp1/*ddt1*/)->id))!=(INT16_C(188))){
error1("Bad target type. The expected type is HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F42370A/*l567c5/hashed_dictionary.e*/);
}
ds.p=0x0F423736/*l567c27/hashed_dictionary.e*/;
r188add(&ds,((T188*)tmp1/*ddt1*/),(/*RF2*/(C)->_free_nodes/*i7p*/),(T0*)(t[(C)->id]));
}
ds.p=0x0F423908/*l569c4/hashed_dictionary.e*/;
/*SFN*/(C->_buckets/*i7p*/)=r191calloc(&ds,(/*RF2*/(C)->_buckets/*i7p*/),a1);
ds.p=0x0F423A08/*l570c4/hashed_dictionary.e*/;
/*SFN*/(C->_capacity/*i7p*/)=a1;
ds.p=0x0F423B08/*l571c4/hashed_dictionary.e*/;
/*SFN*/(C->_cache_user/*i7p*/)=/*IC*/(T2)(INT8_C(-1));
ds.p=0x0F423C08/*l572c4/hashed_dictionary.e*/;
/*SFN*/(C->_count/*i7p*/)=/*IC*/(T2)(INT8_C(0));
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/void r182increase_capacity(se_dump_stack*caller,T182* C){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
T2 tmp1;
/*INTERNAL_C_LOCAL list]*/
T2 _i=0;
T2 _idx=0;
T2 _new_capacity=0;
T191 _old_buckets=(void*)0;
T0* _node1=(void*)0;
T0* _node2=(void*)0;
void**locals[6];
static se_frame_descriptor fd={"increase_capacity"" HASHED_DICTIONARY[POINTER,STRING]",1,6,"%R182%i%E2%idx%E2%new_capacity%E2%old_buckets%E191%node1%R192%node2%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F41AF04/*l431c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&_i;
locals[1]=(void**)&_idx;
locals[2]=(void**)&_new_capacity;
locals[3]=(void**)&_old_buckets;
locals[4]=(void**)&_node1;
locals[5]=(void**)&_node2;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F41CE20/*l462c16/hashed_dictionary.e*/;
tmp0/*old*/=(/*RF2*/(C)->_count/*i7p*/);
ds.p=0x0F41CF26/*l463c19/hashed_dictionary.e*/;
tmp1/*old*/=(/*RF2*/(C)->_capacity/*i7p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F41B208/*l434c4/hashed_dictionary.e*/;
ac_req(r182should_increase_capacity(&ds,C,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/)),"should_increase_capacity(capacity, count)");
fd.assertion_flag=1;
}
ds.p=0x0F41B70A/*l439c5/hashed_dictionary.e*/;
_new_capacity=r182prime_capacity(&ds,C,r2_ix_43(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(1))));
ds.p=0x0F41B80A/*l440c5/hashed_dictionary.e*/;
_old_buckets=(/*RF2*/(C)->_buckets/*i7p*/);
ds.p=0x0F41B90A/*l441c5/hashed_dictionary.e*/;
/*SFN*/(C->_buckets/*i7p*/)=r191calloc(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_new_capacity);
ds.p=0x0F41BA0A/*l442c5/hashed_dictionary.e*/;
_i=r2_ix_45(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(1)));
ds.p=0x0F41BB0A/*l443c5/hashed_dictionary.e*/;
/*SFN*/(C->_capacity/*i7p*/)=_new_capacity;
while(1){
ds.p=0x0F41BD0E/*l445c7/hashed_dictionary.e*/;
if(r2_ix_60(&ds,_i,/*IC*/(T2)(INT8_C(0)))){
break;
}
ds.p=0x0F41C00C/*l448c6/hashed_dictionary.e*/;
_node1=r191item(&ds,_old_buckets,_i);
while(1){
ds.p=0x0F41C20C/*l450c6/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
break;
}
ds.p=0x0F41C40C/*l452c6/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C41E/*l452c15/hashed_dictionary.e*/);
}
if((((_node1)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F41C41E/*l452c15/hashed_dictionary.e*/);
}
_node2=(/*RF2*/(((T192*)_node1))->_next/*i3p*/);
ds.p=0x0F41C50C/*l453c6/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C51A/*l453c13/hashed_dictionary.e*/);
}
if((((_node1)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F41C51A/*l453c13/hashed_dictionary.e*/);
}
if(((/*RF2*/(((T192*)_node1))->_key/*i3p*/))==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C526/*l453c19/hashed_dictionary.e*/);
}
if(((((/*RF2*/(((T192*)_node1))->_key/*i3p*/))->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F41C526/*l453c19/hashed_dictionary.e*/);
}
ds.p=0x0F41C54A/*l453c37/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)((T7*)((/*RF2*/(((T192*)_node1))->_key/*i3p*/)))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F41C618/*l454c12/hashed_dictionary.e*/;
if((_node1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F41C60C/*l454c6/hashed_dictionary.e*/);
}
if((((_node1)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F41C60C/*l454c6/hashed_dictionary.e*/);
}
ds.p=0x0F41C63A/*l454c29/hashed_dictionary.e*/;
r192set_next(&ds,((T192*)_node1),r191item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx));
ds.p=0x0F41C71C/*l455c14/hashed_dictionary.e*/;
r191put(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_node1,_idx);
ds.p=0x0F41C80C/*l456c6/hashed_dictionary.e*/;
_node1=_node2;
}
ds.p=0x0F41CA0A/*l458c5/hashed_dictionary.e*/;
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
ds.p=0x0F41CC08/*l460c4/hashed_dictionary.e*/;
/*SFN*/(C->_cache_user/*i7p*/)=/*IC*/(T2)(INT8_C(-1));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F41CE08/*l462c4/hashed_dictionary.e*/;
ac_ens(((/*RF2*/(C)->_count/*i7p*/))==(tmp0/*old*/),"count = old count");
ds.p=0x0F41CF1A/*l463c13/hashed_dictionary.e*/;
ac_ens(r2_ix_62(&ds,(/*RF2*/(C)->_capacity/*i7p*/),tmp1/*old*/),"capacity > old capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/void r182add(se_dump_stack*caller,T182* C,T8 a1,T0* a2){
/*[INTERNAL_C_LOCAL list*/
T2 tmp0;
/*INTERNAL_C_LOCAL list]*/
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"add"" HASHED_DICTIONARY[POINTER,STRING]",1,4,"%R182%v%E8%k%R7%idx%E2%node%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F40C304/*l195c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F808A28/*l138c20/dictionary.e*/;
tmp0/*old*/=(/*RF2*/(C)->_count/*i7p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F808708/*l135c4/dictionary.e*/;
ac_req(r6_px_not(&ds,(T6)(r182has(&ds,C,a2))),"not has(k)");
fd.assertion_flag=1;
}
ds.p=0x0F40C708/*l199c4/hashed_dictionary.e*/;
/*SFN*/(C->_cache_user/*i7p*/)=/*IC*/(T2)(INT8_C(-1));
ds.p=0x0F40C80E/*l200c7/hashed_dictionary.e*/;
if(r182should_increase_capacity(&ds,C,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/))){
ds.p=0x0F40C90A/*l201c5/hashed_dictionary.e*/;
r182increase_capacity(&ds,C);
}
ds.p=0x0F40CB08/*l203c4/hashed_dictionary.e*/;
if((a2)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40CB16/*l203c11/hashed_dictionary.e*/);
}
if((((a2)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F40CB16/*l203c11/hashed_dictionary.e*/);
}
ds.p=0x0F40CB36/*l203c27/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a2))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F40CC08/*l204c4/hashed_dictionary.e*/;
_node=r182new_node(&ds,C,a1,a2,r191item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx));
ds.p=0x0F40CD18/*l205c12/hashed_dictionary.e*/;
r191put(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_node,_idx);
ds.p=0x0F40CE08/*l206c4/hashed_dictionary.e*/;
/*SFN*/(C->_count/*i7p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i7p*/),/*IC*/(T2)(INT8_C(1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F808A08/*l138c4/dictionary.e*/;
ac_ens(((/*RF2*/(C)->_count/*i7p*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),tmp0/*old*/)),"count = 1 + old count");
ds.p=0x0F808B08/*l139c4/dictionary.e*/;
ac_ens((a1)==(r182at(&ds,C,a2)),"v = at(k)");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T8 r182at(se_dump_stack*caller,T182* C,T0* a1){
T8 R=(void*)0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"at"" HASHED_DICTIONARY[POINTER,STRING]",1,4,"%R182%k%R7%Result%E8%idx%E2%node%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F403704/*l55c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F802A08/*l42c4/dictionary.e*/;
ac_req(r182has(&ds,C,a1),"has(k)");
fd.assertion_flag=1;
}
ds.p=0x0F403C0A/*l60c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F403C18/*l60c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F403C18/*l60c12/hashed_dictionary.e*/);
}
ds.p=0x0F403C38/*l60c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F403D0A/*l61c5/hashed_dictionary.e*/;
_node=r191item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F403F0A/*l63c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F403F28/*l63c20/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F403F28/*l63c20/hashed_dictionary.e*/);
}
ds.p=0x0F403F3C/*l63c30/hashed_dictionary.e*/;
if(r182key_safe_equal(&ds,C,(/*RF2*/(((T192*)_node))->_key/*i3p*/),a1)){
break;
}
ds.p=0x0F40410A/*l65c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40411A/*l65c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F40411A/*l65c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T192*)_node))->_next/*i3p*/);
}
ds.p=0x0F404308/*l67c4/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40431C/*l67c14/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F40431C/*l67c14/hashed_dictionary.e*/);
}
R=(/*RF2*/(((T192*)_node))->_item/*i3p*/);
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182fast_has(se_dump_stack*caller,T182* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"fast_has"" HASHED_DICTIONARY[POINTER,STRING]",1,4,"%R182%k%R7%Result%E6%idx%E2%node%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F405704/*l87c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F804C08/*l76c4/dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"k /= Void");
fd.assertion_flag=1;
}
ds.p=0x0F405C0A/*l92c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F405C18/*l92c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F405C18/*l92c12/hashed_dictionary.e*/);
}
ds.p=0x0F405C38/*l92c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F405D0A/*l93c5/hashed_dictionary.e*/;
_node=r191item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F405F0A/*l95c5/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)((_node)==((void*)((void*)0))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0F405F3C/*l95c30/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F405F32/*l95c25/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F405F32/*l95c25/hashed_dictionary.e*/);
}
ds.p=0x0F405F48/*l95c36/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)(((/*RF2*/(((T192*)_node))->_key/*i3p*/))==((void*)(a1))));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0F40610A/*l97c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40611A/*l97c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F40611A/*l97c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T192*)_node))->_next/*i3p*/);
}
ds.p=0x0F406308/*l99c4/hashed_dictionary.e*/;
R=((T6)((_node)!=((void*)((void*)0))));
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182has(se_dump_stack*caller,T182* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"has"" HASHED_DICTIONARY[POINTER,STRING]",1,4,"%R182%k%R7%Result%E6%idx%E2%node%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F402804/*l40c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F802108/*l33c4/dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"k /= Void");
fd.assertion_flag=1;
}
ds.p=0x0F402D0A/*l45c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F402D18/*l45c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F402D18/*l45c12/hashed_dictionary.e*/);
}
ds.p=0x0F402D38/*l45c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F402E0A/*l46c5/hashed_dictionary.e*/;
_node=r191item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F40300A/*l48c5/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)((_node)==((void*)((void*)0))));
if(tmp0/*or else*/){
}
else{
ds.p=0x0F403032/*l48c25/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F403050/*l48c40/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F403050/*l48c40/hashed_dictionary.e*/);
}
ds.p=0x0F403064/*l48c50/hashed_dictionary.e*/;
tmp0/*or else*/=((T6)(r182key_safe_equal(&ds,C,(/*RF2*/(((T192*)_node))->_key/*i3p*/),a1)));
}
if(tmp0/*or else*/){
break;
}
ds.p=0x0F40320A/*l50c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40321A/*l50c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F40321A/*l50c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T192*)_node))->_next/*i3p*/);
}
ds.p=0x0F403408/*l52c4/hashed_dictionary.e*/;
R=((T6)((_node)!=((void*)((void*)0))));
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/void r182make(se_dump_stack*caller,T182* C){
static se_frame_descriptor fd={"make"" HASHED_DICTIONARY[POINTER,STRING]",1,0,"%R182%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F424204/*l578c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F424808/*l584c4/hashed_dictionary.e*/;
r182create_with_capacity(&ds,C,/*RF1Default_size*/INT32_C(53));
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F424A08/*l586c4/hashed_dictionary.e*/;
ac_ens(((/*RF2*/(C)->_capacity/*i7p*/))==(/*RF1Default_size*/INT32_C(53)),"capacity = Default_size");
ds.p=0x0F821908/*l537c4/dictionary.e*/;
ac_ens(r182is_empty(&ds,C),"is_empty");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182prime_capacity(se_dump_stack*caller,T182* C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"prime_capacity"" HASHED_DICTIONARY[POINTER,STRING]",1,2,"%R182%a_capacity%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0FA08604/*l134c2/hash_table_size.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA0881E/*l136c15/hash_table_size.e*/;
ac_req(r2_ix_62(&ds,a1,/*IC*/(T2)(INT8_C(0))),"a_capacity > 0");
fd.assertion_flag=1;
}
ds.p=0x0FA08A08/*l138c4/hash_table_size.e*/;
R=(int32_t)(((uint32_t)(a1))+((uint32_t)(r2_ix_354747(&ds,a1,/*IC*/(T2)(INT8_C(2))))));
ds.p=0x0FA08B1C/*l139c14/hash_table_size.e*/;
if(r2_ix_62(&ds,R,/*IC*/(T2)(INT8_C(0)))){
ds.p=0x0FA08C0A/*l140c5/hash_table_size.e*/;
R=r182prime_number_ceiling(&ds,C,R);
}
else{
ds.p=0x0FA08E0A/*l142c5/hash_table_size.e*/;
R=r182prime_number_ceiling(&ds,C,/*RF1Maximum_integer*/INT32_C(2147483647));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA09116/*l145c11/hash_table_size.e*/;
ac_ens(r2_ix_6261(&ds,R,a1),"Result >= a_capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182prime_number_ceiling(se_dump_stack*caller,T182* C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"prime_number_ceiling"" HASHED_DICTIONARY[POINTER,STRING]",1,2,"%R182%integer%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0FA00F04/*l15c2/hash_table_size.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA01232/*l18c25/hash_table_size.e*/;
ac_req(r2_ix_6261(&ds,a1,/*IC*/(T2)(INT8_C(0))),"is_positive");
fd.assertion_flag=1;
}
ds.p=0x0FA0141E/*l20c15/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(98317))){
ds.p=0x0FA01520/*l21c16/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(769)))){
ds.p=0x0FA01622/*l22c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(53)))){
ds.p=0x0FA01724/*l23c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(11)))){
ds.p=0x0FA01810/*l24c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(11));
}
else{
ds.p=0x0FA0192C/*l25c22/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(23)))){
ds.p=0x0FA01A10/*l26c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(23));
}
else{
ds.p=0x0FA01C10/*l28c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(53));
}
}
}
else{
ds.p=0x0FA01F24/*l31c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(193)))){
ds.p=0x0FA02026/*l32c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT8_C(97)))){
ds.p=0x0FA02112/*l33c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT8_C(97));
}
else{
ds.p=0x0FA02312/*l35c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(193));
}
}
else{
ds.p=0x0FA02626/*l38c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(389)))){
ds.p=0x0FA02712/*l39c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(389));
}
else{
ds.p=0x0FA02912/*l41c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(769));
}
}
}
}
else{
ds.p=0x0FA02E22/*l46c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(12289)))){
ds.p=0x0FA02F24/*l47c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(3079)))){
ds.p=0x0FA03026/*l48c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(1543)))){
ds.p=0x0FA03112/*l49c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(1543));
}
else{
ds.p=0x0FA03312/*l51c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(3079));
}
}
else{
ds.p=0x0FA03626/*l54c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(6151)))){
ds.p=0x0FA03712/*l55c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(6151));
}
else{
ds.p=0x0FA03912/*l57c9/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(12289));
}
}
}
else{
ds.p=0x0FA03D24/*l61c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,/*IC*/(T2)(INT16_C(24593)))){
ds.p=0x0FA03E10/*l62c8/hash_table_size.e*/;
R=/*IC*/(T2)(INT16_C(24593));
}
else{
ds.p=0x0FA03F2C/*l63c22/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(49157))){
ds.p=0x0FA04010/*l64c8/hash_table_size.e*/;
R=INT32_C(49157);
}
else{
ds.p=0x0FA04210/*l66c8/hash_table_size.e*/;
R=INT32_C(98317);
}
}
}
}
}
else{
ds.p=0x0FA04720/*l71c16/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(12582917))){
ds.p=0x0FA04822/*l72c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(1572869))){
ds.p=0x0FA04924/*l73c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(393241))){
ds.p=0x0FA04A26/*l74c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(196613))){
ds.p=0x0FA04B12/*l75c9/hash_table_size.e*/;
R=INT32_C(196613);
}
else{
ds.p=0x0FA04D12/*l77c9/hash_table_size.e*/;
R=INT32_C(393241);
}
}
else{
ds.p=0x0FA05026/*l80c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(786433))){
ds.p=0x0FA05112/*l81c9/hash_table_size.e*/;
R=INT32_C(786433);
}
else{
ds.p=0x0FA05312/*l83c9/hash_table_size.e*/;
R=INT32_C(1572869);
}
}
}
else{
ds.p=0x0FA05724/*l87c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(3145739))){
ds.p=0x0FA05810/*l88c8/hash_table_size.e*/;
R=INT32_C(3145739);
}
else{
ds.p=0x0FA0592C/*l89c22/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(6291469))){
ds.p=0x0FA05A10/*l90c8/hash_table_size.e*/;
R=INT32_C(6291469);
}
else{
ds.p=0x0FA05C10/*l92c8/hash_table_size.e*/;
R=INT32_C(12582917);
}
}
}
}
else{
ds.p=0x0FA06022/*l96c17/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(201326611))){
ds.p=0x0FA06124/*l97c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(50331653))){
ds.p=0x0FA06226/*l98c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(25165843))){
ds.p=0x0FA06312/*l99c9/hash_table_size.e*/;
R=INT32_C(25165843);
}
else{
ds.p=0x0FA06512/*l101c9/hash_table_size.e*/;
R=INT32_C(50331653);
}
}
else{
ds.p=0x0FA06826/*l104c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(100663319))){
ds.p=0x0FA06912/*l105c9/hash_table_size.e*/;
R=INT32_C(100663319);
}
else{
ds.p=0x0FA06B12/*l107c9/hash_table_size.e*/;
R=INT32_C(201326611);
}
}
}
else{
ds.p=0x0FA06F24/*l111c18/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(805306457))){
ds.p=0x0FA07026/*l112c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(402653189))){
ds.p=0x0FA07112/*l113c9/hash_table_size.e*/;
R=INT32_C(402653189);
}
else{
ds.p=0x0FA07312/*l115c9/hash_table_size.e*/;
R=INT32_C(805306457);
}
}
else{
ds.p=0x0FA07626/*l118c19/hash_table_size.e*/;
if(r2_ix_6061(&ds,a1,INT32_C(1610612741))){
ds.p=0x0FA07712/*l119c9/hash_table_size.e*/;
R=INT32_C(1610612741);
}
else{
ds.p=0x0FA07B12/*l123c9/hash_table_size.e*/;
R=INT32_C(2147483647);
}
}
}
}
}
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0FA08216/*l130c11/hash_table_size.e*/;
ac_ens(r2_ix_6261(&ds,R,r2max(&ds,a1,/*IC*/(T2)(INT8_C(1)))),"Result >= integer.max(1)");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182should_increase_capacity(se_dump_stack*caller,T182* C,T2 a1,T2 a2){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
/*INTERNAL_C_LOCAL list]*/
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"should_increase_capacity"" HASHED_DICTIONARY[POINTER,STRING]",1,3,"%R182%a_capacity%E2%a_count%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0FA09404/*l148c2/hash_table_size.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0FA09608/*l150c4/hash_table_size.e*/;
tmp0/*and then*/=((T6)(r2_ix_62(&ds,a2,(int32_t)(((uint32_t)(r2_ix_354747(&ds,a1,/*IC*/(T2)(INT8_C(3)))))*((uint32_t)(/*IC*/(T2)(INT8_C(2))))))));
if(tmp0/*and then*/){
ds.p=0x0FA0968C/*l150c70/hash_table_size.e*/;
tmp0/*and then*/=((T6)(r2_ix_60(&ds,a1,/*RF1Maximum_integer*/INT32_C(2147483647))));
}
R=((T6)(tmp0/*and then*/));
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T6 r182key_safe_equal(se_dump_stack*caller,T182* C,T0* a1,T0* a2){
T6 R=0;
void**locals[3];
static se_frame_descriptor fd={"key_safe_equal"" HASHED_DICTIONARY[POINTER,STRING]",1,3,"%R182%k1%R7%k2%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F822E04/*l558c2/dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F823108/*l561c4/dictionary.e*/;
ac_req((a1)!=((void*)((void*)0)),"k1 /= Void");
ds.p=0x0F823208/*l562c4/dictionary.e*/;
ac_req((a2)!=((void*)((void*)0)),"k2 /= Void");
fd.assertion_flag=1;
}
ds.p=0x0F82340E/*l564c7/dictionary.e*/;
if((a1)==((void*)(a2))){
ds.p=0x0F82350A/*l565c5/dictionary.e*/;
R=((T6)(1));
}
else{
ds.p=0x0F82361C/*l566c14/dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F823616/*l566c11/dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F823616/*l566c11/dictionary.e*/);
}
ds.p=0x0F823640/*l566c32/dictionary.e*/;
if(r7same_dynamic_type(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),a2)){
ds.p=0x0F82370A/*l567c5/dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F82371E/*l567c15/dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F82371E/*l567c15/dictionary.e*/);
}
ds.p=0x0F823736/*l567c27/dictionary.e*/;
R=((T6)(r7is_equal(&ds,se_i7(&ds,((T7*)(((T7*)a1)))),a2)));
}
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T8 r182fast_at(se_dump_stack*caller,T182* C,T0* a1){
T8 R=(void*)0;
T2 _idx=0;
T0* _node=(void*)0;
void**locals[4];
static se_frame_descriptor fd={"fast_at"" HASHED_DICTIONARY[POINTER,STRING]",1,4,"%R182%k%R7%Result%E8%idx%E2%node%R192%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F406604/*l102c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_idx;
locals[3]=(void**)&_node;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F805508/*l85c4/dictionary.e*/;
ac_req(r182fast_has(&ds,C,a1),"fast_has(k)");
fd.assertion_flag=1;
}
ds.p=0x0F406B0A/*l107c5/hashed_dictionary.e*/;
if((a1)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F406B18/*l107c12/hashed_dictionary.e*/);
}
if((((a1)->id))!=(INT8_C(7))){
error1("Bad target type. The expected type is STRING.",0x0F406B18/*l107c12/hashed_dictionary.e*/);
}
ds.p=0x0F406B38/*l107c28/hashed_dictionary.e*/;
_idx=r2_ix_359292(&ds,r7hash_code(&ds,se_i7(&ds,((T7*)(((T7*)a1))))),(/*RF2*/(C)->_capacity/*i7p*/));
ds.p=0x0F406C0A/*l108c5/hashed_dictionary.e*/;
_node=r191item(&ds,(/*RF2*/(C)->_buckets/*i7p*/),_idx);
while(1){
ds.p=0x0F406E14/*l110c10/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F406E0A/*l110c5/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F406E0A/*l110c5/hashed_dictionary.e*/);
}
ds.p=0x0F406E20/*l110c16/hashed_dictionary.e*/;
if(((/*RF2*/(((T192*)_node))->_key/*i3p*/))==((void*)(a1))){
break;
}
ds.p=0x0F40700A/*l112c5/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40701A/*l112c13/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F40701A/*l112c13/hashed_dictionary.e*/);
}
_node=(/*RF2*/(((T192*)_node))->_next/*i3p*/);
}
ds.p=0x0F407208/*l114c4/hashed_dictionary.e*/;
if((_node)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F40721C/*l114c14/hashed_dictionary.e*/);
}
if((((_node)->id))!=(INT16_C(192))){
error1("Bad target type. The expected type is HASHED_DICTIONARY_NODE[POINTER,STRING].",0x0F40721C/*l114c14/hashed_dictionary.e*/);
}
R=(/*RF2*/(((T192*)_node))->_item/*i3p*/);
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182count(se_dump_stack*caller,T182* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count"" HASHED_DICTIONARY[POINTER,STRING]",1,1,"%R182%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F402604/*l38c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=C->_count/*i7p*/;
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x04803620/*l54c16/traversable.e*/;
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,r182upper(&ds,C),/*RF1lower*/INT32_C(1)),/*IC*/(T2)(INT8_C(1)))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/
T0*oBC122common_free_nodes=(void*)0;
int fBC122common_free_nodes=0;

/*HASHED_DICTIONARY[POINTER,STRING]*/T0* r182common_free_nodes(se_dump_stack*caller,T182* C){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* _fn=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"common_free_nodes"" HASHED_DICTIONARY[POINTER,STRING]",1,2,"%R182%Result%R185%fn%R189%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F420F04/*l527c2/hashed_dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&oBC122common_free_nodes;
locals[1]=(void**)&_fn;
set_dump_stack_top(&ds);/*link*/
if(fBC122common_free_nodes==0){fBC122common_free_nodes=1;{
tmp0/*new*/=((T0*)(new189()));
r189set_item(&ds,((T189*)tmp0/*new*/),(void*)0);
_fn=tmp0/*new*/;
/*tmp0.unlock*/
ds.p=0x0F4214E8/*l532c116/hashed_dictionary.e*/;
/*reusing tmp0*/tmp0/*new*/=((T0*)(new188()));
r188special_common_dictionary(&ds,((T188*)tmp0/*new*/),_fn);
oBC122common_free_nodes=tmp0/*new*/;
/*tmp0.unlock*/
se_i188(&ds,((T188*)(oBC122common_free_nodes)));ds.p=0x0F421516/*l533c11/hashed_dictionary.e*/;
if((/*no_dispatch.e*/oBC122common_free_nodes)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F421508/*l533c4/hashed_dictionary.e*/);
}
if((((/*no_dispatch.e*/oBC122common_free_nodes)->id))!=(INT16_C(188))){
error1("Bad target type. The expected type is HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F421508/*l533c4/hashed_dictionary.e*/);
}
ds.p=0x0F42151E/*l533c15/hashed_dictionary.e*/;
if((/*no_dispatch.e*/oBC122common_free_nodes)==((void*)((void*)0))){
error1("Call on a Void target.",0x0F421526/*l533c19/hashed_dictionary.e*/);
}
if((((/*no_dispatch.e*/oBC122common_free_nodes)->id))!=(INT16_C(188))){
error1("Bad target type. The expected type is HASHED_DICTIONARY[WEAK_REFERENCE[ANY_HASHED_DICTIONARY_NODE],STRING].",0x0F421526/*l533c19/hashed_dictionary.e*/);
}
r188add(&ds,((T188*)/*no_dispatch.e*/oBC122common_free_nodes),_fn,(T0*)(t[(/*no_dispatch.e*/oBC122common_free_nodes)->id]));
}
fBC122common_free_nodes=2;}
else{
ac_req(fBC122common_free_nodes==2, "Recursive once function.");
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return oBC122common_free_nodes;
}/*--*/

/*HASHED_DICTIONARY[POINTER,STRING]*/T2 r182upper(se_dump_stack*caller,T182* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"upper"" HASHED_DICTIONARY[POINTER,STRING]",1,1,"%R182%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x0F811D04/*l285c2/dictionary.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
ds.p=0x0F811F08/*l287c4/dictionary.e*/;
R=(/*RF2*/(C)->_count/*i7p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
ds.p=0x0F812108/*l289c4/dictionary.e*/;
ac_ens((R)==((/*RF2*/(C)->_count/*i7p*/)),"Result = count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i182(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/
se_frame_descriptor se_ifd182={"invariant HASHED_DICTIONARY[POINTER,STRING]",1,0,"%R182%",1};

T182*se_i182(se_dump_stack*caller,T182*C){
/*[INTERNAL_C_LOCAL list*/
T6 tmp0;
T6 tmp1;
/*INTERNAL_C_LOCAL list]*/
se_dump_stack ds;
ds.fd=&se_ifd182;
ds.current=((void*)&C);
ds.p=0x0F427202/*l626c1/hashed_dictionary.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
ds.p=0x0F427316/*l627c11/hashed_dictionary.e*/;
ac_inv(r2_ix_62(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(0))),"capacity > 0");
ds.p=0x0F427416/*l628c11/hashed_dictionary.e*/;
ac_inv(r2_ix_6261(&ds,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/)),"capacity >= count");
ds.p=0x0F42751A/*l629c13/hashed_dictionary.e*/;
ac_inv(r2in_range(&ds,(/*RF2*/(C)->_cache_user/*i7p*/),/*IC*/(T2)(INT8_C(-1)),(/*RF2*/(C)->_count/*i7p*/)),"cache_user.in_range(-1, count)");
ds.p=0x0F42761A/*l630c13/hashed_dictionary.e*/;
tmp0/*implies*/=((T6)(r2_ix_62(&ds,(/*RF2*/(C)->_cache_user/*i7p*/),/*IC*/(T2)(INT8_C(0)))));
if(tmp0/*implies*/){
ds.p=0x0F427632/*l630c25/hashed_dictionary.e*/;
tmp0/*implies*/=((T6)(((/*RF2*/(C)->_cache_node/*i7p*/))!=((void*)((void*)0))));
}
else{
tmp0/*implies*/=((T6)(1));
}
ac_inv(tmp0/*implies*/,"cache_user > 0 implies cache_node /= Void");
ds.p=0x0F42771A/*l631c13/hashed_dictionary.e*/;
tmp1/*implies*/=((T6)(r2_ix_62(&ds,(/*RF2*/(C)->_cache_user/*i7p*/),/*IC*/(T2)(INT8_C(0)))));
if(tmp1/*implies*/){
ds.p=0x0F42774E/*l631c39/hashed_dictionary.e*/;
tmp1/*implies*/=((T6)(r2in_range(&ds,(/*RF2*/(C)->_cache_buckets/*i7p*/),/*IC*/(T2)(INT8_C(0)),r2_ix_45(&ds,(/*RF2*/(C)->_capacity/*i7p*/),/*IC*/(T2)(INT8_C(1))))));
}
else{
tmp1/*implies*/=((T6)(1));
}
ac_inv(tmp1/*implies*/,"cache_user > 0 implies cache_buckets.in_range(0, capacity - 1)");
ds.p=0x0F427804/*l632c2/hashed_dictionary.e*/;
ac_inv(((/*RF2*/(C)->_free_nodes/*i7p*/))!=((void*)((void*)0)),"free_nodes /= Void");
ds.p=0x0F823C16/*l572c11/dictionary.e*/;
ac_inv(r2_ix_6261(&ds,(/*RF2*/(C)->_capacity/*i7p*/),(/*RF2*/(C)->_count/*i7p*/)),"capacity >= count");
ds.fd->assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return C;
}/*--*/

#ifdef __cplusplus
}
#endif
